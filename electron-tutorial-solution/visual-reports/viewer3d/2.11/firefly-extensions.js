
(function() {

'use strict';


var av = Autodesk.Viewing,
    AVU = av.UI;

/**
 * AnimationExtension adds a toolbar with buttons (play/pause/forward/backward/goto start/end)
 * and timeline scrubber to control animation playback.
 */
var AnimationExtension = function(viewer, options) {
    av.Extension.call(this, viewer, options);
    this.viewer = viewer;
    this.animTools = null;
    this.animToolsId = "animationTools";
    this.playButton = null;
    this.prevAnimationTime = -1;
};

AnimationExtension.prototype = Object.create(av.Extension.prototype);
AnimationExtension.prototype.constructor = AnimationExtension;

/**
 * Converts seconds into Hours:Minutes:Seconds String
 * @param {Number} time in seconds
 * @returns {string}
 * @private
 */
function convertSecsToHMS(time) {
    var sign = "";
    if (time < 0) {sign="-"; time = -time;}
    var hrs = ~~(time / 3600);
    var mins = ~~((time % 3600) / 60);
    var secs = time % 60;
    var ret = sign;
    if (hrs > 0)
        ret += hrs + ":" + (mins < 10 ? "0" : "");
    ret += mins + ":" + (secs < 10 ? "0" : "");
    ret += secs.toFixed(2);
    return ret;
}

AnimationExtension.prototype.load = function() {
    var viewer = this.viewer;

    this.onPlayCallbackBinded = this.onPlayCallback.bind(this);
    this.onCameraChangeBinded = this.onCameraChange.bind(this);
    this.onExplodeBinded = this.onExplode.bind(this);
    this.onResizeBinded = this.onResize.bind(this);
    this.onEscapeBinded = this.onEscape.bind(this);

    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
    viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeBinded);
    viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
    viewer.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, this.onEscapeBinded);

    // init animations after object tree created and geometry loaded
    if (viewer.model && viewer.model.isObjectTreeCreated()) {
        this.onAnimationReady();
    } else {
        this.onAnimationReadyBinded = this.onAnimationReady.bind(this);
        viewer.addEventListener(Autodesk.Viewing.ANIMATION_READY_EVENT, this.onAnimationReadyBinded);
    }

    return true;
};

AnimationExtension.prototype.unload = function () {
    var viewer = this.viewer;

    if (this.onAnimationReadyBinded) {
        viewer.removeEventListener(Autodesk.Viewing.ANIMATION_READY_EVENT, this.onAnimationReadyBinded);
        this.onAnimationReadyBinded = null;
    }

    // stop animations
    this.rewind();
    viewer.impl.invalidate(true, true, true); // Required to reset animations when Extension unloads and viewer remains.

    this.onPlayCallbackBinded = null;

    if (this.animTools) {
        this.animTools.removeControl(this.animTools.timeText.getId());
        this.animTools.removeControl(this.animTools.timeline.getId());
        this.animTools.removeControl(this.animTools.timeLeftText.getId());
        this.animTools.removeControl(this.animTools.forwardButton.getId());
        this.animTools.removeControl(this.animTools.backwardButton.getId());
        this.animTools.removeControl(this.animTools.closeButton.getId());
    }

    if (this.toolbar) {
        this.toolbar.removeControl(this.animTools);
        this.toolbar.container.parentNode.removeChild(this.toolbar.container);
        this.toolbar = null;
    }

    if (this.playButton) {
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            toolbar.getControl(av.TOOLBAR.MODELTOOLSID).removeControl(this.playButton.getId());
        }
    }

    // Remove event listeners
    viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
    viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, this.onExplodeBinded);
    viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.onResizeBinded);
    viewer.removeEventListener(av.ESCAPE_EVENT, this.onEscapeBinded);

    if (this.onToolbarCreatedBinded) {
        viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }

    return true;
};

/**
 * Plays the animation. Invoke pause() to stop the animation.
 */
AnimationExtension.prototype.play = function() {

    if (this.isPlaying()) {
        return;
    }

    this.resetExplode(0, true);

    var viewer = this.viewer;
    var animator = viewer.impl.keyFrameAnimator;
    if (!animator) return;

    // restore previous animation if set
    if (this.prevAnimationTime > 0) {
        animator.goto(this.prevAnimationTime);
        this.prevAnimationTime = -1;
    }

    animator.play(0, this.onPlayCallbackBinded);

    this.updatePlayButton(animator.isPaused);
    if (viewer.toolbar) {
        viewer.toolbar.addClass('toolbar-animationMenuplacer');
    }
    if (this.animTools) {
        this.animTools.setVisible(true);
        if (!this.animTools.isPositionAdjusted) {
            this.adjustToolbarPosition();
            this.animTools.isPositionAdjusted = true;
        }
    }
};

/**
 * Pauses an active animation. Can resume by calling play()
 */
AnimationExtension.prototype.pause = function() {

    if (this.isPaused()) {
        return;
    }

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    animator.pause();

    // UI stuff
    this.updatePlayButton(animator.isPaused);
};

/**
 * Whether the animation is currently playing.
 * Always returns the opposite of isPaused()
 * @returns {Boolean}
 */
AnimationExtension.prototype.isPlaying = function() {

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return false;
    return animator.isPlaying && !animator.isPaused;
};

/**
 * Wether the animation is currently paused.
 * Always returns the opposite of isPlaying()
 * @returns {Boolean}
 */
AnimationExtension.prototype.isPaused = function() {

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return false;
    return animator.isPaused;
};

/**
 * Pauses and rewinds the animation.
 */
AnimationExtension.prototype.rewind = function() {
    this.setTimelineValue(0);
};

/**
 * Sets the animation at the very beginning (0), at the end(1) or anywhere in between.
 * For example, use value 0.5 to set the animation half way through it's completion.
 * Will pause a playing animation.
 *
 * @param {Number} scale - value between 0 and 1
 */
AnimationExtension.prototype.setTimelineValue = function(scale) {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    scale = Math.min(Math.max(0,scale), 1);
    var time = scale * animator.duration;
    animator.goto(time);
    this.updateUI();
};

/**
 * Sets animation onto the previous keyframe.
 * Will pause the animation if playing.
 */
AnimationExtension.prototype.prevKeyframe = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    animator.prev();
    this.updateUI();
};

/**
 * Sets animation onto the next keyframe.
 * Will pause the animation if playing.
 */
AnimationExtension.prototype.nextKeyframe = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    animator.next();
    this.updateUI();
};

/**
 * Returns how many seconds does the animation take to complete.
 * See also:
 * - getDurationLabel()
 * - getCurrentTime()
 * @return {Number}
 */
AnimationExtension.prototype.getDuration = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return 0;
    return animator.duration;
};

/**
 * Returns duration as a formatted String h:mm:ss (hours:minutes:seconds)
 * See also:
 * - getDuration()
 * - getCurrentTimeLabel()
 * @returns {string}
 */
AnimationExtension.prototype.getDurationLabel = function() {
    return convertSecsToHMS(this.getDuration());
};

/**
 * Returns the elapsed time (in seconds) of the animation.
 * See also:
 * - getDuration()
 * - getCurrentTimeLabel()
 * @return {Number}
 */
AnimationExtension.prototype.getCurrentTime = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return 0;
    return animator.currentTime;
};

/**
 * Returns the current animation time as a formatted String h:mm:ss (hours:minutes:seconds)
 * See also:
 * - getCurrentTime()
 * - getDurationLabel()
 * @returns {string}
 */
AnimationExtension.prototype.getCurrentTimeLabel = function() {
    return convertSecsToHMS(this.getCurrentTime());
};



/**
 * @private
 */
AnimationExtension.prototype.onAnimationReady = function() {
    var viewer = this.viewer;

    if (this.onAnimationReadyBinded) {
        viewer.removeEventListener(Autodesk.Viewing.ANIMATION_READY_EVENT, this.onAnimationReadyBinded);
        this.onAnimationReadyBinded = null;
    }

    // Check for animator class
    if (!viewer.impl.keyFrameAnimator)
        return;

    // Add the ui only if an animation is available.
    if (viewer.toolbar && viewer.modelTools) {
        this.onToolbarCreated();
    } else {
        this.onToolbarCreatedBinded = this.onToolbarCreated.bind(this);
        viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
    }
};

/**
 *
 * @private
 */
AnimationExtension.prototype.updateUI = function() {

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!this.animTools || !animator) {
        return;
    }
    this.animTools.input.value = animator.duration > 0 ? animator.currentTime / animator.duration * 100 : 0;
    this.animTools.lapse.value = convertSecsToHMS(animator.currentTime);
    this.animTools.lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);
    this.updatePlayButton(animator.isPaused);
    this.updateToolbarBackground();
};

/**
 * @private
 */
AnimationExtension.prototype.onPlayCallback = function(value) {

    // TODO: We should be able to replace this whole method body with a call to update().
    // The only problem for now is taht we would also need to change KeyFrameAnimator because
    // the onPlayCallback() is being invoked BEFORE the animation is paused.
    if (!this.animTools) return;

    var animator = this.viewer.impl.keyFrameAnimator;
    this.animTools.input.value = value;
    this.animTools.lapse.value = convertSecsToHMS(animator.currentTime);
    this.animTools.lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);

    if (value >= 100) {
        this.updatePlayButton(true);
    }
    this.updateToolbarBackground();
};

/**
 *
 * @param isPaused
 * @private
 */
AnimationExtension.prototype.updatePlayButton = function(isPaused) {
    if (!this.playButton) return;
    if (isPaused) {
        this.playButton.setIcon('toolbar-animationPlayIcon');
        this.playButton.setToolTip('Play');
    } else {
        this.playButton.setIcon('toolbar-animationPauseIcon');
        this.playButton.setToolTip('Pause');
    }
};

/**
 * Helper function that resets model explosion.
 * @param value
 * @param setSlider
 * @private
 */
AnimationExtension.prototype.resetExplode = function(value, setSlider) {
    var viewer = this.viewer;
    if (!viewer.model.is2d() && viewer.getExplodeScale() !== 0) {
        if (setSlider && viewer.explodeSlider) { // explodeSlider is only in GuiViewer3D instances
            viewer.explodeSlider.value = value;
        }
        viewer.explode(value);
    }
};

/**
 * @private
 */
AnimationExtension.prototype.adjustToolbarPosition = function() {
    // set timeline width
    var viewer = this.viewer;
    if (!viewer.toolbar) return;
    var fullwidth = viewer.toolbar.getDimensions().width;
    var viewportWidth = viewer.container.getBoundingClientRect().width;
    if (fullwidth > viewportWidth)
        fullwidth = viewer.modelTools.getDimensions().width;
    var inputWidth = fullwidth - (2 *
        this.animTools.backwardButton.getDimensions().width + 3 *
        this.animTools.timeText.getDimensions().width + this.animTools.closeButton.getDimensions().width) + 12;
    this.animTools.input.style.width = inputWidth + 'px';

    // center toolbar
    this.toolbar.container.style.left = 'calc(50% - ' + fullwidth/2 + 'px)';
};

/**
 * @private
 */
AnimationExtension.prototype.hideAnimateToolbar = function() {
    if (this.viewer.toolbar) {
        this.viewer.toolbar.removeClass('toolbar-animationMenuplacer');
    }
    if (this.animTools) {
        this.animTools.setVisible(false);
    }
};

/**
 * @private
 */
AnimationExtension.prototype.updateToolbarBackground = function() {
    if (!this.animTools) return;
    var input = this.animTools.input;
    var percentage = input.value;
    var col1 = "#ffffff", col2 = "#393939";
    input.style.background = "-webkit-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "-moz-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "-ms-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "-o-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "linear-gradient(to right,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
};

/**
 * @private
 */
AnimationExtension.prototype.onCameraChange = function() {
    if (this.viewer.toolController.cameraUpdated) {
        var animator = this.viewer.impl.keyFrameAnimator;
        if (!animator) return;
        if (animator.isPlaying && !animator.isPaused) {
            animator.pause();
            this.updatePlayButton(animator.isPaused);
        }
    }
};

/**
 * @private
 */
AnimationExtension.prototype.onResize = function() {
    if (!this.toolbar) return;
    if (this.viewer.container.clientWidth < (av.isTouchDevice() ? 560 : 600)) {
        this.toolbar.setCollapsed(true);
    } else {
        this.toolbar.setCollapsed(false);
        this.adjustToolbarPosition();
    }
};

/**
 * @private
 */
AnimationExtension.prototype.onEscape = function () {

    if (this.isPlaying()) {
        this.pause();
    } else {
        this.hideAnimateToolbar();
    }
};

/**
 * @private
 */
AnimationExtension.prototype.onExplode = function() {
    // reset animation
    var animator = this.viewer.impl.keyFrameAnimator;
    if (animator) {
        if (animator.currentTime !== 0) {
            this.prevAnimationTime = animator.currentTime;
            animator.goto(0);
        }
        this.updatePlayButton(true);
    }
    this.hideAnimateToolbar();
};

/**
 * @private
 */
AnimationExtension.prototype.onToolbarCreated = function() {

    var viewer = this.viewer;
    var that = this;

    if (this.onToolbarCreatedBinded) {
        viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }

    this.toolbar = new AVU.ToolBar('animation-toolbar');
    this.toolbar.addClass('toolbar-animationSubtoolbar');
    viewer.container.appendChild(this.toolbar.container);

    this.animTools = new AVU.ControlGroup(this.animToolsId);
    this.animTools.setVisible(false);
    this.toolbar.addControl(this.animTools);

    // play button at first of modelTools
    this.playButton = new AVU.Button('toolbar-animationPlay');
    this.playButton.setIcon('toolbar-animationPlayIcon');
    this.playButton.setToolTip('Play');
    this.playButton.onClick = function() {
        if (that.isPaused()) {
            that.play();
        } else {
            that.pause();
        }
    };
    viewer.modelTools.addControl(this.playButton);

    // override reset button's onClick method
    if (viewer.modelTools.resetModelButton) {
        viewer.modelTools.resetModelButton.onClick = function(e) {
            viewer.showAll();
            var animator = viewer.impl.keyFrameAnimator;
            if (animator) {
                animator.goto(0);
                input.value = 0;
                lapse.value = convertSecsToHMS(0);
                lapseLeft.value = convertSecsToHMS(-animator.duration);
                that.updatePlayButton(true);
            }
            that.resetExplode(0, true);
            that.updateToolbarBackground();
        };
    }

    // backward button
    this.animTools.backwardButton = new AVU.Button('toolbar-animationBackward');
    this.animTools.backwardButton.setToolTip('Previous keyframe');
    this.animTools.backwardButton.onClick = function(e) {
        var animator = viewer.impl.keyFrameAnimator;
        if (animator !== undefined && animator) {
            animator.prev();
            that.updateUI();
        }
    };
    this.animTools.backwardButton.addClass('toolbar-animationButton');
    this.animTools.backwardButton.setIcon('toolbar-animationBackwardIcon');
    this.animTools.addControl(this.animTools.backwardButton);

    // forward button
    this.animTools.forwardButton = new AVU.Button('toolbar-animationForward');
    this.animTools.forwardButton.setToolTip('Next keyframe');
    this.animTools.forwardButton.onClick = function(e) {
        var animator = viewer.impl.keyFrameAnimator;
        if (animator !== undefined && animator) {
            animator.next();
            that.updateUI();
        }
    };
    this.animTools.forwardButton.addClass('toolbar-animationButton');
    this.animTools.forwardButton.setIcon('toolbar-animationForwardIcon');
    this.animTools.addControl(this.animTools.forwardButton);

    // current time lapse
    this.animTools.timeText = new AVU.Control('toolbar-animationTimeLapse');
    var lapse = this.animTools.lapse = document.createElement("input");
    lapse.type = "text";
    lapse.value = "0";
    lapse.className = "animationTimeLapse";
    lapse.disabled = true;
    this.animTools.timeText.container.appendChild(lapse);
    this.animTools.timeText.addClass('toolbar-animationButton');
    this.animTools.addControl(this.animTools.timeText);

    // timeline
    this.animTools.timeline = new AVU.Control('toolbar-animationTimeline');
    var input = this.animTools.input = document.createElement("input");
    input.type = "range";
    input.value = "0";
    input.className = "animationTimeline";
    this.animTools.timeline.container.appendChild(input);
    input.addEventListener("input", function(e) {
        var animator = viewer.impl.keyFrameAnimator;
        if (animator !== undefined && animator) {
            var time = input.value * animator.duration / 100;
            lapse.value = convertSecsToHMS(time);
            lapseLeft.value = convertSecsToHMS(time-animator.duration);
            animator.goto(time);
            that.updatePlayButton(animator.isPaused);
            that.updateToolbarBackground();
        }
    });
    // tooltip for slider
    var inputTooltip = document.createElement("div");
    inputTooltip.className = "adsk-control-tooltip";
    inputTooltip.textContent = Autodesk.Viewing.i18n.translate("Click-drag to scrub");
    this.animTools.timeline.container.appendChild(inputTooltip);
    input.addEventListener("mouseover", function(event) {
        if (event.target === input)
            inputTooltip.style.visibility = "visible";
    });
    input.addEventListener("mouseout", function(event) {
        if (event.target === input)
            inputTooltip.style.visibility = "hidden";
    });

    this.animTools.timeline.addClass('toolbar-animationButton');
    this.animTools.timeline.addClass('toolbar-animationTimeline');
    this.animTools.addControl(this.animTools.timeline);

    // remaining time lapse
    this.animTools.timeLeftText = new AVU.Control('toolbar-animationRemainingTime');
    var lapseLeft = this.animTools.lapseLeft = document.createElement("input");
    lapseLeft.type = "text";
    lapseLeft.value = "0";
    lapseLeft.className = "animationTimeLapse";
    lapseLeft.disabled = true;
    this.animTools.timeLeftText.container.appendChild(lapseLeft);
    this.animTools.timeLeftText.addClass('toolbar-animationButton');
    this.animTools.addControl(this.animTools.timeLeftText);

    // close button
    this.animTools.closeButton = new AVU.Button('toolbar-animationClose');
    this.animTools.closeButton.setToolTip('Close animation timeline');
    this.animTools.closeButton.onClick = function() {
        that.hideAnimateToolbar();
    };
    this.animTools.closeButton.setIcon('toolbar-animationCloseIcon');
    this.animTools.closeButton.addClass('toolbar-animationButton');
    this.animTools.addControl(this.animTools.closeButton);
};

//TODO: Is it really necessary to expose it other than to ExtensionManager?
AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360');
Autodesk.Viewing.Extensions.Fusion360.AnimationExtension = AnimationExtension;

av.theExtensionManager.registerExtension('Autodesk.Fusion360.Animation', AnimationExtension);


})();

/**
 * Created by tstanev on 14-11-23.
 */
 
function init_WarpShader() {

if (typeof window.WarpShader !== "undefined")
	return; 

//Shader that implements Oculus VR headset image warping.
WarpShader = {

	uniforms: {
		"tDiffuse": { type: "t", value: null }, //Color buffer containing the rendered 3d model

		//Stereo rendering (Oculus) uniforms. Warp and aberration constants are from DK1 Rift.
		"scale": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
		"scaleIn": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
		"lensCenter": { type: "v2", value: new THREE.Vector2(0.0,0.0) },
		"hmdWarpParam": { type: "v4", value: new THREE.Vector4(1.0, 0.22, 0.24, 0.0) },
		"chromAbParam": { type: "v4", value: new THREE.Vector4(0.996, -0.004, 1.014, 0.0) }
	},


	defines: {
		//"OCULUS" : 1
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"uniform vec2 scale;",
		"uniform vec2 scaleIn;",
		"uniform vec2 lensCenter;",
		"uniform vec4 hmdWarpParam;",
		'uniform vec4 chromAbParam;',


		"varying vec2 vUv;",


		"vec4 sampleColor() {",

			//In our case the source texture is one eye only, so we deviate from the sample
			"vec2 uv = (vUv*2.0)-1.0;", // range from [0,1] to [-1,1]

			"vec2 theta = (uv-lensCenter)*scaleIn;",
			"float rSq = theta.x*theta.x + theta.y*theta.y;",
			"vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);",
		     /*
		    "vec2 tc = (lensCenter + scale * rvector);",
		  	"tc = (tc+1.0)/2.0;", // range from [-1,1] to [0,1]

			"if (any(bvec2(clamp(tc, vec2(0.0,0.0), vec2(1.0,1.0))-tc)))",
			"  return vec4(0.0, 0.0, 0.0, 1.0);",

			"return texture2D( tDiffuse, tc);",
               */

			"  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);",
			"  vec2 tcBlue = (lensCenter + scale * rBlue);",
			"  tcBlue = (tcBlue+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue)))",
			"    return vec4(0.0, 0.0, 0.0, 1.0);",

			"  vec2 tcGreen = lensCenter + scale * rvector;",
			"  tcGreen = (tcGreen+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);",
			"  vec2 tcRed = lensCenter + scale * rRed;",
			"  tcRed = (tcRed+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  return vec4(texture2D(tDiffuse, tcRed).r, texture2D(tDiffuse, tcGreen).g, texture2D(tDiffuse, tcBlue).b, 1);",
		"}",


		"void main() {",

			"vec4 texel = sampleColor();",

			"gl_FragColor = texel;",
		"}"

	].join("\n")

};

}

AutodeskNamespace('Autodesk.Viewing.Extensions.Oculus');


Autodesk.Viewing.Extensions.Oculus.StereoRenderContext = function(options) {

    var _leftCamera, _rightCamera;
    var _leftContext, _rightContext;
    var _renderer;
    var _w, _h, _dpr;
    var _warpPassLeft, _warpPassRight;
    var _useWarp = options ? options.useWarp : true;

	// Specific HMD parameters
	var HMD = (options && options.HMD) ? options.HMD: {
		// Parameters from the Oculus Rift DK2
		hResolution: 1920,
		vResolution: 1080,
		hScreenSize: 0.12576,
		vScreenSize: 0.07074,
		interpupillaryDistance: 0.0635,
		lensSeparationDistance: 0.0635,
		eyeToScreenDistance: 0.041,
		distortionK : [1.0, 0.22, 0.24, 0.0],
		chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]
	};


    var left = {}, right = {};
    var distScale = 1.0;
    var offsetProjection = 0.0;
    var fov = 100;
    var initial_fov,
        initial_aspect;
    var aspect = 1;

//See three.js OculusRiftEffect
	function computeCameraParams(HMD) {
		// Compute aspect ratio and FOV
		aspect = HMD.hResolution / (2*HMD.vResolution);

		// Fov is normally computed with:
		//   THREE.Math.radToDeg( 2*Math.atan2(HMD.vScreenSize,2*HMD.eyeToScreenDistance) );
		// But with lens distortion it is increased (see Oculus SDK Documentation)
		var r = -1.0 - (4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize);
		distScale = (HMD.distortionK[0] + HMD.distortionK[1] * Math.pow(r,2) + HMD.distortionK[2] * Math.pow(r,4) + HMD.distortionK[3] * Math.pow(r,6));
		fov = THREE.Math.radToDeg(2*Math.atan2(HMD.vScreenSize*distScale, 2*HMD.eyeToScreenDistance));

		// Compute camera projection matrices
		offsetProjection = 4 * (HMD.hScreenSize/4 - HMD.interpupillaryDistance/2) / HMD.hScreenSize;

		// Distortion shader parameters
		var lensShift = 4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize;
		left.lensCenter = new THREE.Vector2(lensShift, 0.0);
		right.lensCenter = new THREE.Vector2(-lensShift, 0.0);
	}


    this.init = function (glrenderer, width, height) {
    
        init_WarpShader();

        _renderer = glrenderer;

        //For Oculus targets, we want to cancel out the DPR
        //scale applied by the underlying render context
        _w = width;
        _h = height;
        _dpr = _renderer.getPixelRatio();

        computeCameraParams(HMD);

        _leftContext = new RenderContext();
        _rightContext = new RenderContext();

        _leftContext.setAOEnabled(false);
        _rightContext.setAOEnabled(false);
        _leftContext.settings.antialias = _rightContext.settings.antialias = false;
        _leftContext.settings.customPresentPass = _rightContext.settings.customPresentPass = _useWarp;

        _leftContext.init(_renderer, _w/2 * distScale / _dpr, _h * distScale / _dpr);
        _rightContext.init(_renderer, _h/2 * distScale / _dpr, _h * distScale / _dpr);

        this.settings = _leftContext.settings;

        if (_useWarp) {
            _warpPassLeft = new Autodesk.Viewing.Shaders.LmvShaderPass(WarpShader);
            _warpPassRight = new Autodesk.Viewing.Shaders.LmvShaderPass(WarpShader);

            var bpasses = [_warpPassLeft, _warpPassRight];
            for (var i=0; i<2; i++) {
                bpasses[i].material.blending = THREE.NoBlending;
                bpasses[i].material.depthWrite = false;
                bpasses[i].material.depthTest = false;

                bpasses[i].uniforms['hmdWarpParam'].value.set(HMD.distortionK[0], HMD.distortionK[1], HMD.distortionK[2], HMD.distortionK[3]);
                bpasses[i].uniforms['chromAbParam'].value.set(HMD.chromaAbParameter[0], HMD.chromaAbParameter[1], HMD.chromaAbParameter[2], HMD.chromaAbParameter[3]);
                bpasses[i].uniforms['scaleIn'].value.set(1.0,1.0/aspect);
                bpasses[i].uniforms['scale'].value.set(1.0/distScale, 1.0*aspect/distScale);
            }

            bpasses[0].uniforms['lensCenter'].value.copy(left.lensCenter);
            bpasses[1].uniforms['lensCenter'].value.copy(right.lensCenter);
        }
    };

	function applyCameraChanges(camera) {

		//Correct aspect ration. Stereo rendering cuts horizontal
		//size in half.
		_leftCamera.aspect = _rightCamera.aspect = aspect;

		//Apply field of view correction
		_leftCamera.fov = _rightCamera.fov = fov;

		//Offset real world camera position for each eye
		var unitsPerM = 1.0 / _leftContext.getUnitScale();
		var right = camera.target.clone().sub(camera.position).cross(camera.up).normalize();
		//right.multiplyScalar(0.5 * HMD.interpupillaryDistance * unitsPerM);
        right.multiplyScalar(1 * HMD.interpupillaryDistance * unitsPerM);
		//_leftCamera.position.sub(right);
		_rightCamera.position.add(right);
		//_leftCamera.target.sub(right);
		_rightCamera.target.add(right);

		_leftCamera.toPerspective();
		_rightCamera.toPerspective();

		//_leftCamera.projectionMatrix.elements[12] += offsetProjection;
		_rightCamera.projectionMatrix.elements[12] -= 2 * offsetProjection;

	}

    this.revertCameraChanges = function(camera) {
        console.log("REVERT Camera to normal");
        _leftCamera.fov = initial_fov;
        _leftCamera.aspect = initial_aspect;

        return _leftCamera;

    };

    //save camera state to revert back when oculus toggled off
    this.saveCameraState = function(camera){
        console.log(camera);
        initial_fov = camera.fov;
        initial_aspect = camera.aspect;
    };

    this.update = function(highResTimer) {

        var left = _leftContext.update(highResTimer);
        var right = _rightContext.update(highResTimer);

        return left || right;
    };

    this.beginScene = function (prototypeScene, camera, customLights, needClear) {
		//_leftCamera = camera.clone();
        _leftCamera = camera;
		_rightCamera = camera.clone();

        applyCameraChanges(camera);

        _leftContext.beginScene(prototypeScene, _leftCamera, customLights, needClear);
        _rightContext.beginScene(prototypeScene, _rightCamera, customLights, needClear);

        //camera.updateMatrixWorld();//Check if dirty first, only update then
        //TODO in vporttoray check if i should unproject?
    };


    this.renderScenePart = function (scene, colorTarget, saoTarget, idTarget) {
        _leftContext.renderScenePart(scene, colorTarget, saoTarget, idTarget);
        _rightContext.renderScenePart(scene, colorTarget, saoTarget, idTarget);
    };

    this.sceneDirty = function(camera, bbox) {
        _leftContext.sceneDirty(camera, bbox);
        _rightContext.sceneDirty(camera, bbox);
    };

    //TODO: get rid of this and combine it with composeFinalFrame
    this.endScene = function() {
        _leftContext.endScene();
        _rightContext.endScene();
    };

    this.clearAllOverlays = function () {
        _leftContext.clearAllOverlays();
        _rightContext.clearAllOverlays();
    };

    this.renderOverlays = function (overlays) {
        _leftContext.renderOverlays(overlays);
        _rightContext.renderOverlays(overlays);
    };


    this.composeFinalFrame = function (skipAOPass) {
        //Make the final frame but skip presenting it
        //to the screen. We will do custom stuff
        _leftContext.composeFinalFrame(skipAOPass, true);
        _rightContext.composeFinalFrame(skipAOPass, true);

        //Compose the per-eye frames using viewports per eye
        _renderer.setViewport(0,0,_w/2,_h);
        _leftContext.presentBuffer(_warpPassLeft);

        _renderer.setViewport(_w/2,0,_w/2,_h);
        _rightContext.presentBuffer(_warpPassRight);

        _renderer.setViewport(0,0,_w,_h);
    };

    this.cleanup = function() {
        _leftContext.cleanup();
        _rightContext.cleanup();
    };

    this.setSize = function (w, h, force) {
        _w = w;
        _h = h;

        _leftContext.setSize(_w/2 * distScale / _dpr, _h * distScale / _dpr, force);
        _rightContext.setSize(_w/2 * distScale / _dpr, _h * distScale / _dpr, force);

        _renderer.setSize(w,h);
    };

    this.getMaxAnisotropy = function () {
        return _leftContext.getMaxAnisotropy();
    };

    this.hasMRT = function () {
        return _leftContext.hasMRT();
    };

    this.initPostPipeline = function (useSAO, useFXAA, useIDBuffer) {

        //override these
        useSAO = false; useFXAA = false; useIDBuffer = false;

        _leftContext.initPostPipeline(useSAO, useFXAA, useIDBuffer);
        _rightContext.initPostPipeline(useSAO, useFXAA, useIDBuffer);
    };

    this.setClearColors = function (colorTop, colorBot) {
        _leftContext.setClearColors(colorTop, colorBot);
        _rightContext.setClearColors(colorTop, colorBot);
    };


    this.setAOOptions = function (radius, intensity) {
        _leftContext.setAOOptions(radius, intensity);
        _rightContext.setAOOptions(radius, intensity);
    };

    this.getAOEnabled = function() {
        _leftContext.getAOEnabled();
    };

    this.getAORadius = function () {
        return _leftContext.getAORadius();
    };

    this.getAOIntensity = function() {
        return _leftContext.getAOIntensity();
    };

    this.setTonemapExposureBias = function (bias) {
        _leftContext.setTonemapExposureBias(bias);
        _rightContext.setTonemapExposureBias(bias);
    };

    this.getExposureBias = function () {
        return _leftContext.getExposureBias();
    };

    this.setTonemapMethod = function (value) {
        _leftContext.setTonemapMethod(value);
        _rightContext.setTonemapMethod(value);
    };

    this.getToneMapMethod = function () {
        return _leftContext.getToneMapMethod();
    };

    this.toggleTwoSided = function (isTwoSided) {
        _leftContext.toggleTwoSided(isTwoSided);
        _rightContext.toggleTwoSided(isTwoSided);
    };

    this.enter2DMode = function(idMaterial) {
        _leftContext.enter2DMode(idMaterial);
        _rightContext.enter2DMode(idMaterial);
    };

    //Returns the value of the ID buffer at the given
    //viewport location. Note that the viewport location is in
    //OpenGL-style coordinates [-1, 1] range.
    this.idAtPixel = function (vpx, vpy) {
        console.warn("idAtPixel not implemented in stereo context.");
        return 0;
    };


    this.overlayUpdate = function(highResTimer) {
        _leftContext.overlayUpdate(highResTimer);
        _rightContext.overlayUpdate(highResTimer);
    };

    this.rolloverObjectViewport = function (vpx, vpy) {
       /// console.warn("rolloverObjectViewport not implemented in stereo context");//TODO this is annoying
    };


    this.screenCapture = function() {
        console.warn("Screen capture not implemented by stereo render context");
        return null;
    };

	this.setUnitScale = function(metersPerUnit) {
		_leftContext.setUnitScale(metersPerUnit);
		_rightContext.setUnitScale(metersPerUnit);
	};

	this.getUnitScale = function() {
		return _leftContext.getUnitScale();
	}


};
AutodeskNamespace('Autodesk.Viewing.Extensions.Oculus');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        aveo = ave.Oculus;

    var _vrHMD = null, _vrSensor = null;


    function HeadTrackingTool(viewer) {

        var _camera;
        var _viewer = viewer;

        var _headPos = new THREE.Vector3(0,0,0);
        var _headQuat = new THREE.Quaternion();
        var _turnQuat = new THREE.Quaternion();
        var _mView = new THREE.Matrix4();
        var _headPosBase = new THREE.Vector3(0,0,0);
        var _mViewBase = new THREE.Matrix4();
        var _mTmp = new THREE.Matrix4();
        var _sensorData, _lastId = 0;
        var _toModelUnits = 1.0;

        var SPEED_SCALE = 10.0;
        var LOOK_SCALE = 0.001;
        var _lastTime = -1.0;
        var _baseAzimuth = 0.0;

        var _W=0, _A=0, _S=0, _D=0, _Q=0, _E=0;

        var _ws;

        if (!_vrSensor)
            initWebSocket();
        else
            _sensorData = [0,0,0,0,0,0,0,0];


        this.getNames = function() {
            return ["headtracker"];
        };

        this.getName = function() {
            return "headtracker";
        };

        var _gamepadModule;
        this.activate = function(name) {

            _camera = _viewer.navigation.getCamera();

            resetOrientation();

            if (_viewer.model) {
                _toModelUnits = 1.0 / _viewer.model.getUnitScale();
                var box = _viewer.model.getBoundingBox();
                SPEED_SCALE = box.size().length() * 0.0001;

            }

            //if this browser supports gamepad, instantiate GamepadModule
            if(navigator.getGamepads || !!navigator.webkitGetGamepads || !!navigator.webkitGamepads){
                _gamepadModule = new Autodesk.Viewing.Extensions.GamepadModule(_viewer);
                _gamepadModule.activate(this.getName());
            }
        };

        this.deactivate = function(name) {
            _camera = null;
            if(_gamepadModule)
                _gamepadModule.deactivate();
        };

        this.update = function(timeStamp) {

            if (_lastTime < 0)
                _lastTime = timeStamp;

            var timeDelta = timeStamp - _lastTime;

            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective)
                viewer.navigation.toPerspective();

            if (_vrSensor) {

                var state = _vrSensor.getState();
                _sensorData[0] = _lastId + 1;
                if (state.orientation) {
                    _sensorData[4] = state.orientation.x;
                    _sensorData[5] = state.orientation.y;
                    _sensorData[6] = state.orientation.z;
                    _sensorData[7] = state.orientation.w;
                }
                if (state.position) {
                    _sensorData[1] = state.position.x;
                    _sensorData[2] = state.position.y;
                    _sensorData[3] = state.position.z;
                }
            }

            if (_sensorData) {
                var id = _sensorData[0];
                if (id > _lastId) {

                    //Process head position offset
                    _camera.position.sub(_headPos);

                    _headPos.set(_sensorData[1],_sensorData[2],_sensorData[3]);
                    _headPos.sub(_headPosBase);
                    _headPos.multiplyScalar(_toModelUnits);
                    _headPos.applyMatrix4(_mViewBase);

                    _camera.position.add(_headPos);

                    _baseAzimuth += (_Q - _E) * timeDelta * LOOK_SCALE;
                    _turnQuat.setFromAxisAngle(_camera.worldup, _baseAzimuth);

                    //Derive the orientation matrix from the head tracking quaternion,
                    //the head turning quaternion, and the base orientation
                    _headQuat.set(_sensorData[4],_sensorData[5],_sensorData[6],_sensorData[7]);
                    _turnQuat.multiply(_headQuat);
                    _mTmp.makeRotationFromQuaternion(_turnQuat);
                    _mView.multiplyMatrices(_mViewBase, _mTmp);
                    var e = _mView.elements;

                    //Direction vector is the Z row of the view matrix
                    var dir = new THREE.Vector3(-e[8], -e[9], -e[10]);
                    var distance = _camera.target.clone().sub(_camera.position).length();

                    //Up vector is the Y row of the view matrix
                    _camera.up.set(e[4], e[5], e[6]);

                    //Process displacement motion due to WASD keys
                    var right = new THREE.Vector3(e[0], e[1], e[2]);
                    var moveForward = dir.clone().multiplyScalar((_W - _S) * timeDelta * SPEED_SCALE);
                    _camera.position.add(moveForward);

                    var moveRight = right.multiplyScalar((_D - _A) * timeDelta * SPEED_SCALE);
                    _camera.position.add(moveRight);

                    _camera.target.set(_camera.position.x, _camera.position.y, _camera.position.z);
                    _camera.target.add(dir.multiplyScalar(distance));
                }
                _lastId = id;
            }

            if (_ws) {
                if (_ws.readyState === 1) {
                    _ws.send("get\n");
                }
            }


            if(_gamepadModule){
                _camera = _gamepadModule.update(_camera);
            }

            _lastTime = timeStamp;

            return true;
        };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};

        this.handleKeyDown = function( event, keyCode ) {

            var handled = false;

            switch (keyCode) {
                case 38 :
                case 87 : _W = 1; handled = true; break;
                case 40 :
                case 83 : _S = 1; handled = true; break;
                case 37 :
                case 65 : _A = 1; handled = true; break;
                case 39:
                case 68 : _D = 1; handled = true; break;

                case 81 : _Q = 1; handled = true; break;
                case 69 : _E = 1; handled = true; break;
            }

            return handled;
        };

        this.handleKeyUp = function( event, keyCode ) {

            var handled = false;

            switch (keyCode) {
                case 38 :
                case 87 : _W = 0; handled = true; break;
                case 40 :
                case 83 : _S = 0; handled = true; break;
                case 37 :
                case 65 : _A = 0; handled = true; break;
                case 39 :
                case 68 : _D = 0; handled = true; break;

                case 81 : _Q = 0; handled = true; break;
                case 69 : _E = 0; handled = true; break;

                case 32 : resetOrientation(); handled = true; break;
            }

            return handled;
        };

        this.handleWheelInput = function(delta) { return false; };
        this.handleButtonDown = function(event, button) { return false; };
        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {return false;};
        this.handleGesture = function(event, touches) {return false;};
        this.handleTouchChange = function(event, touches) {return false;};
        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};


        function resetOrientation() {

            _mViewBase.copy(_camera.matrixWorld);
            _mViewBase.elements[12] = 0;
            _mViewBase.elements[13] = 0;
            _mViewBase.elements[14] = 0;

            if (_sensorData)
                _headPosBase.set(_sensorData[1],_sensorData[2],_sensorData[3]);
        }

        function initWebSocket() {

            //====================
            // This headtracker requires the following Oculus-WebSocket bridge library:
            // https://github.com/gyohk/threejs-typescript-oculusdk2
            // (Only need the OculusWebSocket part)
            //====================
            var ws = new WebSocket("ws://localhost:8888/ws");
            ws.onopen = function () {
                console.log("### Oculus Connected ####");
            };

            ws.onmessage = function (evt) {
                var message = evt.data;
                try {
                    _sensorData = JSON.parse(message);
                } catch (err) {
                    console.log(message);
                }
            };

            ws.onclose = function () {
                console.log("### Oculus Connection Closed ####");
            };
            //====================

            _ws = ws;
        }

    };


    //==================================================================================
    //Extension interface

    /** @constructor */
    aveo.Oculus = function (viewer, options) {
        av.Extension.call(this, viewer, options);

        this.viewer = viewer;
        this.context = null;
        this.initialized = false;
    };

    aveo.Oculus.prototype = Object.create(av.Extension.prototype);
    aveo.Oculus.prototype.constructor = ave.Oculus;


    aveo.Oculus.prototype.toggleOculus = function(state) {

        var viewer = this.viewer;

        if (state) {

            if (!this.context) {
                this.context = new aveo.StereoRenderContext( {useWarp:!_vrHMD} );
                this.context.saveCameraState(this.viewer.navigation.getCamera());
                viewer.impl.setUserRenderContext(this.context);

                //TODO: Not sure why we need this call in order to force the
                //stereo layout to fix itself.
                viewer.resize(viewer.canvas.clientWidth, viewer.canvas.clientHeight);

                viewer.displayViewCube(false, false);

                if (!viewer.navigation.isPerspective)
                    viewer.navigation.toPerspective();

                if (_vrHMD) {
                    av.launchFullscreen(viewer.impl.canvas, { vrDisplay: _vrHMD });
                } else {
                    av.launchFullscreen(viewer.impl.canvas);
                }

                if (!this.headTracker) {
                    this.headTracker = new HeadTrackingTool(viewer);
                    viewer.toolController.registerTool(this.headTracker);
                }

                viewer.toolController.activateTool("headtracker");
            }

        }
        else {

            if (this.context) {
                this.viewer.navigation.setCamera(this.context.revertCameraChanges());
                this.context = null;
                viewer.impl.setUserRenderContext(null);

                viewer.displayViewCube(viewer.prefs.get("viewCube"), false);

                viewer.toolController.deactivateTool("headtracker");

                av.exitFullscreen();
            }
        }


    };


    aveo.Oculus.prototype.createUI = function() {
        var scope = this;
        var viewer = this.viewer;

        this.oculusButton = new avu.Button('toolbar-oculusTool');
        this.oculusButton.setToolTip('Oculus VR Mode');
        this.oculusButton.setIcon("oculusIcon");

        this.oculusButton.onClick = function(e) {
            scope.toggleOculus(!scope.context);
        };

        viewer.modelTools.addControl(this.oculusButton);
    };


    aveo.Oculus.prototype.load = function () {

        var viewer = this.viewer;
        var scope = this;
        //scope.createUI(); comment in to test w/o oculus connection

        function onToolbarCreated(e) {
            viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            scope.createUI();
        }

        function onHMDDetected() {

            // add the button to the toolbar
            if(viewer.modelTools && viewer.modelTools.getNumberOfControls() > 0) {
                scope.createUI();
            } else {
                viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            }
        }

        function EnumerateVRDevices(vrdevs) {
            // First, find a HMD -- just use the first one we find
            for (var i = 0; i < vrdevs.length; ++i) {
                if (vrdevs[i] instanceof HMDVRDevice) {
                    _vrHMD = vrdevs[i];
                    break;
                }
            }

            if (!_vrHMD)
                return;

            // Then, find that HMD's position sensor
            for (var i = 0; i < vrdevs.length; ++i) {
                if (vrdevs[i] instanceof PositionSensorVRDevice &&
                    vrdevs[i].hardwareUnitId == _vrHMD.hardwareUnitId)
                {
                    _vrSensor = vrdevs[i];
                   break;
                }
            }

            if (!_vrHMD || !_vrSensor) {
                avp.logger.warn("Didn't find a HMD and sensor!");
            } else {
                onHMDDetected();
            }

            scope.initialized = true;
        }


        if (navigator.getVRDevices) {
            navigator.getVRDevices().then(EnumerateVRDevices);
        } else if (navigator.mozGetVRDevices) {
            navigator.mozGetVRDevices(EnumerateVRDevices);
        } else {
            this.initialized = true;
        }


        return true;
    };

    aveo.Oculus.prototype.unload = function () {

        this.toggleOculus(false);

        return true;
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.Oculus', aveo.Oculus);

})();

AutodeskNamespace('Autodesk.Viewing.Extensions.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        avp = av.Private,
        ave = av.Extensions,
        avec = ave.Collaboration;


    avec.InteractionInterceptor = function(viewtx) {

        this.getNames = function() {
            return ["intercept"];
        };

        this.getName = function() {
            return "intercept";
        };

        this.activate = function(name) { };
        this.deactivate = function(name) { };
        this.update = function(timeStamp) { return false; };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};

        this.handleWheelInput = function(delta) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonDown = function(event, button) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {
            viewtx.updatePointer(event);
            return false;
        };

        this.handleGesture = function(event) {
            viewtx.takeControl();
            return false;
        };

        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};
    };


    avec.ViewTransceiver = function(client) {

        var _this = this;
        var _viewer = this.viewer = null;
        var _blockEvents = false;
        var _haveControl = false;
        var _isDisconnected = false;
        var _lastInControl;
        var _client = this.client = client;
        var _ray = new THREE.Ray();
        var _pointer = null;
        var _pointerOn = false;

        this.channelId = null;

        var _viewerState;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: false,
            cutplanes: true,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };


        function onViewerState(evt) {
            _blockEvents = true;
            var state = JSON.parse(evt.data.msg);
            _viewerState.restoreState(state);
            _viewer.impl.invalidate(true, false, true);
            _blockEvents = false;
        }

        function reduceBits(v) {
            return Math.round(v * 1000) / 1000;
        }

        function reduceBitsV(v) {
            for (var i=0; i< v.length; i++)
                v[i] = reduceBits(v[i]);
        }

        function onCamera(e) {
            var v = e.data.msg;

            if (v[1] === true || _isDisconnected)
            {
                return;
            }

            if (v[0] != _lastInControl)
            {
                _lastInControl = v[0];
                e.data.lastInControl = v[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: e.data });
            }

            //For now, automatically relinquish camera control if we receive a remote command to move the camera
            _haveControl = false;

/*
            viewer.navigation.setRequestTransitionWithUp(true, new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
                                                                new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]),
                                                                _viewer.navigation.getCamera().fov,
                                                                new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
*/

            _viewer.navigation.setView(new THREE.Vector3().set(v[2+0],v[2+1],v[2+2]),
                                       new THREE.Vector3().set(v[2+3],v[2+4],v[2+5]));
            _viewer.navigation.setCameraUpVector(new THREE.Vector3().set(v[2+6],v[2+7],v[2+8]));
        }

        function sendCamera(evt) {
            if (!_haveControl && !_isDisconnected)
                return;

            var c = evt.camera;
            var camParams = [ c.position.x, c.position.y, c.position.z,
                c.target.x, c.target.y, c.target.z,
                c.up.x, c.up.y, c.up.z
            ];

            reduceBitsV(camParams);
            camParams.unshift(_isDisconnected);
            camParams.unshift(client.getLocalId());

            _client.sendMessage("camera", camParams, _this.channelId);

            if (_lastInControl != camParams[0]) {
                _lastInControl = camParams[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: { lastInControl: _lastInControl } });
            }
        }


        function showPointer(show, x, y) {

            if (show && !_pointer) {
                _pointer = document.createElement("div");
                _pointer.classList.add("collabPointer");
            }

            if (show && !_pointerOn) {
                _viewer.container.appendChild(_pointer);
                _pointerOn = true;
            }
            else if (!show && _pointerOn) {
                _viewer.container.removeChild(_pointer);
                _pointerOn = false;
            }

            if (show) {
                //Note the 4px is half the width/height specified in the CSS,
                //so that the pointer is centered.
                _pointer.style.left = (x-6) + "px";
                _pointer.style.top = (y-6) + "px";
            }

        }

        function onPointer(e) {

            if (_haveControl)
                return; //shouldn't get here in theory, but let's check just in case

            if (_isDisconnected)
                return; //we can't show the pointer if the views don't match

            var v = e.data.msg;
            _ray.origin.set(v[1], v[2], v[3]);
            _ray.direction.set(v[4], v[5], v[6]);

            var pt = _ray.at(_viewer.getCamera().near);
            pt.project(_viewer.getCamera());

            pt = _viewer.impl.viewportToClient(pt.x, pt.y);

            //console.log(pt.x + " " + pt.y);
            showPointer(true, pt.x, pt.y);
        }


        function sendPointer(evt) {
            if (!_haveControl)
                return;

            //Note canvasX/Y are set by the ToolController to clientX/Y - canvas left/top.
            var vpVec = _viewer.impl.clientToViewport(evt.canvasX, evt.canvasY);
            _viewer.impl.viewportToRay(vpVec, _ray);

            var rayParams = [ _ray.origin.x, _ray.origin.y, _ray.origin.z,
                              _ray.direction.x, _ray.direction.y, _ray.direction.z ];

            reduceBitsV(rayParams);
            rayParams.unshift(client.getLocalId());

            _client.sendMessage("pointer", rayParams, _this.channelId);
        }


        function sendViewerState(e) {
            //if (!_haveControl)
            //    return;
            if (_blockEvents)
                return;

            var state = _viewerState.getState(VIEWER_STATE_FILTER);

            // TODO: if we kill the socket.io code path, this could be optimized
            // too by removing the JSON.stringify of the state. Pubnub automatically
            // does JSON serialization for us, with optimizations accordingly to their manual.
            client.sendMessage("state", JSON.stringify(state), _this.channelId);
        }


        this.takeControl = function() {
            _haveControl = true;
            showPointer(false);
        };

        this.updatePointer = function(e) {
            sendPointer(e);
        };

        this.connectCamera = function(set) {
            _isDisconnected = !set;
        };

        this.attach = function(viewer) {

            if (_viewer)
                this.detach();

            this.viewer = _viewer = viewer;
            _viewerState = new avp.ViewerState(_viewer);

            _client.addEventListener("cameraChange", onCamera);
            _client.addEventListener("pointerMove", onPointer);
            _client.addEventListener("viewerState", onViewerState);


            if (!_viewer.hasEventListener(av.CAMERA_CHANGE_EVENT, sendCamera))
                _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

            if (!_viewer.hasEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState)) {
                _viewer.addEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.addEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.addEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.addEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.addEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);
            }
        };


        this.detach = function() {

            if (_client) {
                _client.removeEventListener("cameraChange", onCamera);
                _client.removeEventListener("viewerState", onViewerState);
            }

            if (_viewer) {
                _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

                _viewer.removeEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);

                this.viewer = _viewer = null;
                _viewerState = null;
            }
        };

    };

    avec.ViewTransceiver.prototype.constructor = avec.ViewTransceiver;
    Autodesk.Viewing.EventDispatcher.prototype.apply( avec.ViewTransceiver.prototype );



})();

AutodeskNamespace('Autodesk.Viewing.Extensions.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        avec = ave.Collaboration;

    //==================================================================================
    //Extension interface

    /** @constructor */
    ave.Collaboration.Collaboration = function (viewer, options) {
        av.Extension.call(this, viewer, options);
        if (options && options.rtc && options.rtc.disableRTCToolbarButton) {
            this.disableRTCToolbarButton = true;
        }
    };

    ave.Collaboration.Collaboration.prototype = Object.create(av.Extension.prototype);
    ave.Collaboration.Collaboration.prototype.constructor = ave.Collaboration.Collaboration;


    ave.Collaboration.Collaboration.prototype.initNetwork = function(force) {

        if (this.p2p && !force)
            return;

        this.viewtx = new avec.ViewTransceiver(this.client);
        this.interceptor = new avec.InteractionInterceptor(this.viewtx);
        this.viewer.toolController.registerTool(this.interceptor);

        this.p2p = new avp.P2PClient(this.client);
    };

    ave.Collaboration.Collaboration.prototype.createUI = function() {

        var scope = this;
        var viewer = this.viewer;

        this.initNetwork(false);

        this.panel = new avec.DockingCollabPanel(this.viewer, this.client, this.p2p, this.viewtx);
        ave.Collaboration.Collaboration.Panel = this.panel;

        // Create a comment toolbar button.
        this.collabButton = new avu.Button('toolbar-collaborateTool');
        this.collabButton.setToolTip('Live review');
        this.collabButton.setIcon("adsk-icon-live-review");
        this.collabButton.onClick = function(e) {
            var isVisible = scope.panel.isVisible();

            // Prevent instantiating multiple 'enter your name' box by
            // spamming collab button.
            if (document.getElementById("collabBox")) {
                return;
            }

            if (!isVisible && !scope.inviteDivInstantiated) {
                var w = new avec.CollabPromptBox();
                var container = viewer.container;
                w.start(container, function () {
                    scope.panel.setVisible(true, true);
                }, "Start a Live Review", "Start Review");
            }
            else {
                scope.panel.setVisible(false, true);
                scope.panel.reset();
            }
        };
        if (this.disableRTCToolbarButton) {
            this.collabButton.setVisible(false,true);
        }

        this.panel.addVisibilityListener(function(state) {
            if (state) {

                if (viewer.model) {
                    var svf = viewer.model.getData();

                    scope.viewtx.channelId = svf.basePath;
                    scope.viewtx.attach(viewer);

                    scope.client.connect(scope.viewtx.channelId); //use the just the URN as load balancer session ID for now.
                    scope.client.join(scope.viewtx.channelId);
                }

                viewer.toolController.activateTool(scope.interceptor.getName());

                var getColumbusURL = function () {
                    var ret;
                    switch (window.location.hostname) {
                        case "columbus-dev.autodesk.com" :
                            ret = "http://columbus-dev.autodesk.com/collab.html?";
                            break;
                        case "columbus-staging.autodesk.com" :
                            ret = "http://columbus-staging.autodesk.com/collab-stg.html?";
                            break;
                        default:
                            ret = "http://columbus-dev.autodesk.com/collab.html?";
                    }

                    return ret + "document=urn:";
                };

                var generateSharedURL = function () {
                    var baseURL = getColumbusURL();
                    var urn = viewer.model.getData().urn;
                    var ret = baseURL + urn;
                    if (avp.comment2Token) {
                        ret += ("&comment2Token=" + encodeURIComponent(avp.comment2Token));
                    }
                    return ret;
                };

                /*
                window.prompt("Send this URL to people you want to share and collaborate on this file!",
                  generateSharedURL());
                */

                scope.collabButton.setState(avu.Button.State.ACTIVE);

                avp.logger.track({category:"viewer_rtc_start"});
            }
            else {

                if (avp.logger && scope.client.isConnected())
                    avp.logger.track({category:"viewer_rtc_stop"});

                scope.p2p.hangup();
                scope.viewtx.detach(viewer);
                scope.viewtx.channelId = null;
                scope.client.disconnect();
                scope.panel.reset();
                viewer.toolController.deactivateTool(scope.interceptor.getName());

                scope.collabButton.setState(avu.Button.State.INACTIVE);
            }
        });

        viewer.modelTools.addControl(this.collabButton);

        if (Autodesk.Viewing.Private.getParameterByName("invited")) {
            var w = new CollabPromptBox();
            var container = viewer.container;
            w.start(container, function () {
                scope.panel.setVisible(true, true);
            }, "Join a Live Review", "Join Review");
        }
    };


    ave.Collaboration.Collaboration.prototype.close = function () {
        this.panel.setVisible(false, true);
        this.panel.reset();
    };

    ave.Collaboration.Collaboration.prototype.load = function () {
        var viewer = this.viewer;
        var scope = this;

        function init() {

            scope.client = avp.MessageClient.GetInstance(scope.options ? scope.options.messageServerURL : undefined);
            
            scope.socketErrorHandler = function(evt) {
                avp.ErrorHandler.reportError(viewer.container, Autodesk.Viewing.ErrorCodes.RTC_ERROR, evt.data);
                scope.close();
            };
            
            scope.client.addEventListener("socketError", scope.socketErrorHandler);

            scope.presenceChannelId = window.location.host;

            if (scope.client.isConnected()) {
                //If the client is already connected, we assume that a presence service
                //is already joined by the embedding application.
                /*
                scope.client.addEventListener("userListChange", function(e) {
                    if (e.data.user && e.channelId == scope.presenceChannelId)
                        console.log(e.data.user.name + " is online.");
                    else if (e.userStatus == "left")
                        console.log(e.data.user.name + " went offline.");
                });
                */
            }
            else {
                //Standalone configuration, where no embedding application exists
                //Used for testing.
                //Moved to launch of the collaboration panel so we can connect with session ID for load balancing
                //this.client.connect();
                //this.client.join(this.presenceChannelId);
            }

            // add the button to the toolbar
            if (viewer.modelTools) {
                scope.createUI();
            } else {
                viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            }

            function onToolbarCreated(e) {
                viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
                scope.createUI();
            }
        }

        //Load the socket.io library if needed
        avp.loadDependency("lmv_io", "socket.io-1.3.5.js", init);

        return true;
    };

    ave.Collaboration.Collaboration.prototype.unload = function () {

        var viewer = this.viewer;
        
        this.client.removeEventListener("socketError", this.socketErrorHandler);
        this.socketErrorHandler = null;
        
        this.p2p.hangup();
        this.viewtx.detach(viewer);
        this.client.disconnect();

        if (this.panel) {
            this.panel.reset();
            this.panel.setVisible(false);
            this.panel.uninitialize();
            this.panel = null;
        }

        viewer.toolController.deactivateTool(this.interceptor.getName());
        this.interceptor = null;

        viewer.modelTools.removeControl(this.collabButton.getId());
        this.collabButton = null;

        return true;
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.Collaboration', ave.Collaboration.Collaboration);

})(); // closure

'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Beeline');

Autodesk.Viewing.Extensions.Beeline.BeelineExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.constructor = Autodesk.Viewing.Extensions.Beeline.BeelineExtension;

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.Beeline.BeelineTool(viewer.impl, viewer);
    viewer.toolController.registerTool(this.tool);

    // Add UI
    // Add beeline button
    this.createUI();

    // Add hotkey
    var previousTool;
    function onPress() {
        previousTool = viewer.getActiveNavigationTool();
        viewer.setActiveNavigationTool(self.tool.getName());
        return true;
    }
    function onRelease() {
        viewer.setActiveNavigationTool(previousTool ? previousTool : viewer.defaultNavigationToolName);
        return true;
    }
    this.HOTKEYS_ID = "Autodesk.Beeline.Hotkeys";
    var hotkeys = [
        {
            keycodes: [
                Autodesk.Viewing.theHotkeyManager.KEYCODES.CONTROL,
                Autodesk.Viewing.theHotkeyManager.KEYCODES.ALT
            ],
            onPress: onPress,
            onRelease: onRelease
        }
    ];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, hotkeys);

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('beeline') === -1) {
            return;
        }

        if (self.beelineButton) {
            var state = e.active ? AVU.Button.State.ACTIVE : AVU.Button.State.INACTIVE;
            self.beelineButton.setState(state);
        }
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    if (!viewer.getToolbar || !viewer.getSettingsPanel) return; // Add support for Viewer3D instance

    var toolbar = viewer.getToolbar(true);

    var AVU = Autodesk.Viewing.UI;
    var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    var beelineButtonId = "toolbar-beelineTool";

    /*var options = {
        defaultTooltipValue: "Walk to (double-click to Walk through)"
    };*/
    var beelineButton = new AVU.Button(beelineButtonId);
    beelineButton.setToolTip('Walk to');
    beelineButton.setIcon("adsk-icon-walk");
    beelineButton.onClick = function(e) {
        var state = beelineButton.getState();
        if (state === AVU.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("beeline");
        } else if (state === AVU.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    };
    this.beelineButton = beelineButton;

    var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.addControl(this.beelineButton, {index: navTools.indexOf(cameraSubmenuTool.getId())});
    } else {
        navTools.addControl(this.beelineButton);
    }

    // Add beeline settings to the viewer's setting panel.
    var that = this;
    var addViewerUIOptions = function() {
        viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, addViewerUIOptions);

        var navTab = Autodesk.Viewing.Extensions.ViewerSettingTab.Navigation;
        var viewerOptions = viewer.getSettingsPanel(true);
        that.viewerOption_LookHorId = viewerOptions.addCheckbox(navTab, "Reverse horizontal look direction", false, function(checked) {
            viewer.setReverseHorizontalLookDirection(checked);
        }, "reverseHorizontalLookDirection");

        that.viewerOption_LookVertId = viewerOptions.addCheckbox(navTab, "Reverse vertical look direction", false, function(checked) {
            viewer.setReverseVerticalLookDirection(checked);
        }, "reverseVerticalLookDirection");

    };

    if (this.viewer.getSettingsPanel(false)) {
        addViewerUIOptions();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, addViewerUIOptions);
    }
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    if (this.beelineButton) {
        // Button is created only if toolbar API is available
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.beelineButton.getId());
        }
        this.beelineButton = null;
    }

    // Remove the options from the Viewer SettingsPanel.
    if (viewer.getSettingsPanel) {
        viewer.getSettingsPanel(false).removeCheckbox(this.viewerOption_LookHorId);
        viewer.getSettingsPanel(false).removeCheckbox(this.viewerOption_LookVertId);
    }

    //Uh, why does the viewer need to keep track of this in addition to the tool stack?
    if (viewer.getActiveNavigationTool() == this.tool.getName())
        viewer.setActiveNavigationTool();

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Beeline', Autodesk.Viewing.Extensions.Beeline.BeelineExtension);
AutodeskNamespace('Autodesk.Viewing.Extensions.Beeline');

var avp = Autodesk.Viewing.Private;

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.Extensions.Beeline.BeelineTool = function( viewerImpl, viewerApi )
{
    var MODE = {
        GO_TO: 0,
        PASS_THROUGH: 1,
        DEFAULT: 0
    };

    // Constants
    var kDefaultFlightDuration = 1000; // milliseconds
    var kLookSensitivity = 0.8;
    var kMaxFocalLength = 28;
    var kDampingFactor = 0.7;

    // States
    var kStartState = 0;
    var kFlightState = 1;

    var self = this;
    var _viewerapi = viewerApi;
    var _container = viewerApi.container;
    var _autocam = viewerApi.autocam;
    var _navapi = viewerApi.navigation;
    var _viewerUtilities = viewerApi.utilities;
    var _names = ["beeline"];

    var _state = kStartState;
    var _isDragging = false;
    var _mouseButtons = 0;
    var _flightStartTime = null;
    var _flightDuration = null;
    var _intersectPointNear = new THREE.Vector3();
    var _intersectPointFar = new THREE.Vector3();
    var _flightStartPosition = new THREE.Vector3();
    var _flightEndPosition = new THREE.Vector3();
    var _haltAnimation = false;
    var _mouseXY = new THREE.Vector3();
    var _previousXY = new THREE.Vector3();

    var _expectedCameraState = null;
    var _touchType = null;

    function screenModeChanged()
    {
        self.revertToStartState();
    }

    // Utility methods
    function getCameraState(camera) {
        var state = {};

        state.target  = camera.target.clone();
        state.worldup = camera.worldup.clone();

        state.position = camera.position.clone();
        state.up = camera.up.clone();

        var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];
        for (var i = 0; i < props.length; i++) {
            state[props[i]] = camera[props[i]];
        }

        return state;
    }

    function compareCameraToState(camera, state) {
        var result = camera.target.equals(state.target) &&
            camera.position.equals(state.position) &&
            camera.worldup.equals(state.worldup) &&
            camera.up.equals(state.up);

        if (!result) {
            return false;
        }

        var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];
        for (var i = 0; i < props.length; i++) {
            if (camera[props[i]] !== state[props[i]]) {
                return false;
            }
        }

        return true;
    }

    function getIntersectionPoints(normalizedScreenPosition) {
        var viewportVec = new THREE.Vector3(normalizedScreenPosition.x, normalizedScreenPosition.y, 1.0);
        var result = viewerImpl.hitTestViewport(viewportVec.clone(), false);

        if (!result || !result.intersectPoint) {
            return [];
        }

        var caster = new THREE.Raycaster();
        var vector = viewportVec.clone();
        var camera = viewerImpl.camera;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

        vector.z = -1.0;
        vector = vector.unproject( camera );
        end = end.unproject( camera );
        end.sub(vector).normalize();
        caster.set(_navapi.isPerspective ? camera.position : vector, end);

        var intersects = [];

        // Get intersection points
        var frags = result.fragId instanceof Array ? result.fragId : [result.fragId];
        for (var i = 0; i < frags.length; i++) {
            var mesh = viewerImpl.getRenderProxy(viewerApi.model, frags[i]);

            avp.VBIntersector.meshRayCast(mesh, caster, intersects);
        }

        intersects.sort(function(a,b) { return a.distance - b.distance;});

        return intersects;
    }

    function prepareCamera() {
        if (!_navapi.isPerspective) {
            _navapi.toPerspective();
            _viewerUtilities.activatePivot(false);
        }
        if (_navapi.getFocalLength() > kMaxFocalLength) {
            _navapi.setFocalLength(kMaxFocalLength, true);
        }
    }

    // Tool methdos
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(toolName)
    {
        _mouseButtons = 0;
        viewerApi.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);
        _autocam.userLookSpeed = kLookSensitivity;
        this.showHUDMessage(true);
    };

    this.deactivate = function()
    {
        viewerApi.removeEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);
        this.revertToStartState();
        this.showHUDMessage(false);
    };

    this.getCursor = function()
    {
        if (_isDragging) {
            return "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAQAAADYBBcfAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGGlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBFTAyMHy7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BSMDVQYqg4jIKAUICxE+CDEESC4tKoMHJQODAIMCgwGDA0MAQyJDPcMChqMMbxjFGV0YSxlXMN5jEmMKYprAdIFZmDmSeSHzGxZLlg6WW6x6rK2s99gs2aaxfWMPZ9/NocTRxfGFM5HzApcj1xZuTe4FPFI8U3mFeCfxCfNN45fhXyygI7BD0FXwilCq0A/hXhEVkb2i4aJfxCaJG4lfkaiQlJM8JpUvLS19QqZMVl32llyfvIv8H4WtioVKekpvldeqFKiaqP5UO6jepRGqqaT5QeuA9iSdVF0rPUG9V/pHDBYY1hrFGNuayJsym740u2C+02KJ5QSrOutcmzjbQDtXe2sHY0cdJzVnJRcFV3k3BXdlD3VPXS8Tbxsfd99gvwT//ID6wIlBS4N3hVwMfRnOFCEXaRUVEV0RMzN2T9yDBLZE3aSw5IaUNak30zkyLDIzs+ZmX8xlz7PPryjYVPiuWLskq3RV2ZsK/cqSql01jLVedVPrHzbqNdU0n22VaytsP9op3VXUfbpXta+x/+5Em0mzJ/+dGj/t8AyNmf2zvs9JmHt6vvmCpYtEFrcu+bYsc/m9lSGrTq9xWbtvveWGbZtMNm/ZarJt+w6rnft3u+45uy9s/4ODOYd+Hmk/Jn58xUnrU+fOJJ/9dX7SRe1LR68kXv13fc5Nm1t379TfU75/4mHeY7En+59lvhB5efB1/lv5dxc+NH0y/fzq64Lv4T8Ffp360/rP8f9/AA0ADzT6lvFdAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEtSURBVHja7JQxTkJBFEXPQ/xQEDG0ljRYSU1iLN2AtSWlC7Gw04QtGF2ApQVLIDY2hlgIDagJwWCOhf74JXxRYumbaib3ZO7c9zIhq1WBfzAfjJViDWPdYBq/w0pKITjhd7eGJwQkDu2I8rOFHYcmkqgDz4wfoeGZA01BHXtsbSla89ixZsH3an2LtpRUOQde28xFm17PgyPvVK1bl5yYEOtuq3rnyMQCXNJgiiTchuHCnhrGbYBMaXAJULGqlJz54O43bcFdH5xZUqpWJJWW7duza/tDmTWJbbv27Fs2PS2m1iZRNeGcI/aAEevOgCKnbAI7DNjjhUmk1ouf7xgHbLgF3MSzT7wCaxxSiW3hnsf4OngLotj3ILO74CoWTWzOIGcTXab4/6z+CnwbAGjXSZC++vLvAAAAAElFTkSuQmCC), auto";
        } else if (_mouseButtons <= 1) {
            return "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAQdJREFUeNq0k0GOgzAMRZ+jHI4VO4410qzam0aCjbsoaS1PUgfoWIqAEPnZ3z8AN0DNWoFfVeUbC0BtrOtaISNhC3tvGkC2P7ZtY1kWgHul90JEtCYTkVqo7O844LPyeZ51RJ5atQ3biZeolFJ0miYd1d4nd5A/gB+g7E++AFB7VqzWIkKkfdW/d27P8RpE4p8jRy7Z9ZBOpSEgRRb0MAv0lmxZNEXJj0IACTvwrfeksJBW9a0Z6NEh+vl4UI6qHzHBJ4nyFQv6YoaG3Ls80X7vTIqS1W+vdWvArfuSG/pplPzTBRy6ybaLkSSHAFcThoCe/c6C81n7jUY6a78rHQigftBnQY8BAEubfpuApyq2AAAAAElFTkSuQmCC), auto";
        }

        return null;
    };

    this.update = function () {
        var camera = _navapi.getCamera();
        _isDragging = false;

        var moved = false;
        if (_mouseButtons === 1) {
            var deltaXY = _mouseXY.clone().sub(_previousXY);
            if (deltaXY.x !== 0 || deltaXY.y !== 0) {
                _isDragging = true;
                _previousXY.x += deltaXY.x * kDampingFactor;
                _previousXY.y += deltaXY.y * kDampingFactor;
                
                var worldDotCamera = _navapi.getWorldUpVector().dot(_navapi.getCameraUpVector());
                var horDirection = viewerApi.prefs.reverseHorizontalLookDirection ? -1 : 1;
                var vertDirection = viewerApi.prefs.reverseVerticalLookDirection ? -1 : 1;

                deltaXY.x *= worldDotCamera < 0 ? -horDirection : horDirection;
                deltaXY.y *= vertDirection;

                // Make sure we're synced with the camera
                _autocam.sync(_navapi.getCamera());
                _autocam.look(deltaXY);
                moved = true;

                _expectedCameraState = getCameraState(camera);
            }
        }
        return moved;
    };

    // Beeline methods
    this.revertToStartState = function()
    {
        _viewerUtilities.pivotActive(false);
        _state = kStartState;
        _haltAnimation = true;
    };

    this.attemptFlight = function(normalizedScreenPosition, mode)
    {
        if (!_navapi.isActionEnabled('walk')) {
            return;
        }

        var intersectionPoints = getIntersectionPoints(normalizedScreenPosition);

        if (intersectionPoints.length > 0) {
            _intersectPointNear = intersectionPoints[0].point;
            _intersectPointFar = intersectionPoints[intersectionPoints.length - 1].point;
            self.fly(kDefaultFlightDuration, mode);
        }
    };

    this.fly = function(duration, mode)
    {
        // Pivot needs to be set before altering focal length to make it less jarring for the user. Changing the focal
        // length alters the camera's position and we need the camera's position to calculate the far pivot. Instead,
        // use approximation of where the far pivot will be (i.e. _intersectPointFar).
        _viewerUtilities.setPivotPoint(mode === MODE.GO_TO ? _intersectPointNear : _intersectPointFar, true, true);
        prepareCamera();

        _flightStartPosition = _navapi.getPosition();
        _flightDuration = duration;
        switch (mode) {
            case MODE.GO_TO:
                // Fly 80% of the way there
                _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointNear, 0.8);
                break;

            case MODE.PASS_THROUGH:
                // Fly 2 near planes past the object.
                var near = _autocam.camera.near * 2;
                var distance = _intersectPointFar.clone().sub(_flightStartPosition).length();
                var nearRatio = near / distance;

                _viewerUtilities.setPivotPoint(_flightStartPosition.clone().lerp(_intersectPointFar, 1 + 10 * nearRatio), true, true);
                _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointFar, 1 + nearRatio);
                break;

            default:
                return;
        }

        _state = kFlightState;

        _haltAnimation = false;
        _flightStartTime = null;

        requestAnimationFrame(self.step);
    };

    // Animating the camera
    this.step = function(timestamp)
    {
        var camera = _navapi.getCamera();

        if (_haltAnimation) {
            return;
        }

        if (_flightStartTime === null) {
            _expectedCameraState = getCameraState(camera);

            _flightStartTime = timestamp;
        } else if (!compareCameraToState(camera, _expectedCameraState)) {
            self.revertToStartState();
            return;
        }

        var flightTime = timestamp - _flightStartTime;
        var t = flightTime < _flightDuration ? flightTime / _flightDuration : 1;

        var newPosition = _flightStartPosition.clone().lerp(_flightEndPosition, t);

        // Keep target the same distance as the pivot
        var viewVec = _navapi.getEyeVector();
        viewVec.multiplyScalar(_navapi.getPivotPoint().sub(_navapi.getPosition()).length() / viewVec.length());

        _navapi.setView(newPosition, viewVec.add(newPosition));

        _expectedCameraState = getCameraState(camera);

        _viewerUtilities.activatePivot(false);

        if (flightTime < _flightDuration) {
            requestAnimationFrame(self.step);
        } else {
            self.revertToStartState();
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this.handleGesture = function( event )
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();

        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;
        }
        return false;
    };


    this.handleButtonDown = function( event, button )
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();

        _mouseButtons += 1 << button;

        if (button === 0) {
            _previousXY.x = _mouseXY.x = event.canvasX;
            _previousXY.y = _mouseXY.y = event.canvasY;
            return true;
        }
        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        _mouseButtons -= 1 << button;

        if (button === 0) {
            return true;
        }
        return false;
    };

    this.handleSingleClick = function( event, button )
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();

        // Anything besides LMB should revert viewer to initial state
        if (button === 0) {
            var normalizedScreenLocation = {
                x: event.normalizedX,
                y: event.normalizedY
            };

            switch (_state) {
                case kStartState:
                    self.attemptFlight(normalizedScreenLocation, MODE.GO_TO);
                    break;

                case kFlightState:
                    self.revertToStartState();
                    break;

                default:
                    break;
            }
        } else {
            this.revertToStartState();
            return false;
        }

        return true;
    };

    this.handleSingleTap = function( event )
    {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function( event )
    {
        if( event.pointers && event.pointers.length === 1 ) {
            self.attemptFlight({x: event.normalizedX, y: event.normalizedY}, MODE.PASS_THROUGH);
            return true;
        }
        return false;
    };

    this.handleDoubleClick = function( event, button )
    {
        if (button === 0) {
            self.attemptFlight({x: event.normalizedX, y: event.normalizedY}, MODE.PASS_THROUGH);
            return true;
        }

        return false;
    };

    this.handleMouseMove = function( event )
    {
        _mouseXY.x = event.canvasX;
        _mouseXY.y = event.canvasY;

        if (_mouseButtons === 1) {
            prepareCamera();
            return true;
        }

        return false;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.revertToStartState();
        return false;
    };

    this.showOrthoWarningMessage = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "Orthographic View Set",
            "messageKey"    : "The view is set to Orthographic Beeline",
            "messageDefaultValue"  : "The view is set to Orthographic. Using this tool will switch to Perspective."
        };
        var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCallback);
    };

    this.showFocalWarningMessage = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "Long Focal Length View Set",
            "messageKey"    : "The view is set to a long focal length",
            "messageDefaultValue"  : "This view has a long focal length. Using this tool will set a short focal length."
        };
        var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCallback);
    };

    this.watchCamera = function(e)
    {
        // If camera changed to ORTHO and we are still in Beeline mode
        // put up the warning message that the system will switch to perspective.
        // Similarly, warn for long focal length.
        if (_viewerapi.toolController.getActiveToolName() === _names[0] ||
            _viewerapi.toolController.getActiveToolName() === _names[1]) {
            var camera = _navapi.getCamera();
            var isOrtho = camera && !camera.isPerspective;
            var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;

            if (isOrtho)
                self.showOrthoWarningMessage();
            else if (hasLongFocalLength)
                self.showFocalWarningMessage();
            else
                Autodesk.Viewing.Private.HudMessage.dismiss();
        }
    };

    this.showHUDMessage = function(state)
    {
        var camera = _navapi.getCamera();
        var isOrtho = camera && !camera.isPerspective;
        var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;

        if (state && isOrtho) {
            self.showOrthoWarningMessage();
        } else if (state && hasLongFocalLength) {
            self.showFocalWarningMessage();
        } else {
            Autodesk.Viewing.Private.HudMessage.dismiss();
        }

        if (state) {
            _viewerapi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);
        } else {
            _viewerapi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);
        }
    };

};



(function() {

'use strict';

var avet = AutodeskNamespace('Autodesk.Viewing.Extensions.DefaultTools');

var av = Autodesk.Viewing,
    AVU = av.UI;

function createNavToggler(viewer, button, name) {
    return function() {
        var state = button.getState();
        if (state === AVU.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool(name);
            button.setState(AVU.Button.State.ACTIVE);
        } else if (state === AVU.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
            button.setState(AVU.Button.State.INACTIVE);
        }
    };
}

var NavToolsExtension = function(viewer, options) {
    av.Extension.call(this, viewer, options);
};

NavToolsExtension.prototype = Object.create(av.Extension.prototype);
NavToolsExtension.prototype.constructor = NavToolsExtension;

NavToolsExtension.prototype.load = function() {
    var viewer = this.viewer;

    // Register tools
    var fovtool  = new av.FovTool(viewer);
    var rolltool = new av.WorldUpTool(viewer.impl, viewer);

    viewer.toolController.registerTool( fovtool );
    viewer.toolController.registerTool( rolltool );

    this.createUI();
    this.initCameraStateMachine();
    this.initFocalLengthOverlay();

    return true;
};

NavToolsExtension.prototype.createUI = function()
{
    // Adds the UI for the default navigation tools (orbit, pan, dolly, camera controls)
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
    var navActionDisplayMode = function(action) {
        return viewer.navigation.isActionEnabled(action) ? 'block' : 'none'
    };

    navTools.returnToDefault = function() {};

    if (this.options.mode === '3d') {
        var orbitToolsButton = new AVU.ComboButton('toolbar-orbitTools');
        orbitToolsButton.setToolTip('Orbit');
        orbitToolsButton.setIcon("adsk-icon-orbit-constrained");
        orbitToolsButton.setDisplay(navActionDisplayMode('orbit'));

        this.createOrbitSubmenu(orbitToolsButton);

        navTools.addControl(orbitToolsButton);
        navTools.orbittoolsbutton = orbitToolsButton;
        orbitToolsButton.setState(AVU.Button.State.ACTIVE);

        navTools.returnToDefault = function() {
            orbitToolsButton.setState(AVU.Button.State.ACTIVE);
        };
    }

    var panButton = new AVU.Button('toolbar-panTool');
    panButton.setToolTip('Pan');
    panButton.setIcon("adsk-icon-pan");
    panButton.onClick = createNavToggler(viewer, panButton, 'pan');
    panButton.setDisplay(navActionDisplayMode('pan'));

    navTools.addControl(panButton);
    navTools.panbutton = panButton;

    var dollyButton = new AVU.Button('toolbar-zoomTool');
    dollyButton.setToolTip('Zoom');
    dollyButton.setIcon("adsk-icon-zoom");
    dollyButton.onClick = createNavToggler(viewer, dollyButton, 'dolly');
    dollyButton.setDisplay(navActionDisplayMode('zoom'));

    navTools.addControl(dollyButton);
    navTools.dollybutton = dollyButton;

    var cameraButton = new AVU.ComboButton('toolbar-cameraSubmenuTool');
    cameraButton.setToolTip('Camera interactions');
    cameraButton.setIcon("adsk-icon-camera");
    cameraButton.saveAsDefault();
    this.createCameraSubmenu(cameraButton);
    navTools.addControl(cameraButton);
    navTools.camerabutton = cameraButton;
};


NavToolsExtension.prototype.createOrbitSubmenu = function(parentButton)
{
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    var freeOrbitButton = new AVU.Button('toolbar-freeOrbitTool');
    freeOrbitButton.setToolTip('Free orbit');
    freeOrbitButton.setIcon("adsk-icon-orbit-free");
    freeOrbitButton.onClick = createNavToggler(viewer, freeOrbitButton, 'freeorbit');

    parentButton.addControl(freeOrbitButton);
    navTools.freeorbitbutton = freeOrbitButton;

    var orbitButton = new AVU.Button('toolbar-orbitTool');
    orbitButton.setToolTip('Orbit');
    orbitButton.setIcon("adsk-icon-orbit-constrained");
    orbitButton.onClick = createNavToggler(viewer, orbitButton, 'orbit');

    parentButton.addControl(orbitButton);
    navTools.orbitbutton = orbitButton;

    parentButton.onClick = orbitButton.onClick; // default

};

NavToolsExtension.prototype.createCameraSubmenu = function(parentButton)
{
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
    var navActionDisplayMode = function(action) {
        return viewer.navigation.isActionEnabled(action) ? 'block' : 'none'
    };

    if (av.isTouchDevice()) {
        var homeButton = new AVU.Button('toolbar-homeTool');
        homeButton.setToolTip('Home');
        homeButton.setIcon("adsk-icon-home");
        homeButton.onClick = function () {
            viewer.navigation.setRequestHomeView(true);
            var defaultNavToolName = viewer.getDefaultNavigationToolName();
            viewer.setActiveNavigationTool(defaultNavToolName);
            parentButton.restoreDefault();
        };
        homeButton.setDisplay(navActionDisplayMode('gotoview'));

        parentButton.addControl(homeButton);
        navTools.homebutton = homeButton;
    }

    //options = { defaultTooltipValue : "Fit to view (F)" };
    var fitToViewButton = new AVU.Button('toolbar-fitToViewTool');
    fitToViewButton.setToolTip('Fit to view');
    fitToViewButton.setIcon("adsk-icon-fit-to-view");
    fitToViewButton.onClick = function(e) {
        // Need to map the objects to dbIds
        viewer.fitToView(self.options.mode === "3d" ? viewer.getSelection() : undefined);
        var defaultNavToolName = viewer.getDefaultNavigationToolName();
        viewer.setActiveNavigationTool(defaultNavToolName);
        parentButton.restoreDefault();
    };
    fitToViewButton.setDisplay(navActionDisplayMode('gotoview'));

    parentButton.addControl(fitToViewButton);
    navTools.fovbutton = fitToViewButton;

    if (this.options.mode === "3d") {
        //options.defaultTooltipValue = "Focal length (Ctrl+Shift drag)";
        var fovButton = new AVU.Button('toolbar-focalLengthTool');
        fovButton.setToolTip('Focal length');
        fovButton.setIcon("adsk-icon-fov");
        fovButton.onClick = createNavToggler(viewer, fovButton, 'fov');
        fovButton.setDisplay(navActionDisplayMode('fov'));

        parentButton.addControl(fovButton);
        navTools.fovbutton = fovButton;
    }

    //options.defaultTooltipValue = "Roll (Alt+Shift drag)";
    var rollButton = new AVU.Button('toolbar-rollTool');
    rollButton.setToolTip('Roll');
    rollButton.setIcon("adsk-icon-roll");
    rollButton.onClick = createNavToggler(viewer, rollButton, 'worldup');
    rollButton.setDisplay(navActionDisplayMode('roll'));

    parentButton.addControl(rollButton);
    navTools.rollbutton = rollButton;
};

NavToolsExtension.prototype.initCameraStateMachine = function(mode) {
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    this.toolChangedHandler = function (e) {
        if (e.toolName === "fov") {
            self.showFocalLengthOverlay(e.active);
        }
    };
    viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedHandler);

    this.navChangedHandler = function(e) {
        if (viewer.getDefaultNavigationToolName() === e.id)
            navTools.returnToDefault();
    };
    viewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
};

NavToolsExtension.prototype.initFocalLengthOverlay = function() {

    var container = this.focallength = document.createElement("div");

    container.className = "focallength";

    var table = document.createElement("table");
    var tbody = document.createElement("tbody");
    table.appendChild(tbody);

    container.appendChild(table);
    this.viewer.container.appendChild(container);

    var row = tbody.insertRow(-1);
    var cell = row.insertCell(0);
    cell.setAttribute( "data-i18n", "Focal Length" );
    cell.textContent = Autodesk.Viewing.i18n.translate( "Focal Length" );
    cell = row.insertCell(1);
    cell.textContent = '';
    cell.style.width = "4em";
    cell.style.textAlign = "right";
    this.fovCell = cell;

    container.style.visibility = "hidden";
};

NavToolsExtension.prototype.showFocalLengthOverlay = function(state)
{
    var self = this;
    var viewer = this.viewer;
    var myFocalLength = 0;

    function showFovHudMessage(yes) {
        if( yes ) {
            // Display a hud messages.
            var messageSpecs = {
                "msgTitleKey"   : "Orthographic View Set",
                "messageKey"    : "The view is set to Orthographic",
                "messageDefaultValue" : "The view is set to Orthographic. Changing the focal length will switch to Perspective."
            };
            av.Private.HudMessage.displayMessage(viewer.container, messageSpecs);
        }
        else {
            av.Private.HudMessage.dismiss();
        }
    }

    function showFov(yes) {
        if (yes) updateFOV();

        if( self.focallength )
            self.focallength.style.visibility = yes ? "visible" : "hidden";
    }

    function updateFOV() {
        var camFocalLength = viewer.getFocalLength();
        if( myFocalLength !== camFocalLength )
        {
            myFocalLength = camFocalLength;
            self.fovCell.textContent = camFocalLength.toString() + " mm";
        }
    }

    function watchFOV(e) {
        updateFOV();
        // If camera changed to ORTHO and we are still in FOV mode
        // put up the warning message that the system will switch to perspective.
        //
        if (viewer.toolController.getActiveToolName() === "fov") {
            var camera = viewer.navigation.getCamera();
            var isOrtho = camera && !camera.isPerspective;

            showFov(!isOrtho);
            showFovHudMessage(isOrtho);
        }
    }
    var camera = viewer.navigation.getCamera();
    var isOrtho = camera && !camera.isPerspective;

    showFov(state && !isOrtho);
    showFovHudMessage(state && isOrtho);

    if( state ) {
        viewer.addEventListener(av.CAMERA_CHANGE_EVENT, watchFOV);
    }
    else {
        viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, watchFOV);
    }
};

NavToolsExtension.prototype.unload = function () {
    this.destroyUI();

    return true;
};

NavToolsExtension.prototype.destroyUI = function () {
    // Removes the UI created in createUI
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(false);

    if (!toolbar) {
        return true;
    }

    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    if (!navTools) {
        return true;
    }

    if (this.options.mode === '3d') {
        navTools.orbittoolsbutton.subMenu.removeEventListener(AVU.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, navTools.orbittoolsbutton.subMenuActiveButtonChangedHandler(navTools));
        navTools.removeControl(navTools.orbittoolsbutton.getId());
        navTools.orbittoolsbutton = null;
        navTools.orbitbutton.onClick = null;
        navTools.orbitbutton = null;
        navTools.freeorbitbutton.onClick = null;
        navTools.freeorbitbutton = null;
    }

    navTools.removeControl(navTools.panbutton.getId());
    navTools.panbutton.onClick = null;
    navTools.panbutton = null;

    navTools.removeControl(navTools.dollybutton.getId());
    navTools.dollybutton.onClick = null;
    navTools.dollybutton = null;

    navTools.camerabutton.subMenu.removeEventListener(AVU.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, navTools.camerabutton.subMenuActiveButtonChangedHandler(navTools));
    navTools.removeControl(navTools.camerabutton.getId());
    navTools.camerabutton.onClick = null;
    navTools.camerabutton = null;

    navTools.rollbutton.onClick = null;
    navTools.rollbutton = null;
    navTools.fovbutton.onClick = null;
    navTools.fovbutton = null;

    this.focallength = null;

    // Remove Listeners
    viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedHandler);
    this.toolChangedHandler = null;
    viewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
    this.navChangedHandler = null;

    return true;
};

avet.NavToolsExtension = NavToolsExtension;

av.theExtensionManager.registerExtension('Autodesk.DefaultTools.NavTools', NavToolsExtension);

})();

AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * Formats a value with units
 * @param {number} value
 * @param {string} units - GNU units format
 * @param {number} type - For example: 1=boolean, 2=integer, 3=double, 20=string, 24=Position
 * @param {number} precision - required precision.
 * see https://git.autodesk.com/A360/platform-translation-propertydb/blob/master/propertydb/PropertyDatabase.h
 * @returns {string} formatted value
 */
Autodesk.Viewing.Private.formatValueWithUnits = function (value, units, type, precision) {

    function modf(x) {
        var intPart = (0 <= x) ? Math.floor(x) : Math.ceil(x),
            fracPart = x - intPart;
        return {intPart: intPart, fracPart: fracPart};
    }

    function formatNumber(x, precision, needMinusSign) {
        var result = '';

//        // Change -0.0 to 0.0
//        if (x === 0.0) {
//            x = 0.0;
//        }

        if (needMinusSign && x === 0) {
            result += '-';
        }

        //According to Shawn's request, do not truncate trailing .0's
        //if (modf(x).fracPart === 0) {
        //
        //    // No fractional part.
        //    //
        //    result += x;
        //
        //} else if (0 < precision) {
        if (0 < precision) {

            // Truncate any trailing .0's.
            //
            //var s = x.toFixed(precision);
            //var re = /^\-?([0-9]+)\.0+$/;
            //var m = re.exec(s);
            //if (m !== null) {
            //    result += m[1];
            //} else {
            //    result += s;
            //}

            result += x.toFixed(precision);

        } else {
            result += x.toFixed(0);
        }

        return result;
    }

    function formatFeet(value, precision, inchesOnly) {

        // Borrowed from AdCoreUnits PrimeDoublePrimeSymbol2::Format

        var result = '',
            radix = 12.0,
            denominator = 1.0,
            isNegative = (value < 0);

        for (var i = 0; i < precision; ++i) {
            denominator *= 2.0;
        }

        // round to the nearest 1/denominator
        if (value > 0) {
            value += 0.5/denominator;
        } else {
            value -= 0.5/denominator;
        }

        var primeValue, doublePrimeValue;

        if (!inchesOnly) {
            primeValue = modf(value/radix).intPart;
            result += formatNumber(primeValue, 0, isNegative) + '\' ';
            doublePrimeValue = value - (primeValue * radix);
            if (doublePrimeValue < 0) {
                doublePrimeValue = -doublePrimeValue;
            }

        } else {
            doublePrimeValue = value;
        }

        var intPart = modf(doublePrimeValue).intPart;
        var numerator = modf((doublePrimeValue - intPart) * denominator).intPart;

        if (numerator === 0 || intPart !== 0) {
            result += formatNumber(intPart, 0);
        }

        if (numerator !== 0) {
            if (intPart < 0 && numerator < 0) {
                numerator = -numerator;
            }
            while (numerator % 2 === 0) {
                numerator /= 2;
                denominator /= 2;
            }
            if (intPart !== 0) {
                result += '-';
            }
            result += formatNumber(numerator, 0) + '/' + formatNumber(denominator, 0);
        }

        result += '\"';
        return result;
    }

    function formatMeterAndCentimeter(value, precision) {
        var sign = '';
        if (value < 0) {
            sign = '-';
            value = Math.abs(value);
        }
        var modfValue = modf(value),
            mValue = modfValue.intPart,
            cmValue = modfValue.fracPart * 100.0;

        return sign + formatNumber(mValue, 0) + ' m ' + formatNumber(cmValue, precision) + ' cm';
    }

    function formatFeetAndDecimalInches(value, precision) {
        var sign = '';
        if (value < 0) {
            sign = '-';
            value = Math.abs(value);
        }
        var modfValue = modf(value),
            ftValue = modfValue.intPart,
            inValue = modfValue.fracPart * 12.0;

        return sign + formatNumber(ftValue, 0) + '\' ' + formatNumber(inValue, precision) + '\"';
    }

    var result;

    if (precision === undefined) {
        precision = 3;
    }

    // TODO(go) - 20150504: Ideally this would be handled better: according to the git file at the top property types can be 0,1,2,3,10,11,20,21,22,23,24
    // TODO(go) - 20150504: The code below only handle Boolean (1) Integer (2) and double (3). Not sure how well the property types are assigned so using
    // TODO(go) - 20150504: try catch for now.
    try {

        if (type === 1) { // Boolean
            result = Autodesk.Viewing.i18n.translate(value ? 'Yes' : 'No');

        } else if (type === 24) { // Position
            var position = value.split(' ');
            result = [];

            for(var i = 0; i < position.length; ++i) {
                result.push(Autodesk.Viewing.Private.formatValueWithUnits(parseFloat(position[i]), units, 3, precision));
            }

            result = result.join(', ');

        } else if ((type === 2 || type === 3) && isNaN(value)) {
            result = 'NaN';

        } else if (units === 'ft-and-fractional-in') {
            result = formatFeet(value * 12.0, precision);

        } else if (units === 'ft-and-fractional-in^2') {
            result = formatFeet(value * 12.0, precision) + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'ft-and-decimal-in') {
            result = formatFeetAndDecimalInches(value, precision);

        } else if (units === 'ft-and-decimal-in^2') {
            result = formatFeetAndDecimalInches(value, precision) + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'decimal-in' || units === 'in' || units === 'inch') {
            result = formatNumber(value, precision) + '\"';

        } else if (units === 'decimal-in^2' || units === 'in^2' || units === 'inch^2') {
            result = formatNumber(value, precision) + '\"' + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'decimal-ft' || units === 'ft' || units === 'feet' || units === 'foot') {
            result = formatNumber(value, precision) + '\'';

        } else if (units === 'decimal-ft^2' || units === 'ft^2' || units === 'feet^2' || units === 'foot^2') {
            result = formatNumber(value, precision) + '\'' + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'fractional-in') {
            result = formatFeet(value, precision, /*inchesOnly=*/true);

        } else if (units === 'fractional-in^2') {
            result = formatFeet(value, precision, /*inchesOnly=*/true) + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'm-and-cm') {
            result = formatMeterAndCentimeter(value, precision);

        } else if (units === 'm-and-cm^2') {
            result = formatMeterAndCentimeter(value, precision) + ' ' + String.fromCharCode(0xb2);

        } else if (type === 3 && units) { // Double, with units
            units = units.replace("^2", String.fromCharCode(0xb2));
            units = units.replace("^3", String.fromCharCode(0xb3));
            result = formatNumber(value, precision) + ' ' + units;

        } else if (units) {
            result = value + ' ' + units;

        } else if (type === 3) { // Double, no units
            result = formatNumber(value, precision);

        } else {
            result = value;
        }

    } catch (e) {

        if (units) {
            result = value + ' ' + units;
        } else {
            result = value;
        }
    }

    return result;
};

/**
 * Convert distance from unit to unit.
 * @param {string} fromUnits - GNU units format - units to convert from
 * @param {string} toUnits - GNU units format - units to convert to
 * @param {number} d - distance to convert
 * @param {string} type - default for distance, "square" for area
 * @returns {number} - distance after conversion.
 */
Autodesk.Viewing.Private.convertUnits = function (fromUnits, toUnits, d, type) {

    if (fromUnits === toUnits)
        return d;

    var toFactor = 1;
    switch (toUnits) {
        case "mm": toFactor = 1000; break;
        case "cm": toFactor = 100; break;
        case "m" : toFactor = 1; break;
        case "in": toFactor = 39.37007874; break;
        case "ft": toFactor = 3.280839895; break;
        case "ft-and-fractional-in": toFactor = 3.280839895; break;
        case "ft-and-decimal-in": toFactor = 3.280839895; break;
        case "decimal-in": toFactor = 39.37007874; break;
        case "decimal-ft": toFactor = 3.280839895; break;
        case "fractional-in": toFactor = 39.37007874; break;
        case "m-and-cm": toFactor = 1; break;
    }

    var fromFactor = 1;
    switch (fromUnits) {
        case "mm": fromFactor = 0.001; break;
        case "cm": fromFactor = 0.01; break;
        case "m" : fromFactor = 1; break;
        case "in": fromFactor = 0.0254; break;
        case "ft": fromFactor = 0.3048; break;
        case "ft-and-fractional-in": fromFactor = 0.3048; break;
        case "ft-and-decimal-in": fromFactor = 0.3048; break;
        case "decimal-in": fromFactor = 0.0254; break;
        case "decimal-ft": fromFactor = 0.3048; break;
        case "fractional-in": fromFactor = 0.0254; break;
        case "m-and-cm": fromFactor = 1; break;
    }

    if (type === "square") {

        return (d * Math.pow(toFactor * fromFactor, 2));
    }
    return (d * toFactor * fromFactor);
};


(function() {

'use strict';

var avem = AutodeskNamespace('Autodesk.Viewing.Extensions.Measure'),
    av = Autodesk.Viewing,
    avu = av.UI;

/**
 * Extension used to support distance and angle measure for 2d and 3d models.
 * @constructor
 * @tutorial feature_measure
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer to be extended.
 * @param {object} options - An optional dictionary of options for this extension.
 * @memberof Autodesk.Viewing.Extensions.Measure
 * @alias Autodesk.Viewing.Extensions.Measure.MeasureExtension
 * @category Extensions
*/
var MeasureExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

MeasureExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
MeasureExtension.prototype.constructor = MeasureExtension;


MeasureExtension.prototype.onToolbarCreated = function() {
    this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.bindedOnToolbarCreated);
    this.bindedOnToolbarCreated = null;
    this.createUI();
};

/**
 * Load the measure extension.
 * @returns {boolean} True if measure extension is loaded successfully.
*/
MeasureExtension.prototype.load = function() {

    var self   = this;
    var viewer = this.viewer;

    this.escapeHotkeyId = 'Autodesk.Measure.Hotkeys.Escape';

    // Register the Measure tool
    if (!viewer.toolController){
        return false;
    }
    this.tool = new avem.MeasureTool(viewer, { onCloseCallback: function(e) {
        self.enableMeasureTool(false);
    }});
    viewer.toolController.registerTool(this.tool);

    if (this.viewer.toolbar) {
        this.createUI();
    } else {
        this.bindedOnToolbarCreated = this.onToolbarCreated.bind(this);
        this.viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.bindedOnToolbarCreated);
    }

    return true;
};

/**
 * Unload the measure extension.
 * @returns {boolean} True if measure extension is unloaded successfully.
*/
MeasureExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove the ui from the viewer.
    this.destroyUI();
    if (this.bindedOnToolbarCreated) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.bindedOnToolbarCreated);
        this.bindedOnToolbarCreated = null;
    }

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Whether the measure tool is currently active.
 * @returns {boolean}
 */
MeasureExtension.prototype.isActive = function() {
    return this.tool.isActive();
};

/**
 * Enable/disable the measure tool.
 * @param {boolean} active - True to activate, false to deactivate.
 * @returns {boolean} True if a change in activeness occurred.
 */
MeasureExtension.prototype.setActive = function(active) {
    return this.enableMeasureTool(active);
};

/**
 * Toggles activeness of the measure tool.
 * @return {boolean} Whether the tool is active.
 */
MeasureExtension.prototype.toggle = function() {
    if (this.isActive()) {
        this.enableMeasureTool(false);
    } else {
        this.enableMeasureTool(true);
    }
    return this.isActive();
};

/**
 * Get the current measurement in the measure tool.
 * @param {string} unitType - Optional measure unit: "decimal-ft", "ft", "ft-and-decimal-in", "decimal-in", "fractional-in", "m", "cm", "mm" or "m-and-cm".
 * @param {number} precision - Optional measure precision index (0: 0, 1: 0.1, 2: 0.01, 3: 0.001, 4: 0.0001, 5: 0.00001).
 * When units type is "ft", "in" or "fractional-in", then the precisions are 0: 1, 1: 1/2, 2: 1/4, 3: 1/8, 4: 1/16, 5: 1/32, 6: 1/64.
 * @returns {object|null} Object with properties of the current measurement, or null.
 */
MeasureExtension.prototype.getMeasurement = function(unitType, precision) {
    var measurement = null;
    if (this.isActive()) {
        measurement = this.tool.getMeasurement(unitType, precision);
    }
    return measurement;
};

/**
 * Get all available units in measure tool.
 * @returns {object[]} Array of all available units.
*/
MeasureExtension.prototype.getUnitOptions = function() {
    var units = [
        { name: 'Unknown', type: '' },
        { name: 'Decimal feet', type: 'decimal-ft' },
        { name: 'Feet and fractional inches', type: 'ft' },
        { name: 'Feet and decimal inches', type: 'ft-and-decimal-in' },
        { name: 'Decimal inches', type: 'decimal-in' },
        { name: 'Fractional inches', type: 'fractional-in' },
        { name: 'Meters', type: 'm' },
        { name: 'Centimeters', type: 'cm' },
        { name: 'Millimeters', type: 'mm' },
        { name: 'Meters and centimeters', type: 'm-and-cm' }
    ];

    return units;
};

/**
 * Get all available precisions in measure tool.
 * @param {boolean} isFractional - Set true to get fractional precisions.
 * @return {string[]} List of all available precisions.
*/
MeasureExtension.prototype.getPrecisionOptions = function(isFractional) {

    if (isFractional)
        var precisions = ['1', '1/2', '1/4', '1/8', '1/16', '1/32', '1/64'];
    else
        var precisions = ['0', '0.1', '0.01', '0.001', '0.0001', '0.00001'];

    return precisions;
};

/**
 * Get the default measure unit in measure tool.
 * @returns {string} The default measure unit.
*/
MeasureExtension.prototype.getDefaultUnit = function() {
    var unit = this.viewer.model.getDisplayUnit();

    return unit;
};

/**
 * Enable/disable the measure tool.
 * @param {boolean} enable - True to enable, false to disable.
 * @returns {boolean} True if the tool state was changed.
 * @private
 */
MeasureExtension.prototype.enableMeasureTool = function(enable) {
    var toolController = this.viewer.toolController,
        isActive = this.tool.isActive();

    this.viewer.impl.disableRollover(enable);

    if (enable && !isActive) {
        toolController.activateTool("measure");
        if (this.measureToolButton) {
            this.measureToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        }
        return true;

    } else if (!enable && isActive) {
        toolController.deactivateTool("measure");
        if (this.measureToolButton) {
            this.measureToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        }
        return true;
    }
    return false;
};



/**
 * Create measure button in toolbar.
 * @private
*/
MeasureExtension.prototype.createUI = function()
{
    var self   = this;
    var viewer = this.viewer;

    this.measureToolButton = null;

    var toolbar = viewer.getToolbar(true);

    // Create a button for the measure tool.
    this.measureToolButton = new avu.Button( "toolbar-measureTool");
    this.measureToolButton.setToolTip("Measure");
    this.measureToolButton.setIcon("adsk-icon-measure");
    this.measureToolButton.onClick = function(e) {
        self.enableMeasureTool(!self.tool.isActive());
    };
    this.onMeasureButtonStateChange = function(e) {
        if (e.state === avu.Button.State.ACTIVE) {
            self.enableMeasureTool(true);
        } else if (e.state === avu.Button.State.INACTIVE) {
            self.enableMeasureTool(false);
        }
    };
    this.measureToolButton.addEventListener(avu.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);

    var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
    if (modelTools) {
        modelTools.addControl(this.measureToolButton, {index:0});
    }

    // Escape hotkey to exit tool.
    //
    var hotkeys = [{
        keycodes: [
            av.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return self.enableMeasureTool(false);
        }
    }];
    av.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, hotkeys);
};

/**
 * Destroy measure button in toolbar.
 * @private
*/
MeasureExtension.prototype.destroyUI = function()
{
    var viewer = this.viewer;

    if (this.measureToolButton) {
        this.measureToolButton.removeEventListener(avu.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);
    }

    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
        if (modelTools) {
            if (this.measureToolButton) {
                var submenu = modelTools.getControl("toolbar-inspectSubMenu");
                if (submenu) {
                    submenu.removeControl(this.measureToolButton.getId());
                } else {
                    modelTools.removeControl(this.measureToolButton.getId());
                }
            }

            this.measureToolButton = null;
        }
    }

    av.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
};

avem.MeasureExtension = MeasureExtension;
av.theExtensionManager.registerExtension('Autodesk.Measure', MeasureExtension);


})();

AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.MeasureTool = function( viewer, options )
{
    var tool = this;

    var _viewer  = viewer;
    var _options = options;

    var _names  = ["measure"];
    var _active = false;

    var _firstClick = null;
    var _secondClick = null;
    var _isDragging = false;
    var _interacting = false;
    var _activePoint = 0;
    var _consumeSingleClick = false;
    var _firstClickGeometry = null;
    var _secondClickGeometry = null;

    var _units = "";
    var _precision = 3;
    var _distances = {};

    var _angle = 0;

    var _redraw = false;

    // UI.
    var _indicator = null;
    var _measurePanel = null;
    var _cursor = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKZJREFUeNrclLEKwzAQQ9+FgH/Nk7d8ViFT+6cG36IsNXgIdMg5kAoOIw8WSDoDvAEN04BdEhFjgCTR4e6klFxSIgDLSNydbdsAPgRCktRaUylFkfZ0Z2qtVTlnAfugGibwAur3JFrAxoBnYGEy1pGYmQCLLNB6Uqmw182M9eRS0yzqGo+y6D9rytSQR8vM7DKfbtHy4x+/xG8J+d4W9WAi8fxFOwYA8W0ypu2ZfcsAAAAASUVORK5CYII=), auto";

    // Snapper
    var _snapper = null;
    var _firstIntersectPoint = null;
    var _secondIntersectPoint = null;
    var _firstFaceNormal = null;
    var _secondFaceNormal = null;
    var _firstCircularArcCenter = null;
    var _secondCircularArcCenter = null;

    // Isolate Measurement
    var _isolateMeasure = false;
    var _firstClickNode = null;
    var _secondClickNode = null;

    // Multiple Viewports For 2D
    var _firstViewportIndex = null;
    var _secondViewportIndex = null;

    var _hasUI = Autodesk.Viewing.Private.GuiViewer3D && viewer instanceof Autodesk.Viewing.Private.GuiViewer3D;

    var _clip = null;

    this.register = function()
    {
        if (_hasUI && !_measurePanel) {
            _measurePanel = new Autodesk.Viewing.Extensions.Measure.MeasurePanel( tool, _viewer, "measure-panel", "Measure", options );
            _viewer.addPanel( _measurePanel );
        }

        if (!_snapper) {
            _snapper = new Autodesk.Viewing.Extensions.Measure.Snapper(viewer);
            _viewer.toolController.registerTool(_snapper);
        }
    };

    this.deregister = function()
    {
        this.deactivate();
        if (_measurePanel) {
            _viewer.removePanel( _measurePanel );
            _measurePanel.uninitialize();
        }

        _viewer.toolController.deregisterTool(_snapper);
        _snapper = null;
    };

    this.isActive = function()
    {
        return _active;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.getCursor = function() {
        return (_isDragging && !_interacting) ? null : _cursor;
    };

    function onCameraChange() {
        _indicator.updateLabelPositions();
    }

    function onReset() {
        tool.clearMeasurement();
    }

    this.activate = function()
    {
        _active = true;
        _activePoint = 0;
        _isDragging = false;

        if (!_units) {
            _units = _viewer.model.getDisplayUnit();
        }

        if (_viewer.model && _viewer.model.is2d()) {
            _precision = 3;
        }
        else {
            _precision = 1;
        }

        activateUI();

        _viewer.clearSelection();
        _viewer.toolController.activateTool("snapper");

       _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
       _viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
    };

    this.deactivate = function()
    {
        _active = false;
        _firstClick = _secondClick = null;
        _distances = {};

        this.clearMeasurement();

        deactivateUI();

        if(_snapper && _snapper.isActive()) {
            _viewer.toolController.deactivateTool("snapper");
        }

        _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
        _viewer.removeEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
    };

    this.update = function()
    {
        return false;
    };

    this.getUnits = function() {
        return _units;
    };

    this.setUnits = function( units )
    {
        if (_units !== units ) {
            _units = units;

            // Update UI
            if (_indicator) {
                _indicator.updateDistance();
                //_indicator.updateLabels();
            }
        }
    };

    this.getPrecision = function() {
        return _precision;
    };

    this.setPrecision = function( precision ) {

        if (_precision !== precision ) {
            _precision = precision;

            // Update UI
            if (_indicator) {
                _indicator.updateDistance();
                //_indicator.updateLabels();
            }
        }
    };

    this.getDistance = function (name) {

        if (_viewer.model && _viewer.model.isLoadDone()) {
            var d = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, _distances[name] || 0);
            return Autodesk.Viewing.Private.formatValueWithUnits(d, _units, 3, _precision);
        }
    };

    this.getAngle = function() {

            return Autodesk.Viewing.Private.formatValueWithUnits(_angle, String.fromCharCode(0xb0), 3, _precision);
    };

    /**
     * TODO: We need to flesh out the return value here.
     *
     * @param unitType
     * @param precision
     * @returns {Object}
     */
    this.getMeasurement = function(unitType, precision) {

        _units = unitType || _units;
        _precision = precision || _precision;

        var geomTypes = ['Vertex', 'Edge', 'Face', 'Circular Arc', 'Curved Edge', 'Curved Face'];

        var measurement = {
            from: geomTypes[this.getFirstGeometry().type],
            to: geomTypes[this.getSecondGeometry().type],
            distance: this.getDistance('xyz'),
            deltaX: this.getDistance('x'),
            deltaY: this.getDistance('y'),
            deltaZ: this.getDistance('z'),
            angle: this.getAngle(),
            unitType: _units,
            precision: _precision
        };
        return measurement;
    };

    this.clearMeasurement = function() {
        _firstClick = _secondClick = null;
        _firstClickGeometry = _secondClickGeometry = null;
        _firstClickNode = _secondClickNode = null;
        _firstViewportIndex = _secondViewportIndex = null;
        _activePoint = 1;
        _distances = {};
        _angle = 0;
        _clip = null;

        if (_indicator) {
            _indicator.hide();
        }
        if (_measurePanel) {
            _measurePanel.updatePanel();
            _measurePanel.hideMeasureResult();

            if (_measurePanel.isolateMeasure) {
                this.clearIsolate();
            }
        }
        //if (_viewer.model.is2d() && _snapper) {
        //    _snapper.setClip();
        //}
        if (_viewer.model.is2d()) {
            viewer.impl.updateViewportId(0);

            if (_snapper)
                _snapper.setFirstClickVpId(null);
        }
    };

    this.clearRubberBand = function() {
        _secondClick = null;
        _secondClickGeometry = null;
        _indicator.hideClick('second');
    };

    this.clearFirstPick = function() {
        if (_secondClick) {
            _indicator.hide();

            _firstClick = _secondClick.clone();
            _firstClickGeometry = _secondClickGeometry;
            _firstIntersectPoint = _secondIntersectPoint;
            _firstFaceNormal = _secondFaceNormal;
            _firstClickNode = _secondClickNode;
            _firstViewportIndex = _secondViewportIndex;
            _firstCircularArcCenter = _secondCircularArcCenter;

            //if (_viewer.model.is2d()) {
            //    _indicator.drawGreyOutPlane(_firstViewportIndex);
            //
            //    // Need to pass the clip to Snapper (disable snapper in greying out area), only snap in the clip
            //    if (_snapper)
            //        _snapper.setClip(_clip);
            //}
            if (_viewer.model.is2d()) {
                // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
                viewer.impl.updateViewportId(_firstViewportIndex);

                if (_snapper)
                    _snapper.setFirstClickVpId(_firstViewportIndex);
            }

            // redraw the first pick
            _redraw = true;
            if (_firstClickGeometry === SNAP_VERTEX) {
                _indicator.showFirstVertex(_firstClick);
            }
            else if (_firstClickGeometry === SNAP_EDGE) {
                _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
            }
            else if (_firstClickGeometry === SNAP_FACE) {
                _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
            }
            else if (_firstClickGeometry === SNAP_CIRCULARARC) {

                _firstClick.center = _secondClick.center;
                _firstClick.radius = _secondClick.radius;
                _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
            }
            else if (_firstClickGeometry === SNAP_CURVEDFACE) {

                _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
            }
            _redraw = false;

            _secondClick = null;
            _secondClickGeometry = null;
            _secondClickNode = null;
            _secondViewportIndex = null;
            _secondCircularArcCenter = null;
            _activePoint = 2;
            _distances = {};
            _angle = 0;

            if (_measurePanel && _measurePanel.isolateMeasure) {
                this.clearIsolate();
            }
        }
        else {
            this.clearMeasurement();
        }

        if (_measurePanel) _measurePanel.showSelection1();
    };

    this.clearSecondPick = function() {
        _secondClick = null;
        _secondClickGeometry = null;
        _secondClickNode = null;
        _secondViewportIndex = null;
        _activePoint = 2;
        _distances = {};
        _angle = 0;
        _indicator.hideClick('second');

        if (_measurePanel && _measurePanel.isolateMeasure) {
            this.clearIsolate();
        }

        if (_viewer.model.is2d()) {
            // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
            viewer.impl.updateViewportId(_firstViewportIndex);

            if (_snapper)
                _snapper.setFirstClickVpId(_firstViewportIndex);
        }
    };

    this.getIndicator = function () {
        return _indicator;
    };

    this.getFirstGeometry = function () {
        return {"type": _firstClickGeometry, "geometry": _firstClick};
    };

    this.getSecondGeometry = function () {
        return {"type": _secondClickGeometry, "geometry": _secondClick};
    };

    this.getEdgeLength = function (edge) {
        return _indicator.getEdgeLength(edge);
    };

    this.getFaceArea = function (face) {
        return _indicator.getFaceArea(face);
    };

    this.getCircularArcRadius = function (edge) {
        return _indicator.getCircularArcRadius(edge);
    };

    this.isolateMeasurement = function () {
        if (_firstClickNode && _secondClickNode) {
            var nodeList = [_firstClickNode, _secondClickNode];
            _viewer.isolate(nodeList);
        }
    };

    this.clearIsolate = function() {
        _viewer.showAll();
    };

    this.isIdenticalEdges = function() {

        if (_firstClick.vertices.length === _secondClick.vertices.length) {

            for (var i = 0; i < _firstClick.vertices.length; i++) {
                if (!_firstClick.vertices[i].equals(_secondClick.vertices[i])) {
                    return false;
                }
            }
            return true;
        }

        return false;
    };

    this.isIdenticalFaces = function() {

        if (_firstClick.faceId && _secondClick.faceId) {
            if (_firstClick.fragId === _secondClick.fragId && _firstClick.faceId === _secondClick.faceId) {
                return true;
            }
        }
        else {
            if (_firstClick.vertices.length === _secondClick.vertices.length) {

                for (var i = 0; i < _firstClick.vertices.length; i++) {
                    if (!_firstClick.vertices[i].equals(_secondClick.vertices[i])) {
                        return false;
                    }
                }
                return true;
            }
        }

        return false;
    };

    this.isIdenticalGeometries = function() {

        if (_firstClickGeometry === _secondClickGeometry) {

            switch (_firstClickGeometry) {

                case SNAP_VERTEX:
                    if (_firstClick.equals(_secondClick))
                        return true;
                    break;
                case SNAP_EDGE: return this.isIdenticalEdges(); break;
                case SNAP_FACE: return this.isIdenticalFaces(); break;
                case SNAP_CIRCULARARC: return this.isIdenticalEdges(); break;
                case SNAP_CURVEDEDGE: return this.isIdenticalEdges(); break;
                case SNAP_CURVEDFACE: return this.isIdenticalFaces(); break;
                default: break;
            }
        }

        return false;
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this._handleMouseEvent = function (event) {

        if(_snapper.isSnapped()) {  // ray cast has intersection with mesh
            if (_activePoint === 0) {
                this.clearMeasurement();
                _activePoint = 1;
            }

            if (_activePoint === 1) {  // First Pick

                _firstViewportIndex = _snapper.getViewportIndex();
                _firstClickGeometry = _snapper.getHighlightGeometry();
                _firstIntersectPoint = _snapper.getIntersectPoint();

                //if (_viewer.model.is2d()) {
                //    _indicator.drawGreyOutPlane(_firstViewportIndex);
                //
                //    // Need to pass the clip to Snapper (disable snapper in greying out area), only snap in the clip
                //    if (_snapper)
                //        _snapper.setClip(_clip);
                //}

                // Only snap the geometries which belong to the same viewport as the first selection
                if (_viewer.model.is2d()) {
                    // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
                    viewer.impl.updateViewportId(_firstViewportIndex);

                    if (_snapper)
                        _snapper.setFirstClickVpId(_firstViewportIndex);
                }

                _firstClick = _snapper.getGeometry();

                if (_firstClickGeometry === SNAP_VERTEX) {

                    _indicator.showFirstVertex(_firstClick);
                }
                else if (_firstClickGeometry === SNAP_EDGE || _firstClickGeometry === SNAP_CURVEDEDGE) {

                    _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_FACE) {

                    _firstFaceNormal = _snapper.getFaceNormal();
                    _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC) {

                    // TODO: need to get rid of _firstCircularArcCenter, use _firstClick.center instead.
                    _firstCircularArcCenter = _snapper.getCircularArcCenter();
                    _firstClick.center = _snapper.getCircularArcCenter();
                    _firstClick.radius = _snapper.getCircularArcRadius();
                    _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE) {

                    _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
                }

                _firstClickNode = _snapper.getSnapNode();
                if (_measurePanel) _measurePanel.showSelection1();

            } else if (_activePoint === 2) { // Second Pick

                var result = null; // result = [endPoint, endPoint] or result = angle

                _secondClickGeometry = _snapper.getHighlightGeometry();
                _secondIntersectPoint = _snapper.getIntersectPoint();

                _secondClick = _snapper.getGeometry();

                if (_secondClickGeometry === SNAP_CIRCULARARC) {
                    _secondClick.center = _snapper.getCircularArcCenter();
                    _secondClick.radius = _snapper.getCircularArcRadius();
                }

                // Do not measure between identical geometries since the measurement is always 0.
                if (this.isIdenticalGeometries()) {
                    return false;
                }

                if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_VERTEX) { // do vertex to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    _indicator.drawLine(_firstClick, _secondClick);

                    result = [_firstClick, _secondClick];

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_EDGE) { // do edge to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToEdgeMeasure(_secondClick, _firstClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_FACE) { // do face to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToFaceMeasure(_firstIntersectPoint, _firstFaceNormal, _secondIntersectPoint, _secondFaceNormal);

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_EDGE) { // do vertex to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToEdgeMeasure(_firstClick, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_VERTEX) { // do edge to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.edgeToPointMeasure(_firstClick, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_FACE) { // do vertex to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToFaceMeasure(_firstClick, _secondClick, _secondFaceNormal, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_VERTEX) { // do face to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_FACE) { // do edge to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToFaceMeasure(_firstClick, _firstIntersectPoint, _secondClick, _secondFaceNormal, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_EDGE) { // do face to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToEdgeMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_CIRCULARARC) { // do circular arc to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();

                    // When circular arcs have same center, measure the radius of arc instead of the distance of two centers
                    if (_firstCircularArcCenter.equals(_secondCircularArcCenter)) {
                        _secondClick = _indicator.nearestVertexInVertexToEdge(_secondIntersectPoint, _secondClick);
                        _secondClickGeometry = SNAP_VERTEX;

                        _indicator.showSecondVertex(_secondClick);

                        _indicator.drawLine(_firstCircularArcCenter, _secondClick);

                        result = [_firstCircularArcCenter, _secondClick];
                    }
                    else {
                        _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);
                        _indicator.drawLine(_firstCircularArcCenter, _secondCircularArcCenter);

                        result = [_firstCircularArcCenter, _secondCircularArcCenter];
                    }
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_VERTEX) { // do circular arc to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    _indicator.drawLine(_firstCircularArcCenter, _secondClick);

                    result = [_firstCircularArcCenter, _secondClick];

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_CIRCULARARC) { // do vertex to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    _indicator.drawLine(_firstClick, _secondCircularArcCenter);

                    result = [_firstClick, _secondCircularArcCenter];
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_EDGE) { // do circular arc to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToEdgeMeasure(_firstCircularArcCenter, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_CIRCULARARC) { // do edge to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToPointMeasure(_firstClick, _secondCircularArcCenter);

                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_FACE) { // do circular arc to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToFaceMeasure(_firstCircularArcCenter, _secondClick, _secondFaceNormal, _secondIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_CIRCULARARC) { // do face to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondCircularArcCenter);
                }
                // Below is for curved edge and curved face measure
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_VERTEX) { // do curved edge to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.curvedEdgeToVertexMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_CURVEDEDGE) { // do vertex to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToVertexMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_CIRCULARARC) { // do curved edge to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToVertexMeasure(_firstClick, _secondCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_CURVEDEDGE) { // do circular arc to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToVertexMeasure(_secondClick, _firstCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_EDGE) { // do curved edge to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToEdgeMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_CURVEDEDGE) { // do edge to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToEdgeMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_CURVEDEDGE) { // do curved edge to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToCurvedEdgeMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && (_secondClickGeometry === SNAP_FACE || _secondClickGeometry === SNAP_CURVEDFACE)) { // do curved edge to face/curvedFace measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_firstClick, _secondClick);
                }
                else if ((_firstClickGeometry === SNAP_FACE || _firstClickGeometry === SNAP_CURVEDFACE) && _secondClickGeometry === SNAP_CURVEDEDGE) { // do face/curvedFace to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && _secondClickGeometry === SNAP_VERTEX) { // do curved face to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.curvedFaceToVertexMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_CURVEDFACE) { // do vertex to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToVertexMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && _secondClickGeometry === SNAP_CIRCULARARC) { // do curved face to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToVertexMeasure(_firstClick, _secondCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_CURVEDFACE) { // do circular arc to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToVertexMeasure(_secondClick, _firstCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && _secondClickGeometry === SNAP_EDGE) { // do curved face to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_CURVEDFACE) { // do edge to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && (_secondClickGeometry === SNAP_FACE || _secondClickGeometry === SNAP_CURVEDFACE)) { // do curved face to face/curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToFaceMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_CURVEDFACE) { // do face to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToFaceMeasure(_firstClick, _secondClick);
                }

                if (_consumeSingleClick) {

                    if (result.length === undefined) {

                        _angle = result;

                        if (_measurePanel) _measurePanel.showAngleResult();
                    }
                    else {

                        var ep1 = result[0].clone();
                        var ep2 = result[1].clone();

                        if (_viewer.model.is2d()) {
                            _viewer.model.pageToModel(ep1, ep2, _firstViewportIndex);
                        }

                        _distances.xyz = ep1.distanceTo(ep2);
                        _distances.x = Math.abs(ep1.x - ep2.x);
                        _distances.y = Math.abs(ep1.y - ep2.y);
                        _distances.z = Math.abs(ep1.z - ep2.z);

                        if (_measurePanel) {
                            // Add hideXYZ option because parallel faces should only display distance, not XYZ per Fusion's request
                            if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_FACE)
                                _measurePanel.showDistanceResult(true);
                            else
                                _measurePanel.showDistanceResult();
                        }
                    }

                    if (_measurePanel) {
                        _measurePanel.showSelection2();
                        _measurePanel.updatePanel();
                    }
                    _indicator.updateDistance();
                    _indicator.updateAngle();

                    _secondClickNode = _snapper.getSnapNode();
                    _secondViewportIndex = _snapper.getViewportIndex();

                    if (_measurePanel && _measurePanel.isolateMeasure) {
                        this.isolateMeasurement();
                    }

                    // Clear the clip in snapper (enable snapper in greying out area) after the
                    // second selection, then user can select the objects in greying out area.
                    //if (_viewer.model.is2d() && _snapper)
                    //    _snapper.setClip();

                    if (_viewer.model.is2d()) {
                        viewer.impl.updateViewportId(0);

                        if (_snapper)
                            _snapper.setFirstClickVpId(null);
                    }
                }

                _indicator.updateLabelPositions();

            }
            return true;
        }
        else {  // show "rubber band" even when user is NOT over any 2nd pick geometry
            if (_activePoint === 2) {
                var cursorPosition = this.inverseProject(event.canvasX, event.canvasY);

                //if (_viewer.model.is2d() && !_viewer.model.pointInPolygon(cursorPosition.x, cursorPosition.y, _clip.contours, _clip.points))
                //    return false;

                if (_firstClickGeometry === SNAP_VERTEX) { // do vertex to vertex measure

                    _indicator.drawLine(_firstClick, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_EDGE) { // do edge to vertex measure

                    _indicator.edgeToPointMeasure(_firstClick, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_FACE) { // do face to vertex measure

                    _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC) { // do circular arc to vertex measure

                    _indicator.drawLine(_firstCircularArcCenter, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE) { // do curved edge to vertex measure

                    _indicator.curvedEdgeToVertexMeasure(_firstClick, cursorPosition);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE) { // do curved face to vertex measure

                    _indicator.curvedFaceToVertexMeasure(_firstClick, cursorPosition);
                }
            }
        }
        return false;
    };

    this.inverseProject = function (canvasX, canvasY) {

        var camera = _viewer.navigation.getCamera(),
            containerBounds = _viewer.navigation.getScreenViewport(),
            p = new THREE.Vector3();

        p.x = canvasX / containerBounds.width * 2 - 1;
        p.y = -(canvasY / containerBounds.height * 2 - 1);
        p.z = 0;

        p = p.unproject(camera);

        return p;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        if (button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {

            _consumeSingleClick = true;
        }
        return false;
    };

    this.handleMouseMove = function (event) {
        _consumeSingleClick = false;
        if(_activePoint === 2) {
            this.clearRubberBand();
            this._handleMouseEvent(event);
        }
        return false;
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        return false;
    };

    this.handleSingleClick = function (event, button) {
        if (_consumeSingleClick) {

            if (!this._handleMouseEvent(event)) {
                this.clearMeasurement();
                _activePoint = 0;
            }

            if (_activePoint === 1 || _activePoint === 2) {
                _activePoint = (_activePoint === 1) ? 2 : 0;
            }

            _consumeSingleClick = false;
        }
        return true;
    };

    this.handleDoubleClick = function( event, button ) {
        return true;
    };

    this.handleWheelInput = function (delta) {
        _indicator.updateScale();
        return false;
    };

    this.handleSingleTap = function (event) {
        return true;
    };

    this.handleDoubleTap = function(event) {
        return true;
    };

    this.handleResize = function() {
        if (_indicator) {
            _indicator.updateLabelPositions();
        }
    };

    // Create UI and initially hide it.
    function activateUI( )
    {
        if (!_indicator) {
            _indicator = new Indicator( _viewer );
        }
        _indicator.hide();

        if (_measurePanel) {
            _measurePanel.setVisible(true);
            _measurePanel.updatePanel();

            if (_viewer.model && _viewer.model.is2d()) {
                _measurePanel.isolate.setVisibility(false);
            }

            if (!_units) {
                _measurePanel.disableUnitOption();
            }
            else {
                _measurePanel.disableUnitOption(0);  // disable "Unknown" option when the model has units
            }
        }
    }

    function deactivateUI()
    {
        if (_indicator) {
            _indicator.hide();
            _indicator.destroy();
        }

        _distances = {};

        if (_measurePanel) {
            _measurePanel.setVisible(false);
            _measurePanel.updatePanel();
        }
    }

    // /** @constructor */
    function Indicator( viewer )
    {
        var that = this,
            _simple = false,
            kIndicatorColor = 0x1E8FFF,
            kIndicatorOpacity = 0.7,
            kEndPointOverlayName = 'MeasureTool-endPoint',
            kEdgeOverlayName = 'MeasureTool-edge',
            kFaceOverlayName = 'MeasureTool-face',
            kAngleOverlayName = 'MeasureTool-angle',
            kAngleOutlineOverlayName = 'MeasureTool-angle-outline',
            kExtensionLineOverlayName = 'MeasureTool-extensionLine',
            kExtensionFaceOverlayName = 'MeasureTool-extensionFace',
            kGreyOutPlaneOverlayName = 'MeasureTool-greyOutPlane',
            _materialPoint = null,
            _materialLine = null,
            _materialFace = null,
            _materialAngle = null,
            _materialAngleOutline = null,
            _materialExtensionLine = null,
            _materialExtensionFace = null,
            _materialGreyOutPlane = null,
            _endPoints = {first: {}, second: {}},
            _edges = {first: {}, second: {}},
            _faces = {first: {}, second: {}},
            _lines = {
                xyz: {axis: false, color: 'FF9900'},
                x:   {axis: true,  color: 'F12C2C'},
                y:   {axis: true,  color: '0BB80B'},
                z:   {axis: true,  color: '2C2CF1'}
            },
            _angleLabel = {},
            _labels = [],
            kHudOffset = 4; // pixels

        this.showFirstVertex = function( position )
        {
            var scale = this.setScale(position);
            this.showEndPoint('first', position, scale);
        };

        this.showSecondVertex = function( position )
        {
            var scale = this.setScale(position);
            this.showEndPoint('second', position, scale);
        };

        this.showEndPoint = function (name, position, scale) {
            if (!_materialPoint) {
                _materialPoint = new THREE.MeshPhongMaterial({
                    color: kIndicatorColor,
                    ambient: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kEndPointOverlayName);
            }

            var endPoint = _endPoints[name],
                mesh = endPoint.mesh;

            if (!mesh) {
                endPoint.geometry = new THREE.SphereGeometry(1.0);
                mesh = endPoint.mesh = new THREE.Mesh(endPoint.geometry, _materialPoint);
                _viewer.impl.addOverlay(kEndPointOverlayName, mesh);
            }

            mesh.scale.x = scale;
            mesh.scale.y = scale;
            mesh.scale.z = scale;
            mesh.position.set(position.x, position.y, position.z);
            mesh.visible = true;

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);

            if (_consumeSingleClick || _redraw) {

                var label = endPoint.label;
                if (!label) {

                    label = endPoint.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    label.style.pointerEvents = 'none';

                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                label.classList.toggle('visible', true);

                endPoint.position = position.clone();

                this.updateLabelPositions();
            }
        };

        // Set scale for vertex and extension dashed line
        this.setScale = function (point) {

            var pixelSize = 5;

            var navapi = _viewer.navigation;
            var camera = navapi.getCamera();

            var view = navapi.getEyeVector();
            var position = navapi.getPosition();

            var p = point.clone();

            var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
                : navapi.getEyeVector().length();

            var fov = navapi.getVerticalFov();
            var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

            var viewport = navapi.getScreenViewport();
            var devicePixelRatio = window.devicePixelRatio || 1;
            var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

            return scale;
        };

        // Update scale for vertex, edge, line and extension dash line
        this.updateScale = function() {

            var overlay = _viewer.impl.overlayScenes[kEndPointOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var pointMesh = scene.children[i];
                    if (pointMesh) {

                        var scale = this.setScale(pointMesh.position);
                        pointMesh.scale.x = scale;
                        pointMesh.scale.y = scale;
                        pointMesh.scale.z = scale;
                    }
                }
            }

            overlay = _viewer.impl.overlayScenes[kExtensionLineOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var extensionLine = scene.children[i];
                    if (extensionLine) {

                        var dashScale = this.setScale(extensionLine.geometry.vertices[0]);
                        extensionLine.material.dashSize = dashScale * 4;
                        extensionLine.material.gapSize = dashScale * 2;
                    }
                }
            }

            overlay = _viewer.impl.overlayScenes[kEdgeOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var cylinderMesh = scene.children[i];
                    if (cylinderMesh) {
                        this.setCylinderScale(cylinderMesh);
                    }
                }
            }

            overlay = _viewer.impl.overlayScenes[kAngleOutlineOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var cylinderMesh = scene.children[i];
                    if (cylinderMesh) {
                        this.setCylinderScale(cylinderMesh);
                    }
                }
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        this.setCylinderScale(item.line);
                    }
                }
            }
        };

        this.showFirstEdge = function(geom, point)
        {
            this.showEdge('first', geom, point);
        };

        this.showSecondEdge = function(geom, point)
        {
            this.showEdge('second', geom, point);
        };

        this.showEdge = function(name, geom, point) {

            if (!_materialLine) {

                _materialLine = new THREE.MeshPhongMaterial({
                    color: kIndicatorColor,
                    ambient: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });

                _viewer.impl.createOverlayScene(kEdgeOverlayName);
            }

            var edge = _edges[name];

            if (edge.line) {
                _viewer.impl.removeMultipleOverlays(kEdgeOverlayName, edge.line);
            }

            edge.line = this.drawEdgeAsCylinder(geom, _materialLine, 5, 1);
            _viewer.impl.addMultipleOverlays(kEdgeOverlayName, edge.line);

            if (_consumeSingleClick || _redraw) {

                var label = edge.label;
                if (!label) {

                    label = edge.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    label.style.pointerEvents = 'none';

                    // Stop showing length of edges per Jay's request
                    //var label_text = document.createElement('div');
                    //label_text.className = 'measure-label-text';
                    //label.appendChild(label_text);
                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                //label.children[0].textContent = this.getEdgeLength(geom);
                label.classList.toggle('visible', true);

                edge.intersectPoint = point.clone();

                this.updateLabelPositions();
            }
        };

        // This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library
        this.drawEdgeAsCylinder = function(geom, material, linewidth, type) {

            // The array for all cylinders
            var edge = [];

            if (type == 1) { // LinePieces
                for (var i = 0; i < geom.vertices.length; i += 2) {
                    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, linewidth);
                    this.setCylinderScale(cylinder);
                    edge.push(cylinder);
                }
            }
            else { // LineStrip
                for (var i = 0; i < geom.vertices.length - 1; i++) {
                    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, linewidth);
                    this.setCylinderScale(cylinder);
                    edge.push(cylinder);
                }
            }


            return edge;
        };

        // This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library
        this.drawLineAsCylinder = function(geom, material, linewidth) {

            var line;

            if (geom.vertices.length == 2) {
                line = this.cylinderMesh(geom.vertices[0], geom.vertices[1], material, linewidth);
                this.setCylinderScale(line);
            }

            return line;
        };

        this.cylinderMesh = function(pointX, pointY, material, linewidth) {

            var direction = new THREE.Vector3().subVectors(pointY, pointX);
            var orientation = new THREE.Matrix4();
            orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
            orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
                0, 0, 1, 0,
                0, -1, 0, 0,
                0, 0, 0, 1));

            var edgeGeometry = new THREE.CylinderGeometry(0.1 * linewidth, 0.1 * linewidth, direction.length(), 8, 1, true);
            var edge = new THREE.Mesh(edgeGeometry, material);
            edge.applyMatrix(orientation);
            edge.position.x = (pointY.x + pointX.x) / 2;
            edge.position.y = (pointY.y + pointX.y) / 2;
            edge.position.z = (pointY.z + pointX.z) / 2;

            return edge;
        };

        // Set scale for cylinder
        this.setCylinderScale = function (cylinderMesh) {

            var scale = this.setScale(cylinderMesh.position);
            cylinderMesh.scale.x = scale;
            cylinderMesh.scale.z = scale;
        };

        this.showFirstFace = function(geom, point) {

            this.showFace('first', geom, point);
        };

        this.showSecondFace = function(geom, point) {

            this.showFace('second', geom, point);
        };

        this.showFace = function(name, geom, point) {

            if (!_materialFace) {
                _materialFace = new THREE.MeshPhongMaterial({
                        color: kIndicatorColor,
                        ambient: kIndicatorColor,
                        opacity: kIndicatorOpacity,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kFaceOverlayName);
            }

            var face = _faces[name];

            if (face.mesh) {
                _viewer.impl.removeOverlay(kFaceOverlayName, face.mesh);
            }

            face.mesh = new THREE.Mesh(geom, _materialFace);
            _viewer.impl.addOverlay(kFaceOverlayName, face.mesh);

            if (_consumeSingleClick || _redraw) {

                var label = face.label;
                if (!label) {

                    label = face.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    label.style.pointerEvents = 'none';

                    // Stop showing area of faces per Jay's request
                    //var label_text = document.createElement('div');
                    //label_text.className = 'measure-label-text';
                    //label.appendChild(label_text);
                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                //label.children[0].textContent = this.getFaceArea(geom);
                label.classList.toggle('visible', true);

                face.intersectPoint = point.clone();

                this.updateLabelPositions();
            }
        };

        this.drawExtensionFace = function(geom, intersectPoint, normal) {

            if (!_materialExtensionFace) {
                _materialExtensionFace = new THREE.MeshPhongMaterial({
                        color: 0x66CCFF,
                        ambient: 0x00CCFF,
                        opacity: 0.2,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kExtensionFaceOverlayName);
            }

            var face = new THREE.Mesh(geom, _materialExtensionFace);

            face.position.set(intersectPoint.x, intersectPoint.y, intersectPoint.z);
            var V = face.position.clone();
            V.add(normal);
            face.lookAt(V);
            face.updateMatrixWorld();

            _viewer.impl.addOverlay(kExtensionFaceOverlayName, face);
        };

        this.drawGreyOutPlane = function(vpId) {

            if (!_materialGreyOutPlane) {
                _materialGreyOutPlane = new THREE.MeshPhongMaterial({
                        color: 0x000000,
                        ambient: 0x000000,
                        opacity: 0.5,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kGreyOutPlaneOverlayName);
            }

            var pw = _viewer.model.getMetadata('page_dimensions', 'page_width');
            var ph = _viewer.model.getMetadata('page_dimensions', 'page_height');

            var paperShape = new THREE.Shape();
            paperShape.moveTo(0, 0);
            paperShape.lineTo(pw, 0);
            paperShape.lineTo(pw, ph);
            paperShape.lineTo(0, ph);
            paperShape.lineTo(0, 0);

            var clip = _clip = _viewer.model.getClip(vpId);

            // TODO: Need to handle multiple contours in clip, for now we only draw the first one.
            var cntr = clip.contours[0];
            var clipPath = new THREE.Path();
            clipPath.moveTo(clip.points[cntr[0]].x, clip.points[cntr[0]].y);
            for (var i = 1; i < cntr.length; i++) {
                clipPath.lineTo(clip.points[cntr[i]].x, clip.points[cntr[i]].y);
            }
            clipPath.lineTo(clip.points[cntr[0]].x, clip.points[cntr[0]].y);

            paperShape.holes.push(clipPath);

            var paperGeom = new THREE.ShapeGeometry(paperShape);
            var paperMesh = new THREE.Mesh(paperGeom, _materialGreyOutPlane);

            _viewer.impl.addOverlay(kGreyOutPlaneOverlayName, paperMesh);
        };

        this.getEdgeLength = function(edge) {

            var length = 0;
            var eg = edge.clone();
            var vertices = eg.vertices;
            for (var i = 0; i < vertices.length; i += 2) {

                if (_viewer.model.is2d()) {
                    _viewer.model.pageToModel(vertices[i], vertices[i + 1], _firstViewportIndex);
                }

                length += vertices[i].distanceTo(vertices[i + 1]);
            }

            length = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, length);

            return Autodesk.Viewing.Private.formatValueWithUnits(length, _units, 3, _precision);
        };

        this.getCircularArcRadius = function(edge) {

            var radius = edge.radius;

            if (radius) {
                if (_viewer.model.is2d()) {
                    var pt1 = edge.center.clone();
                    var pt2 = edge.vertices[0].clone();
                    _viewer.model.pageToModel(pt1, pt2, _firstViewportIndex);
                    radius = pt1.distanceTo(pt2);
                }

                radius = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, radius);
                return Autodesk.Viewing.Private.formatValueWithUnits(radius, _units, 3, _precision);
            }
        };

        this.getFaceArea = function(face) {

            var area = 0;
            var vertices = face.vertices;
            var V1 = new THREE.Vector3();
            var V2 = new THREE.Vector3();

            for (var i = 0; i < vertices.length; i += 3) {

                V1.subVectors(vertices[i + 1], vertices[i]);
                V2.subVectors(vertices[i + 2], vertices[i]);

                area += V1.length() * V2.length() * Math.sin(V1.angleTo(V2)) / 2;
            }

            area = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, area, 'square');

            if (_units) {

                return Autodesk.Viewing.Private.formatValueWithUnits(area, _units+'^2', 3, _precision);
            }
            else {

                return Autodesk.Viewing.Private.formatValueWithUnits(area, null, 3, _precision);
            }

        };

        this.updateLabels = function() {

            if (_firstClickGeometry === SNAP_EDGE) { // edge

                _edges['first'].label.children[0].textContent = this.getEdgeLength(_firstClick);
            }
            else if (_firstClickGeometry === SNAP_FACE) { // face

                _faces['first'].label.children[0].textContent = this.getFaceArea(_firstClick);
            }

            if (_secondClickGeometry === SNAP_EDGE) { // edge

                _edges['second'].label.children[0].textContent = this.getEdgeLength(_secondClick);
            }
            else if (_secondClickGeometry === SNAP_FACE) { // face

                _faces['second'].label.children[0].textContent = this.getFaceArea(_secondClick);
            }

        };

        this.updateLabelPositions = function () {
            function project(x, y, z) {
                var camera = _viewer.navigation.getCamera(),
                    containerBounds = _viewer.navigation.getScreenViewport(),
                    p = new THREE.Vector3(x, y, z);

                p = p.project(camera);

                return {
                    x: Math.round(( p.x + 1) / 2 * containerBounds.width) + 5,    // Add 5px to make the label not to be on the object
                    y: Math.round((-p.y + 1) / 2 * containerBounds.height) + 5    // Add 5px to make the label not to be on the object
                };
            }

            function placeLabelXYZ(item) {
                var p1 = item.p1,
                    p2 = item.p2,
                    p1xy = project(p1.x, p1.y, p1.z),
                    p2xy = project(p2.x, p2.y, p2.z),
                    dx = p2xy.x - p1xy.x,
                    dy = p2xy.y - p1xy.y,
                    xy = project(p2.x, p2.y, p2.z),
                    x = xy.x,
                    y = xy.y,
                    labelRect = item.label.getBoundingClientRect();

                if (0 < dy) {
                    y += kHudOffset;
                } else {
                    y -= (labelRect.height + kHudOffset);
                }
                if ((dx < 0) || (0 < dy)) {
                    x -= (labelRect.width + kHudOffset);
                } else {
                    x += kHudOffset;
                }

                return {x: x, y: y};
            }

            function placeLabelAxis(item, itemXYZ) {
                var p1 = item.p1,
                    p2 = item.p2,
                    mx = p1.x + (p2.x - p1.x) / 2,
                    my = p1.y + (p2.y - p1.y) / 2,
                    mz = p1.z + (p2.z - p1.z) / 2,
                    xy = project(mx, my, mz),
                    x = xy.x,
                    y = xy.y,
                    p1xyz = itemXYZ.p1,
                    p2xyz = itemXYZ.p2,
                    p1xy = project(p1xyz.x, p1xyz.y, p1xyz.z),
                    p2xy = project(p2xyz.x, p2xyz.y, p2xyz.z),
                    cx = (x + p1xy.x + p2xy.x) / 3,
                    cy = (y + p1xy.y + p2xy.y) / 3,
                    dx = x - cx,
                    dy = y - cy,
                    labelRect = item.label.getBoundingClientRect(),
                    halfLabelWidth = labelRect.width / 2,
                    halfLabelHeight = labelRect.height / 2;

                x -= halfLabelWidth;
                y -= halfLabelHeight;

                if (0 < dx) {
                    x += halfLabelWidth;
                } else {
                    x -= halfLabelWidth;
                }

                if (0 < dy) {
                    y += halfLabelHeight;
                } else {
                    y -= halfLabelHeight;
                }

                return {x: x, y: y};
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name],
                        label = item.label;

                    if (label) {
                        var xy = project((item.p1.x + item.p2.x)/2, (item.p1.y + item.p2.y)/2, (item.p1.z + item.p2.z)/2); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            if (_angleLabel) {

                label = _angleLabel.label;

                if (label) {
                    var xy = project((_angleLabel.p1.x + _angleLabel.p2.x)/2, (_angleLabel.p1.y + _angleLabel.p2.y)/2, (_angleLabel.p1.z + _angleLabel.p2.z)/2); // TODO: avoid collisions for labels
                    label.style.top = xy.y + 'px';
                    label.style.left = xy.x + 'px';
                    _labels.push(label);
                }
            }

            for (var name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name],
                        label = face.label,
                        point = face.intersectPoint;

                    if (label && point) {
                        var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            for (var name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name],
                        label = edge.label,
                        point = edge.intersectPoint;

                    if (label && point) {
                        var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            for (var name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name],
                        label = endPoint.label,
                        point = endPoint.position;

                    if (label && point) {
                        var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            for (var i = 0; i < _labels.length; i++) {
                for (var j = 0; j < i; j++) {
                    this.labelsOverlapDetection(_labels[j], _labels[i]);
                }
            }
            _labels = [];
        };

        this.labelsOverlapDetection = function(label1, label2) {

            var rect1 = label1.getBoundingClientRect();
            var rect2 = label2.getBoundingClientRect();

            //if ((rect2.top <= rect1.bottom && rect2.top >= rect1.top) || (rect2.bottom <= rect1.bottom && rect2.bottom >= rect1.top)) {
            if (rect2.top <= rect1.bottom && rect2.bottom >= rect1.top) {
                if (rect2.right >= rect1.left && rect2.right <= rect1.right) {
                    label2.style.left = parseInt(label2.style.left, 10) - (rect2.right - rect1.left) + 'px';
                }
                else if (rect2.left >= rect1.left && rect2.left <= rect1.right) {
                    label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
                }
                else if (rect2.left <= rect1.left && rect2.right >= rect1.right) {
                    label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
                }
            }
        };

        // Draw distance measurement
        this.drawLine = function( p1, p2, /*optional*/ hideXYZ )
        {
            function updateLine(name, x1, y1, z1, x2, y2, z2, showAxis) {
                var item = _lines[name],
                    line = item.line,
                    label = item.label,
                    p1 = new THREE.Vector3(x1, y1, z1),
                    p2 = new THREE.Vector3(x2, y2, z2);

                if (line) {
                    _viewer.impl.removeOverlay('MeasureTool-' + name, line);
                    item.line = null;
                }
                if (label) {
                    label.classList.remove('visible');
                }

                if (p1.distanceTo(p2) >= Math.pow(0.1, _precision) && showAxis) {

                    var show = (name === 'xyz' || (!_simple && _consumeSingleClick));

                    if (!line) {
                        item.material = new THREE.MeshBasicMaterial({
                            color: parseInt(item.color, 16),
                            depthTest: false,
                            depthWrite: false
                        });
                        item.overlayName = 'MeasureTool-' + name;
                        _viewer.impl.createOverlayScene(item.overlayName);

                    }

                    // make the rubber band 50% transparent.
                    if (_consumeSingleClick) {
                        item.material.opacity = 1;
                    }
                    else {
                        item.material.opacity = kIndicatorOpacity;
                    }

                    _viewer.impl.clearOverlay(item.overlayName);

                    var geometry = item.geometry = new THREE.Geometry();
                    geometry.vertices.push(p1);
                    geometry.vertices.push(p2);

                    var linewidth = (name === 'xyz' ? 5 : (name === 'z' ? 1 : 2));
                    line = item.line = that.drawLineAsCylinder(geometry, item.material, linewidth);
                    _viewer.impl.addOverlay(item.overlayName, line);

                    line.visible = show;

                    item.p1 = p1;
                    item.p2 = p2;

                    if (name != 'xyz' || _consumeSingleClick) {

                        if (!label) {
                            label = item.label = document.createElement('div');
                            label.className = 'measure-length';

                            if (name === 'xyz') {
                                var text = document.createElement('div');
                                text.className = 'measure-length-text';
                                label.appendChild(text);

                                // This button is for Markup and Comments
                                //var button = document.createElement('div');
                                //button.className = 'measure-length-button';
                                //button.style.cursor = 'pointer';
                                //button.addEventListener('click', function (event) {
                                //
                                //}, true);
                                //label.appendChild(button);

                            }

                            label.style.pointerEvents = 'none';

                            if (item.axis) {
                                //label.style.color = '#' + item.color;
                                //label.style.backgroundColor = 'transparent';
                                //label.textContent = name.toUpperCase();
                                label.className = 'adsk-icon-axis-' + name + ' measure-label-axis measure-label-axis-' + name;
                            }

                            _viewer.container.appendChild(label);
                        }

                        if (!item.axis) {
                            that.updateDistance();
                        }
                        label.classList.toggle('visible', show);
                    }
                }
            }

            // If the line aligns with one of axis, then don't show axis
            function displayAxis(p1, p2) {
                var prec = Math.pow(0.1, _precision);

                if ((Math.abs(p1.x - p2.x) >= prec && Math.abs(p1.y - p2.y) < prec && Math.abs(p1.z - p2.z) < prec)
                    || (Math.abs(p1.y - p2.y) >= prec && Math.abs(p1.x - p2.x) < prec && Math.abs(p1.z - p2.z) < prec)
                    || (Math.abs(p1.z - p2.z) >= prec && Math.abs(p1.x - p2.x) < prec && Math.abs(p1.y - p2.y) < prec)) {
                    return false;
                }

                return true;
            }

            updateLine('xyz', p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, true);

            var up = _viewer.navigation.getAlignedUpVector(),
                x = Math.abs(up.x),
                y = Math.abs(up.y),
                z = Math.abs(up.z);

            var showAxis = hideXYZ ? false : displayAxis(p1, p2);

            if (z > x && z > y) { // z up
                updateLine('x', p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);
                updateLine('y', p2.x, p1.y, p1.z, p2.x, p2.y, p1.z, showAxis);
                updateLine('z', p2.x, p2.y, p1.z, p2.x, p2.y, p2.z, showAxis);

            } else if (y > x && y > z) { // y up
                updateLine('x', p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);
                updateLine('z', p2.x, p1.y, p1.z, p2.x, p1.y, p2.z, showAxis);
                updateLine('y', p2.x, p1.y, p2.z, p2.x, p2.y, p2.z, showAxis);

            } else { // x up - do we ever see this?
                updateLine('y', p1.x, p1.y, p1.z, p1.x, p2.y, p1.z, showAxis);
                updateLine('z', p1.x, p2.y, p1.z, p1.x, p2.y, p2.z, showAxis);
                updateLine('x', p1.x, p2.y, p2.z, p2.x, p2.y, p2.z, showAxis);
            }

            this.updateLabelPositions();
        };

        // Update distance measurement label
        this.updateDistance = function () {
            var label = _lines.xyz.label;
            if (label) {
                label.children[0].textContent = "~ " + tool.getDistance('xyz');
            }
        };

        // Update angle measurement label
        this.updateAngle = function() {
            var label = _angleLabel.label;
            if (label) {
                label.children[0].textContent = "~ " + tool.getAngle();
            }
        };

        this.drawExtensionLine = function(point, lineStart, lineEnd) {

            var p1, p2;
            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);


            if (param < 0) {
                p1 = lineStart;
                p2 = nearestPoint;
            }
            else if (param > 1) {
                p1 = lineEnd;
                p2 = nearestPoint;
            }
            else {
                return;
            }

            if (!_materialExtensionLine) {

                _materialExtensionLine = new THREE.LineDashedMaterial({
                    color: 0x0033FF,
                    linewidth: 1,
                    dashSize: 1,
                    gapSize: 0.5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kExtensionLineOverlayName);
            }

            // make the rubber band 50% transparent.
            if (_consumeSingleClick) {
                _materialExtensionLine.opacity = 1;
            }
            else {
                _materialExtensionLine.opacity = kIndicatorOpacity;
            }

            var dashScale = this.setScale(p1);
            _materialExtensionLine.dashSize = dashScale * 4;
            _materialExtensionLine.gapSize = dashScale * 2;

            var geometry = new THREE.Geometry();
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);

            geometry.computeLineDistances();

            var line = new THREE.Line(geometry, _materialExtensionLine);
            _viewer.impl.addOverlay(kExtensionLineOverlayName, line);
        };

        this.drawExtensionLinePointToPoint = function(lineStart, lineEnd) {

            var p1 = lineStart;
            var p2 = lineEnd;

            if (!_materialExtensionLine) {

                _materialExtensionLine = new THREE.LineDashedMaterial({
                    color: 0x0033FF,
                    linewidth: 1,
                    dashSize: 1,
                    gapSize: 0.5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kExtensionLineOverlayName);
            }

            // make the rubber band 50% transparent.
            if (_consumeSingleClick) {
                _materialExtensionLine.opacity = 1;
            }
            else {
                _materialExtensionLine.opacity = kIndicatorOpacity;
            }

            var dashScale = this.setScale(p1);
            _materialExtensionLine.dashSize = dashScale * 4;
            _materialExtensionLine.gapSize = dashScale * 2;

            var geometry = new THREE.Geometry();
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);

            geometry.computeLineDistances();

            var line = new THREE.Line(geometry, _materialExtensionLine);
            _viewer.impl.addOverlay(kExtensionLineOverlayName, line);
        };

        // Get the two nearest endpoints between two line segments
        this.nearestPointsInSegmentToSegment = function (p1, p2, p3, p4) {

            var smallNum = 0.001;
            var u = new THREE.Vector3();
            var v = new THREE.Vector3();
            var w = new THREE.Vector3();

            u.subVectors(p2, p1);
            v.subVectors(p4, p3);
            w.subVectors(p1, p3);

            var a = u.dot(u);
            var b = u.dot(v);
            var c = v.dot(v);
            var d = u.dot(w);
            var e = v.dot(w);
            var D = a * c - b * b;
            var sc, sN, sD = D;
            var tc, tN, tD = D;

            // Compute the line parameters of the two closest points
            if (D < smallNum) { // the lines are almost parallel
                sN = 0.0;  // for using point p1 on segment p1p2
                sD = 1.0;  // to prevent possible division by 0.0 later
                tN = e;
                tD = c;
            }
            else {  // get the closest points on the infinite lines
                sN = b * e - c * d;
                tN = a * e - b * d;
                if (sN < 0.0) {  // sc < 0 => the s = 0 is visible
                    sN = 0.0;
                    tN = e;
                    tD = c;
                }
                else if (sN > sD) {  // sc > 1 => the s = 1 edge is visible
                    sN = sD;
                    tN = e + b;
                    tD = c;
                }
            }

            if (tN < 0.0) {  // tc < 0 => the t = 0 edge is visible
                tN = 0.0;
                // recompute sc for this edge
                if (-d < 0.0)
                    sN = 0.0;
                else if (-d > a)
                    sN = sD;
                else {
                    sN = -d;
                    sD = a;
                }
            }
            else if (tN > tD) {  // tc > 1 => the t = 1 edge is visible
                tN = tD;
                // recompute sc for this edge
                if ((-d + b) < 0.0)
                    sN = 0;
                else if ((-d + b) > a)
                    sN = sD;
                else {
                    sN = -d + b;
                    sD = a;
                }
            }

            // finally do the division to get sc and tc
            sc = Math.abs(sN) < smallNum ? 0.0 : sN / sD;
            tc = Math.abs(tN) < smallNum ? 0.0 : tN / tD;

            // get the difference of the two closest points
            u.multiplyScalar(sc);
            v.multiplyScalar(tc);
            w.add(u);
            w.sub(v);

            //return w.length();

            u.add(p1);
            v.add(p3);
            return [u, v];
        };

        // Measure from Edge to Edge
        this.edgeToEdgeMeasure = function(edge1, edge2, intersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge1);
            var p1 = eps[0].clone();
            var p2 = eps[1].clone();
            eps = _snapper.getEndPointsInEdge(edge2);
            var p3 = eps[0].clone();
            var p4 = eps[1].clone();

            var va = this.nearestPointInPointToLine(p1, p3, p4);
            var vb = this.nearestPointInPointToLine(p2, p3, p4);

            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();

            v1.subVectors(p1, p2);
            v2.subVectors(p3, p4);
            v1.normalize();
            v2.normalize();

            // Draw distance line between parallel edges
            if (this.isEqualVectors(v1, v2, smallNum) || this.isInverseVectors(v1, v2, smallNum)) {

                // Measure the endpoint closest to the intersection point
                if (p1.distanceTo(intersectPoint) <= p2.distanceTo(intersectPoint)) {

                    this.drawLine(p1, va);
                    this.drawExtensionLine(p1, p3, p4);
                    return [p1, va];
                }
                else {

                    this.drawLine(p2, vb);
                    this.drawExtensionLine(p2, p3, p4);
                    return [p2, vb];
                }
            }
            else {  // Draw arc

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(intersectPoint, p1, p2);

                var angle = this.angleVectorToVector(v1, v2);

                // Find the nearest endpoints of the two edges
                // Draw arc between p1p2 and p3p4
                if (p1.distanceTo(p3) < p1.distanceTo(p4) && p1.distanceTo(p3) < p2.distanceTo(p3) && p1.distanceTo(p3) < p2.distanceTo(p4)) {

                    this.drawAngleLineToLine(p1, newEp, p3, p4, angle);
                }
                // Draw arc between p1p2 and p4p3
                else if (p1.distanceTo(p4) < p1.distanceTo(p3) && p1.distanceTo(p4) < p2.distanceTo(p3) && p1.distanceTo(p4) < p2.distanceTo(p4)) {

                    this.drawAngleLineToLine(p1, newEp, p4, p3, angle);
                }
                // Draw arc between p2p1 and p3p4
                else if (p2.distanceTo(p3) < p1.distanceTo(p3) && p2.distanceTo(p3) < p1.distanceTo(p4) && p2.distanceTo(p3) < p2.distanceTo(p4)) {

                    this.drawAngleLineToLine(p2, newEp, p3, p4, angle);
                }
                // Draw arc between p2p1 and p4p3
                else {  // if (p2.distanceTo(p4) < p1.distanceTo(p3) && p2.distanceTo(p4) < p1.distanceTo(p4) && p2.distanceTo(p4) < p2.distanceTo(p3)) {

                    this.drawAngleLineToLine(p2, newEp, p4, p3, angle);
                }

                return angle;
            }

        };

        // Measure between Curved Edge and Straight Edge
        this.curvedEdgeToEdgeMeasure = function (curvedEdge, edge) {

            var minDist = Number.MAX_VALUE;
            var nP1 = null;
            var nP2 = null;

            var vertices = curvedEdge.vertices;
            var eps = _snapper.getEndPointsInEdge(edge);

            for (var i = 0; i < vertices.length; i += 2) {
                var tempPs = this.nearestPointsInSegmentToSegment(vertices[i], vertices[i + 1], eps[0], eps[1]);
                var dist = tempPs[0].distanceTo(tempPs[1]);
                if (dist < minDist) {
                    minDist = dist;
                    nP1 = tempPs[0];
                    nP2 = tempPs[1];
                }
            }

            this.drawLine(nP1, nP2);

            return [nP1, nP2];
        };

        // Measure between Curved Edge and Curved Edge
        this.curvedEdgeToCurvedEdgeMeasure = function (edge1, edge2) {

            var minDist = Number.MAX_VALUE;
            var nP1 = null;
            var nP2 = null;

            var vertices1 = edge1.vertices;
            var vertices2 = edge2.vertices;

            for (var i = 0; i < vertices1.length; i += 2)
                for (var j = 0; j < vertices2.length; j += 2) {
                    var tempPs = this.nearestPointsInSegmentToSegment(vertices1[i], vertices1[i + 1], vertices2[j], vertices2[j + 1]);
                    var dist = tempPs[0].distanceTo(tempPs[1]);
                    if (dist < minDist) {
                        minDist = dist;
                        nP1 = tempPs[0];
                        nP2 = tempPs[1];
                    }
                }

            this.drawLine(nP1, nP2);

            return [nP1, nP2];
        };

        // Get the nearest point on the line segment from point to line segment
        this.nearestPointInPointToSegment = function (point, lineStart, lineEnd) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            if (param < 0) {
                nearestPoint = lineStart;
            }
            else if (param > 1) {
                nearestPoint = lineEnd;
            }
            else {
                X0.subVectors(lineEnd, lineStart);
                X0.multiplyScalar(param);
                nearestPoint = X0.add(lineStart);
            }

            return nearestPoint;
        };

        // Get the nearest point on the line from point to line
        this.nearestPointInPointToLine = function(point, lineStart, lineEnd) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);

            return nearestPoint;
        };

        // Measure from Point to Edge
        this.pointToEdgeMeasure = function(point, edge, intersectPoint) {

            var eps = _snapper.getEndPointsInEdge(edge);

            var lineStart = eps[0];
            var lineEnd = eps[1];

            var X0 = this.nearestPointInPointToLine(point, lineStart, lineEnd);
            var X1 = this.nearestPointInPointToLine(intersectPoint, lineStart, lineEnd);

            var p1 = new THREE.Vector3();
            p1.subVectors(X1, X0);
            p1.add(point);

            this.drawLine(p1, X1);

            this.drawExtensionLinePointToPoint(point, p1);

            return [point, X0];
        };

        // Measure from Edge to Point
        this.edgeToPointMeasure = function(edge, point) {

            var eps = _snapper.getEndPointsInEdge(edge);

            var lineStart = eps[0];
            var lineEnd = eps[1];

            var X0 = this.nearestPointInPointToLine(point, lineStart, lineEnd);

            this.drawLine(point, X0);

            this.drawExtensionLine(point, lineStart, lineEnd);

            return [point, X0];
        };

        // Measure between Curved Edge and Vertex
        this.curvedEdgeToVertexMeasure = function(edge, point) {

            var vertices = edge.vertices;
            var minDist = Number.MAX_VALUE;
            var nearestPoint = null;

            for (var i = 0; i < vertices.length; i += 2) {

                var nP = this.nearestPointInPointToSegment(point, vertices[i], vertices[i + 1]);
                var dist = point.distanceTo(nP);
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = nP;
                }
            }

            this.drawLine(point, nearestPoint);

            return [point, nearestPoint];
        };

        // Measure from Face to Face
        this.faceToFaceMeasure = function(p1, n1, p2, n2) {

            var smallNum = 0.01;
            var firstNormal = n1.clone();
            var secondNormal = n2.clone();

            var angle = this.angleVectorToVector(n1, n2);

            if (((firstNormal.x <= secondNormal.x + smallNum) && (firstNormal.x >= secondNormal.x - smallNum)
                && (firstNormal.y <= secondNormal.y + smallNum) && (firstNormal.y >= secondNormal.y - smallNum)
                && (firstNormal.z <= secondNormal.z + smallNum) && (firstNormal.z >= secondNormal.z - smallNum))
                || ((firstNormal.x <= -secondNormal.x + smallNum) && (firstNormal.x >= -secondNormal.x - smallNum)
                && (firstNormal.y <= -secondNormal.y + smallNum) && (firstNormal.y >= -secondNormal.y - smallNum)
                && (firstNormal.z <= -secondNormal.z + smallNum) && (firstNormal.z >= -secondNormal.z - smallNum)))
            {
                var X0 = new THREE.Vector3();
                X0.subVectors(p1, p2);
                var t = firstNormal.dot(X0) / firstNormal.dot(secondNormal);

                X0.addVectors(p2, secondNormal.multiplyScalar(t));

                //var dist = new THREE.Vector3();
                //dist.subVectors(X0, p1);
                //var extendFace = _faces['first'].mesh.geometry.clone();
                //extendFace.applyMatrix(new THREE.Matrix4().makeTranslation(dist.x, dist.y, dist.z));

                var dist = X0.distanceTo(p1) * 2;
                var extendFace = new THREE.PlaneBufferGeometry(dist, dist);
                this.drawExtensionFace(extendFace, p1, n1);
                //this.drawExtensionLinePointToPoint(p1, X0);

                this.drawLine(p2, X0, true);
                return [p2, X0, angle];
            }
            else {

                //this.drawLine(p1, p2);
                //return [p1, p2, angle];

                angle = this.drawAngleFaceToFace(p1, n1, p2, n2);
                return angle;
            }
        };

        this.angleVectorToVector = function(v1, v2) {

            var a = v1.angleTo(v2) * 180 / Math.PI;
            return a;
        };

        // Find the intersection of two nonparallel planes
        this.intersectPlaneToPlane = function(p1, n1, p2, n2) {

            var u = new THREE.Vector3();
            u.crossVectors(n1, n2);
            var ax = (u.x >= 0 ? u.x : -u.x);
            var ay = (u.y >= 0 ? u.y : -u.y);
            var az = (u.z >= 0 ? u.z : -u.z);

            var maxc;  // max coordinate
            if (ax > ay) {
                if (ax > az)
                    maxc = 1;
                else
                    maxc = 3;
            }
            else {
                if (ay > az)
                    maxc = 2;
                else maxc = 3;
            }

            var iP = new THREE.Vector3(); // intersect point
            var d1, d2;
            d1 = -n1.dot(p1);
            d2 = -n2.dot(p2);

            switch (maxc) {

                case 1:  // intersect with x = 0
                    iP.x = 0;
                    if (u.x !== 0) {
                        iP.y = (d2 * n1.z - d1 * n2.z) / u.x;
                        iP.z = (d1 * n2.y - d2 * n1.y) / u.x;
                    }
                    else {
                        iP.y = - (d2 * n1.z) / (n1.z * n2.y);
                        iP.z = - (d1 * n2.y) / (n1.z * n2.y);
                    }
                    break;
                case 2:
                    iP.y = 0;
                    if (u.y !== 0) {
                        iP.x = (d1 * n2.z - d2 * n1.z) / u.y;
                        iP.z = (d2 * n1.x - d1 * n2.x) / u.y;
                    }
                    else {
                        iP.x = - (d1 * n2.z) / (n1.x * n2.z);
                        iP.z = - (d2 * n1.x) / (n1.x * n2.z);
                    }
                    break;
                case 3:
                    iP.z = 0;
                    if (u.z !== 0) {
                        iP.x = (d2 * n1.y - d1 * n2.y) / u.z;
                        iP.y = (d1 * n2.x - d2 * n1.x) / u.z;
                    }
                    else {
                        iP.x = - (d2 * n1.y) / (n1.y * n2.x);
                        iP.y = - (d1 * n2.x) / (n1.y * n2.x);
                    }
                    break;
            }

            var iP2 = new THREE.Vector3();
            iP2.addVectors(iP, u.multiplyScalar(100));

            var vP1 = this.nearestPointInPointToLine(p1, iP, iP2);
            var vP2 = this.nearestPointInPointToLine(p2, iP, iP2);

            return [vP1, vP2];

        };

        this.drawAngle = function (p, ep1, ep2, n, angle, midPoint) {

            var smallNum = 0.001;

            if (!_materialAngle) {

                _materialAngle = new THREE.MeshPhongMaterial({
                        color: 0x999999,
                        ambient: 0x999999,
                        opacity: 0.5,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _materialAngleOutline = new THREE.MeshBasicMaterial({
                    color: 0xFF9900,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kAngleOverlayName, _materialAngle);
                _viewer.impl.createOverlayScene(kAngleOutlineOverlayName, _materialAngleOutline);
            }

            _viewer.impl.clearOverlay(kAngleOverlayName);
            _viewer.impl.clearOverlay(kAngleOutlineOverlayName);


            // draw arc of angle
            var radius = p.distanceTo(ep1);
            var segments = 100;
            //angle = angle * Math.PI / 180;

            var circleGeometry = new THREE.CircleGeometry(radius, segments, 0, angle * Math.PI / 180);
            var arc = new THREE.Mesh(circleGeometry, _materialAngle);

            var center = arc.geometry.vertices[0].clone();
            arc.geometry.vertices.push(center);


            // Translate and rotate the arc to the plane where it should lie in
            arc.position.set(p.x, p.y, p.z);
            var V = arc.position.clone();
            V.add(n);
            arc.lookAt(V);
            arc.updateMatrixWorld();


            // Rotate the arc in the plane to the right place
            var vA = arc.geometry.vertices[1].clone();
            var vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();
            vA.applyMatrix4(arc.matrixWorld);
            vB.applyMatrix4(arc.matrixWorld);

            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var v3 = new THREE.Vector3();
            var v4 = new THREE.Vector3();
            v1.subVectors(vA, p);
            v2.subVectors(vB, p);
            v3.subVectors(ep1, p);
            v4.subVectors(ep2, p);

            var a13 = v1.angleTo(v3);
            var a14 = v1.angleTo(v4);
            var a23 = v2.angleTo(v3);
            var a24 = v2.angleTo(v4);

            //console.log(a13 * 180 / Math.PI + " " + a14 * 180 / Math.PI + " " + a23 * 180 / Math.PI + " " + a24 * 180 / Math.PI);

            var ra;
            // The arc is in the right place
            if (((a13 <= smallNum && a13 >= -smallNum) || (a14 <= smallNum && a14 >= -smallNum))
                && ((a23 <= smallNum && a23 >= -smallNum) || (a24 <= smallNum && a24 >= -smallNum))) {

                ra =0;
            }
            // The arc needs to be rotated 180 degree to the right place
            else if (((a13 <= Math.PI + smallNum && a13 >= Math.PI - smallNum) || (a14 <= Math.PI + smallNum && a14 >= Math.PI - smallNum))
                && ((a23 <= Math.PI + smallNum && a23 >= Math.PI - smallNum) || (a24 <= Math.PI + smallNum && a24 >= Math.PI - smallNum))) {

                ra = Math.PI;
            }
            // The arc needs to be rotated a13 radian
            else if ((a13 <= a23 + smallNum && a13 >= a23 - smallNum) || (a13 <= a24 + smallNum && a13 >= a24 - smallNum)) {

                ra = a13;
            }
            // The arc needs to be rotated a14 radian
            else {

                ra = a14;
            }

            var rotWorldMatrix = new THREE.Matrix4();
            rotWorldMatrix.makeRotationAxis(n, ra);
            //arc.matrix.multiply(rotWorldMatrix);
            rotWorldMatrix.multiply(arc.matrix);
            arc.matrix = rotWorldMatrix;
            arc.rotation.setFromRotationMatrix(arc.matrix);

            // Check if rotate to the wrong direction, if so, rotate back twice of the degree
            arc.updateMatrixWorld();
            vA = arc.geometry.vertices[1].clone();
            vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();
            vA.applyMatrix4(arc.matrixWorld);
            vB.applyMatrix4(arc.matrixWorld);

            v1.subVectors(vA, p);
            v2.subVectors(vB, p);

            a13 = v1.angleTo(v3);
            a14 = v1.angleTo(v4);
            a23 = v2.angleTo(v3);
            a24 = v2.angleTo(v4);

            //console.log(a13 * 180 / Math.PI + " " + a14 * 180 / Math.PI + " " + a23 * 180 / Math.PI + " " + a24 * 180 / Math.PI);

            if (a13 >= smallNum && a14 >= smallNum) {

                var rotWorldMatrix = new THREE.Matrix4();
                rotWorldMatrix.makeRotationAxis(n, - ra * 2);
                //arc.matrix.multiply(rotWorldMatrix);
                rotWorldMatrix.multiply(arc.matrix);
                arc.matrix = rotWorldMatrix;
                arc.rotation.setFromRotationMatrix(arc.matrix);
            }

            // draw outline of the arc
            var outlineGeometry = new THREE.CircleGeometry(radius * 0.9, segments, 0, angle * Math.PI / 180);
            outlineGeometry.vertices.splice(0, 1);
            arc.updateMatrixWorld();
            outlineGeometry.applyMatrix(arc.matrixWorld);
            var outline = this.drawEdgeAsCylinder(outlineGeometry, _materialAngleOutline, 2.5, 0);


            // draw lines of angle
            var geom1 = new THREE.Geometry();
            var geom2 = new THREE.Geometry();
            geom1.vertices.push(arc.geometry.vertices[0].clone(), arc.geometry.vertices[1].clone());
            geom2.vertices.push(arc.geometry.vertices[0].clone(), arc.geometry.vertices[arc.geometry.vertices.length - 2].clone());
            geom1.applyMatrix(arc.matrixWorld);
            geom2.applyMatrix(arc.matrixWorld);
            var line1 = this.drawLineAsCylinder(geom1, _materialAngleOutline, 2.5);
            var line2 = this.drawLineAsCylinder(geom2, _materialAngleOutline, 2.5);


            _viewer.impl.addOverlay(kAngleOverlayName, arc);
            _viewer.impl.addMultipleOverlays(kAngleOutlineOverlayName, outline);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, line1);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, line2);

            // This is used for angle label's position
            midPoint.copy(arc.geometry.vertices[Math.round(arc.geometry.vertices.length / 2) - 1]);
            midPoint.applyMatrix4(arc.matrixWorld);
        };

        // Draw angle between face to face
        this.drawAngleFaceToFace = function (p1, n1, p2, n2) {

            var vPs = this.intersectPlaneToPlane(p1, n1, p2, n2);

            var X1 = new THREE.Vector3();
            var X2 = new THREE.Vector3();
            X1.subVectors(p1, vPs[0]);
            X2.subVectors(p2, vPs[1]);

            var angle = this.angleVectorToVector(X1, X2);

            var p = vPs[0].clone();
            var n = new THREE.Vector3();
            n.crossVectors(n1, n2);
            n.normalize();

            vPs = this.intersectPlaneToPlane(p1, n1, p, n);
            var ep1 = vPs[0].clone();
            vPs = this.intersectPlaneToPlane(p2, n2, p, n);
            var ep2 = vPs[0].clone();

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_consumeSingleClick) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    label.style.pointerEvents = 'none';

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }

            return angle;
        };

        // Draw angle between line to line
        this.drawAngleLineToLine = function (p1, p2, p3, p4, angle) {

            var p = p1;
            var n = new THREE.Vector3();
            var n1 = new THREE.Vector3();
            var n2 = new THREE.Vector3();
            n1.subVectors(p1, p2);
            n2.subVectors(p3, p4);
            n.crossVectors(n1, n2);
            n.normalize();


            var ep1 = p2;
            var ep2 = new THREE.Vector3();
            ep2.subVectors(p, p3);
            ep2.add(p4);

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_consumeSingleClick) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    label.style.pointerEvents = 'none';

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }
        };

        // Find the intersection point of two nonparallel lines
        this.intersectLineToLine = function(p1, v1, p2, v2) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();

            X0.subVectors(p2, p1);
            X0.cross(v2);
            X1.crossVectors(v1, v2);

            var scalar = X0.divide(X1);

            X1 = v1.clone();
            X1.multiplyScalar(scalar);
            X0.addVectors(p1, X1);

            return X0;
        };

        // Find the nearest point from point to plane
        this.nearestPointInPointToPlane = function(p1, p2, n) {

            var nearestPoint = new THREE.Vector3();
            var norm = n.clone();
            var X0 = new THREE.Vector3();
            X0.subVectors(p1, p2);

            var sn = -norm.dot(X0);
            var sd = norm.dot(norm);
            var sb = sn / sd;

            nearestPoint.addVectors(p1, norm.multiplyScalar(sb));
            return nearestPoint;
        };

        // Measure from face to vertex
        this.faceToPointMeasure = function(face, normal, intersectPoint, point) {

            var p = face.vertices[0];

            var X0 = this.nearestPointInPointToPlane(point, p, normal);

            var p1 = intersectPoint.clone();
            var p2 = new THREE.Vector3();
            p2.subVectors(p1, X0);
            p2.add(point);

            //var dist = new THREE.Vector3();
            //dist.subVectors(X0, p1);
            //var extendFace = face.clone();
            //extendFace.applyMatrix(new THREE.Matrix4().makeTranslation(dist.x, dist.y, dist.z));

            var dist = X0.distanceTo(intersectPoint) * 2;
            var extendFace = new THREE.PlaneBufferGeometry(dist, dist);
            this.drawExtensionFace(extendFace, intersectPoint, normal);

            this.drawLine(point, X0);
            //this.drawExtensionLinePointToPoint(p1, X0);
            return [point, X0];
        };

        // Find the nearest point from point to triangle
        this.nearestPointInPointToTriangle = function(point, a, b, c) {

            var nearestPoint;
            var minDist = Number.MAX_VALUE;

            nearestPoint = this.pointProjectsInTriangle(point, a, b, c);
            if (nearestPoint) {
               return nearestPoint;
            }

            var p = this.nearestPointInPointToSegment(point, a, b);
            if (point.distanceTo(p) < minDist) {
                minDist = point.distanceTo(p);
                nearestPoint = p.clone();
            }

            p = this.nearestPointInPointToSegment(point, a, c);
            if (point.distanceTo(p) < minDist) {
                minDist = point.distanceTo(p);
                nearestPoint = p.clone();
            }

            p = this.nearestPointInPointToSegment(point, b, c);
            if (point.distanceTo(p) < minDist) {

                nearestPoint = p.clone();
            }

            return nearestPoint;
        };

        // Measure from point to face
        this.pointToFaceMeasure = function(point, face, normal, intersectPoint) {

            var p = face.vertices[0];

            var X0 = this.nearestPointInPointToPlane(point, p, normal);

            var p1 = intersectPoint.clone();
            var p2 = new THREE.Vector3();
            p2.subVectors(p1, X0);
            p2.add(point);

            this.drawLine(p1, p2);
            this.drawExtensionLinePointToPoint(point, p2);
            return [point, X0];

        };

        // Measure between Curved Face and Vertex
        this.curvedFaceToVertexMeasure = function(face, point) {

            var minDist = Number.MAX_VALUE;
            var nearestPoint;
            var vertices = face.vertices;

            for (var i = 0; i < vertices.length; i += 3) {
                var tempP = this.nearestPointInPointToTriangle(point, vertices[i], vertices[i + 1], vertices[i + 2]);
                if (point.distanceTo(tempP) < minDist) {
                    minDist = point.distanceTo(tempP);
                    nearestPoint = tempP;
                }
            }

            this.drawLine(nearestPoint, point);

            return [nearestPoint, point];
        };

        this.pointProjectsInTriangle = function(point, a, b, c) {

            var u = new THREE.Vector3();
            var v = new THREE.Vector3();
            var w = new THREE.Vector3();
            var n = new THREE.Vector3();

            u.subVectors(b, a);
            v.subVectors(c, a);
            n.crossVectors(u, v);
            w.subVectors(point, a);

            u.cross(w);
            var r = u.dot(n) / n.dot(n);
            w.cross(v);
            var b = w.dot(n) / n.dot(n);
            var a = 1 - r - b;

            if (a >= 0 && a <= 1 && b >= 0 && b <= 1 && r >= 0 && r <= 1) {

                var normal = THREE.Triangle.normal(a, b, c);
                var nearestPoint = this.nearestPointInPointToPlane(point, a, normal);

                return nearestPoint;
            }
        };

        this.nearestPointsInLineSegmentToTriangle = function(p1, p2, a, b, c) {

            // The closest pair of points between a line segment and a triangle can always be found either
            // (a) between an endpoint of the segment an the triangle interior or
            // (b) between the segment and an edge of the triangle.

            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            var p3, p4;

            var pp1 = this.pointProjectsInTriangle(p1, a, b, c);
            if (pp1 && p1.distanceTo(pp1) < minDist) {
                minDist = p1.distanceTo(pp1);
                nearestPoints[0] = p1;
                nearestPoints[1] = pp1;
            }

            var pp2 = this.pointProjectsInTriangle(p2, a, b, c);
            if (pp2 && p2.distanceTo(pp2) < minDist) {
                minDist = p2.distanceTo(pp2);
                nearestPoints[0] = p2;
                nearestPoints[1] = pp2;
            }

            p3 = a;
            p4 = b;
            var p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
            if (p[0].distanceTo(p[1]) < minDist) {
                minDist = p[0].distanceTo(p[1]);
                nearestPoints[0] = p[0].clone();
                nearestPoints[1] = p[1].clone();
            }

            p3 = a;
            p4 = c;
            p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
            if (p[0].distanceTo(p[1]) < minDist) {
                minDist = p[0].distanceTo(p[1]);
                nearestPoints[0] = p[0].clone();
                nearestPoints[1] = p[1].clone();
            }

            p3 = b;
            p4 = c;
            p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
            if (p[0].distanceTo(p[1]) < minDist) {

                nearestPoints[0] = p[0].clone();
                nearestPoints[1] = p[1].clone();
            }

            return nearestPoints;
        };

        // Find the two nearest points between edge and face
        this.nearestPointsInEdgeToFace = function(p1, p2, face) {

            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            for (var i = 0; i < face.vertices.length; i += 3) {

                var tempPs = this.nearestPointsInLineSegmentToTriangle(p1, p2, face.vertices[i], face.vertices[i + 1], face.vertices[i + 2]);
                if (tempPs[0].distanceTo(tempPs[1]) < minDist) {
                    minDist = tempPs[0].distanceTo(tempPs[1]);
                    nearestPoints = tempPs;
                }
            }

            return nearestPoints;
        };

        // Find the two nearest points between triangle and triangle
        this.nearestPointsInTriangleToTriangle = function (a1, b1, c1, a2, b2, c2) {

            // A pair of closest points between two triangles can be found by computing the closest points between
            // segment and triangle for all six possible combinations of an edge from one triangle tested against
            // the other triangle. But segment-triangle distance tests are fairly expensive,  and thus a better
            // realization is that the closest pair of points between T1 and T2 can be found to occur either on
            // an edge from each triangle or as a vertex of one triangle and a point interior to the other triangle.
            // In all, six vertex-triangle tests and nine edge-edge tests are required.

            var self = this;
            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            function vertexToTriangleTest(point, a, b, c) {

                var p = self.pointProjectsInTriangle(point, a, b, c);
                if (p && point.distanceTo(p) < minDist) {
                    minDist = point.distanceTo(p);
                    nearestPoints[0] = point;
                    nearestPoints[1] = p;
                }
            }

            function edgeToEdgeTest(p1, p2, p3, p4) {

                var p = self.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
                if (p[0].distanceTo(p[1]) < minDist) {
                    minDist = p[0].distanceTo(p[1]);
                    nearestPoints = p;
                }
            }

            // a1
            vertexToTriangleTest(a1, a2, b2, c2);

            // b1
            vertexToTriangleTest(b1, a2, b2, c2);

            // c1
            vertexToTriangleTest(c1, a2, b2, c2);

            // a2
            vertexToTriangleTest(a2, a1, b1, c1);

            // b2
            vertexToTriangleTest(b2, a1, b1, c1);

            // c2
            vertexToTriangleTest(c2, a1, b1, c1);

            // edge a1b1 and a2b2
            edgeToEdgeTest(a1, b1, a2, b2);

            // edge a1b1 and a2c2
            edgeToEdgeTest(a1, b1, a2, c2);

            // edge a1b1 and b2c2
            edgeToEdgeTest(a1, b1, b2, c2);

            // edge a1c1 and a2b2
            edgeToEdgeTest(a1, c1, a2, b2);

            // edge a1c1 and a2c2
            edgeToEdgeTest(a1, c1, a2, c2);

            // edge a1c1 and b2c2
            edgeToEdgeTest(a1, c1, b2, c2);

            // edge b1c1 and a2b2
            edgeToEdgeTest(b1, c1, a2, b2);

            // edge b1c1 and a2c2
            edgeToEdgeTest(b1, c1, a2, c2);

            // edge b1c1 and b2c2
            edgeToEdgeTest(b1, c1, b2, c2);

            return nearestPoints;
        };

        // Measure between Edge and Face when one of them or both are Curved
        this.curvedEdgeToFaceMeasure = function(edge, face) {

            var minDist = Number.MAX_VALUE;
            var nearestPoints = [];
            var vertices = edge.vertices;

            for (var i = 0; i < vertices.length; i += 2) {

                var tempPs = this.nearestPointsInEdgeToFace(vertices[i], vertices[i + 1], face);
                if (tempPs[0].distanceTo(tempPs[1]) < minDist) {
                    minDist = tempPs[0].distanceTo(tempPs[1]);
                    nearestPoints = tempPs;
                }
            }

            this.drawLine(nearestPoints[0], nearestPoints[1]);

            return [nearestPoints[0], nearestPoints[1]];
        };

        // Measure between Curved Face and Face/Curved Face
        this.curvedFaceToFaceMeasure = function(face1, face2) {

            var minDist = Number.MAX_VALUE;
            var nearestPoints = [];

            var v1s = face1.vertices;
            var v2s = face2.vertices;

            face1.computeBoundingSphere();
            face2.computeBoundingSphere();
            var bSphere1 = new THREE.Sphere();
            var bSphere2 = new THREE.Sphere();
            var mins = [];
            var minMax = Number.MAX_VALUE;
            var minV1s = [];
            var minV2s = [];
            face1.bSpheres = [];
            face2.bSpheres = [];

            // Find the smallest max between face2's bounding sphere and face1's triangles' bounding spheres
            for (var i = 0; i < v1s.length; i += 3) {

                bSphere1.setFromPoints([v1s[i], v1s[i + 1], v1s[i + 2]]);
                face1.bSpheres.push(bSphere1.clone());
                var max = bSphere1.center.distanceTo(face2.boundingSphere.center) + bSphere1.radius + face2.boundingSphere.radius;

                if (max < minMax) {
                    minMax = max;
                }
            }

            // Get rid of the triangles whose min is bigger than smallest max in face1
            for (var i = 0; i < v1s.length; i += 3) {

                bSphere1 = face1.bSpheres[i / 3];
                var min = bSphere1.center.distanceTo(face2.boundingSphere.center) - bSphere1.radius - face2.boundingSphere.radius;

                if (min <= minMax) {
                    minV1s.push(i);
                }
            }

            // Find the smallest max between face1's bounding sphere and face2's triangles' bounding spheres
            minMax = Number.MAX_VALUE;
            for (var j = 0; j < v2s.length; j += 3) {

                bSphere2.setFromPoints(v2s[j], v2s[j + 1], v2s[j + 2]);
                face2.bSpheres.push(bSphere2.clone());
                var max = bSphere2.center.distanceTo(face1.boundingSphere.center) + bSphere2.radius + face1.boundingSphere.radius;

                if (max < minMax) {
                    minMax = max;
                }
            }

            // Get rid of the triangles whose min is bigger than smallest max in face2
            for (var j = 0; j < v2s.length; j += 3) {

                bSphere2 = face2.bSpheres[j / 3];
                var min = bSphere2.center.distanceTo(face1.boundingSphere.center) - bSphere2.radius - face1.boundingSphere.radius;

                if (min <= minMax) {
                    minV2s.push(j);
                }
            }

            minMax = Number.MAX_VALUE;
            for (var i = 0; i < minV1s.length; i++) {

                bSphere1 = face1.bSpheres[minV1s[i] / 3];

                for (var j = 0; j < minV2s.length; j++) {

                    bSphere2 = face2.bSpheres[minV2s[j] / 3];
                    var min = bSphere1.center.distanceTo(bSphere2.center) - bSphere1.radius - bSphere2.radius;
                    var max = bSphere1.center.distanceTo(bSphere2.center) + bSphere1.radius + bSphere2.radius;

                    if (max < minMax) {
                        minMax = max;
                        mins.push({i: minV1s[i], j: minV2s[j], value: min});
                    }
                }
            }

            for (var k = 0; k < mins.length; k++) {

                if (mins[k].value <= minMax && mins[k].value < minDist) {

                    var p = this.nearestPointsInTriangleToTriangle(v1s[mins[k].i], v1s[mins[k].i + 1], v1s[mins[k].i + 2], v2s[mins[k].j], v2s[mins[k].j + 1], v2s[mins[k].j + 2]);
                    if (p[0].distanceTo(p[1]) < minDist) {
                        minDist = p[0].distanceTo(p[1]);
                        nearestPoints = p;
                    }
                }
            }

            this.drawLine(nearestPoints[0], nearestPoints[1]);

            return [nearestPoints[0], nearestPoints[1]];

        };

        // Measure from Face to Edge
        this.faceToEdgeMeasure = function(face, normal, faceIntersectPoint, edge, edgeIntersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1;
            var p2;

            if (eps[0].distanceTo(faceIntersectPoint) < eps[1].distanceTo(faceIntersectPoint)) {
                p1 = eps[0];
                p2 = eps[1];
            }
            else {
                p1 = eps[1];
                p2 = eps[0];
            }

            var X0 = new THREE.Vector3();
            X0.subVectors(p2, p1);

            var angle = this.angleLineToPlane(X0, normal);

            if (X0.dot(normal) <= smallNum && X0.dot(normal) >= -smallNum) { // the edge is parallel with the face

                var p = face.vertices[0];
                var X1 = this.nearestPointInPointToPlane(p1, p, normal);

                var point = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);
                this.faceToPointMeasure(face, normal, faceIntersectPoint, point);

                return [p1, X1, angle];
            }
            else { // nonparallel between edge and face

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);

                this.drawAngleEdgeToFace(face.vertices[0], normal, faceIntersectPoint, p1, newEp, angle);

                //var X1 = this.nearestPointsInEdgeToFace(edge, face);

                //this.drawLine(X1[0], X1[1]);
                //return [X1[0], X1[1], angle];
                return angle;
            }

        };

        // Measure from Edge to Face
        this.edgeToFaceMeasure = function(edge, edgeIntersectPoint, face, normal, faceIntersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1;
            var p2;

            if (eps[0].distanceTo(faceIntersectPoint) < eps[1].distanceTo(faceIntersectPoint)) {
                p1 = eps[0];
                p2 = eps[1];
            }
            else {
                p1 = eps[1];
                p2 = eps[0];
            }

            var X0 = new THREE.Vector3();
            X0.subVectors(p2, p1);

            var angle = this.angleLineToPlane(X0, normal);

            if (X0.dot(normal) <= smallNum && X0.dot(normal) >= -smallNum) { // the edge is parallel with the face

                var p = face.vertices[0];
                var X1 = this.nearestPointInPointToPlane(p1, p, normal);

                var newp1 = new THREE.Vector3();
                newp1.subVectors(faceIntersectPoint, X1);
                newp1.add(p1);

                var newp2 = new THREE.Vector3();
                newp2.subVectors(faceIntersectPoint, X1);
                newp2.add(p2);

                this.drawLine(newp1, faceIntersectPoint);
                this.drawExtensionLinePointToPoint(newp1, newp2);
                return [p1, X1, angle];
            }
            else { // nonparallel between edge and face

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);

                this.drawAngleEdgeToFace(face.vertices[0], normal, faceIntersectPoint, p1, newEp, angle);

                //var X1 = this.nearestPointsInEdgeToFace(edge, face);

                //this.drawLine(X1[0], X1[1]);
                //return [X1[0], X1[1], angle];
                return angle;
            }

        };

        // Get the angle between line and plane
        this.angleLineToPlane = function(v, n) {

            var angle = this.angleVectorToVector(v, n);

            if (angle > 90) {
                angle -= 90;
            }
            else {
                angle = 90 - angle;
            }

            return angle;
        };

        // Draw angle between edge and face
        this.drawAngleEdgeToFace = function(p0, n0, faceIntersectPoint, p1, p2, angle) {

            var p = this.intersectPointLineToPlane(p0, n0, p1, p2);
            if (!p) {
                return;
            }

            var ep1 = p2;

            if (angle === 90) {   // edge and face are vertical with each other
                var ep2 = faceIntersectPoint.clone();
            }
            else {
                var ep2 = this.nearestPointInPointToPlane(p2, p0, n0);
            }

            var n = new THREE.Vector3();
            var n1 = new THREE.Vector3();
            var n2 = new THREE.Vector3();
            n1.subVectors(p2, p1);
            n2.subVectors(ep2, p);
            n.crossVectors(n1, n2);
            n.normalize();

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_consumeSingleClick) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    label.style.pointerEvents = 'none';

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }
        };

        // Get the intersect point between line and plane
        this.intersectPointLineToPlane = function(p0, n0, p1, p2) {

            var smallNum = 0.001;

            var u = new THREE.Vector3();
            var w = new THREE.Vector3();
            u.subVectors(p2, p1);
            w.subVectors(p1, p0);

            var D = n0.dot(u);
            var N = -n0.dot(w);

            if (Math.abs(D) < smallNum) {  // edge is parallel to plane
                if (N == 0)                      // edge lies in plane
                    return null;
                else
                    return null;                    // no intersection
            }

            // they are not parallel
            u.multiplyScalar(N / D);             // compute segment intersect point
            u.add(p1);
            return u;
        };

        // Find the vertex need to draw For circular arc's radius
        this.nearestVertexInVertexToEdge = function(vertex, edge) {

            var nearestPoint;
            var minDist = Number.MAX_VALUE;

            for (var i = 0; i < edge.vertices.length; i++) {
                var dist = vertex.distanceTo(edge.vertices[i]);
                if (minDist > dist) {
                    nearestPoint = edge.vertices[i];
                    minDist = dist;
                }
            }

            return nearestPoint;
        };

        this.isEqualVectors = function (v1, v2, precision) {

            if (Math.abs(v1.x - v2.x) <= precision && Math.abs(v1.y - v2.y) <= precision && Math.abs(v1.z - v2.z) <= precision) {

                return true;
            }

            return false;
        };

        this.isInverseVectors = function (v1, v2, precision) {

            if (Math.abs(v1.x + v2.x) <= precision && Math.abs(v1.y + v2.y) <= precision && Math.abs(v1.z + v2.z) <= precision) {

                return true;
            }

            return false;
        };

        // Set if collapse or expand the xyz delta distance
        this.setSimple = function (simple) {
            if (_simple != simple) {
                _simple = simple;

                for (var name in _lines) {
                    if (name !== 'xyz' && _lines.hasOwnProperty(name)) {
                        var item = _lines[name];
                        if (item.line) {
                            item.line.visible = !simple;

                            if (item.label) {
                                item.label.classList.toggle('visible', !simple);
                            }
                        }
                    }
                }

                _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
            }
        };

        this.hide = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        endPoint.mesh.visible = false;
                    }
                    if (endPoint.label) {
                        endPoint.label.classList.remove('visible');
                    }
                }
            }

            for (name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name];
                    if (edge.line) {
                        for (var i in edge.line) {
                            edge.line[i].visible = false;
                        }
                    }
                    if (edge.label) {
                        edge.label.classList.remove('visible');
                    }
                }
            }

            for (name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name];
                    if (face.mesh) {
                        face.mesh.visible = false;
                    }
                    if (face.label) {
                        face.label.classList.remove('visible');
                    }
                }
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.classList.remove('visible');
            }

            if (_materialAngle) {

                _viewer.impl.clearOverlay(kAngleOverlayName);
                _viewer.impl.clearOverlay(kAngleOutlineOverlayName);
            }

            if (_materialExtensionLine) {

                _viewer.impl.clearOverlay(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {

                _viewer.impl.clearOverlay(kExtensionFaceOverlayName);
            }

            if (_materialGreyOutPlane) {
                _viewer.impl.clearOverlay(kGreyOutPlaneOverlayName);
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
        };

        this.hideClick = function(clickName) {

            if (_endPoints.hasOwnProperty(clickName)) {
                var endPoint = _endPoints[clickName];
                if (endPoint.mesh) {
                    endPoint.mesh.visible = false;
                }
                if (endPoint.label) {
                    endPoint.label.classList.remove('visible');
                }
            }

            if (_edges.hasOwnProperty(clickName)) {
                var edge = _edges[clickName];
                if (edge.line) {
                    for (var i in edge.line) {
                        edge.line[i].visible = false;
                    }
                }
                if (edge.label) {
                    edge.label.classList.remove('visible');
                }
            }

            if (_faces.hasOwnProperty(clickName)) {
                var face = _faces[clickName];
                if (face.mesh) {
                    face.mesh.visible = false;
                }
                if (face.label) {
                    face.label.classList.remove('visible');
                }
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.classList.remove('visible');
            }

            if (_materialAngle) {

                _viewer.impl.clearOverlay(kAngleOverlayName);
                _viewer.impl.clearOverlay(kAngleOutlineOverlayName);
            }

            if (_materialExtensionLine) {

                _viewer.impl.clearOverlay(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {

                _viewer.impl.clearOverlay(kExtensionFaceOverlayName);
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);

        };

        this.destroy = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        _viewer.impl.removeOverlay(kEndPointOverlayName, endPoint.mesh);
                        endPoint.mesh = endPoint.geometry = null;
                    }
                    if (endPoint.label) {
                        endPoint.label.parentNode.removeChild(endPoint.label);
                        endPoint.label = null;
                    }
                }
            }

            for (name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name];
                    if (edge.line) {
                        _viewer.impl.removeMultipleOverlays(kEdgeOverlayName, edge.line);
                        edge.line = edge.intersectPoint = null;
                    }
                    if (edge.label) {
                        edge.label.parentNode.removeChild(edge.label);
                        edge.label = null;
                    }
                }
            }

            for (name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name];
                    if (face.mesh) {
                        _viewer.impl.removeOverlay(kFaceOverlayName, face.mesh);
                        face.mesh = face.intersectPoint = null;
                    }
                    if (face.label) {
                        face.label.parentNode.removeChild(face.label);
                        face.label = null;
                    }
                }
            }

            if (_materialPoint) {
                _materialPoint = null;
                _viewer.impl.removeOverlayScene(kEndPointOverlayName);
            }

            if (_materialFace) {
                _materialFace = null;
                _viewer.impl.removeOverlayScene(kFaceOverlayName);
            }

            if (_materialLine) {
                _materialLine = null;
                _viewer.impl.removeOverlayScene(kEdgeOverlayName);
            }

            if (_materialExtensionLine) {
                _materialExtensionLine = null;
                _viewer.impl.removeOverlayScene(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {
                _materialExtensionFace = null;
                _viewer.impl.removeOverlayScene(kExtensionFaceOverlayName);
            }

            if (_materialGreyOutPlane) {
                _materialGreyOutPlane = null;
                _viewer.impl.clearOverlay(kGreyOutPlaneOverlayName);
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        _viewer.impl.removeOverlay(item.overlayName, item.line);
                        _viewer.impl.removeOverlayScene(item.overlayName);
                        item.material = item.line = item.geometry = null;
                    }

                    if (item.label) {
                        item.label.parentNode.removeChild(item.label);
                        item.label = null;
                    }
                    item.material = item.line = item.geometry = item.label = item.p1 = item.p2 = null;
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.parentNode.removeChild(_angleLabel.label);
                _angleLabel.label = null;
            }
            _angleLabel.label = _angleLabel.p1 = _angleLabel.p2 = null;

        };
    }
};

AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

var SNAP_VERTEX = 0;
var SNAP_EDGE = 1;
var SNAP_FACE = 2;
var SNAP_CIRCULARARC = 3;
var SNAP_CURVEDEDGE = 4;
var SNAP_CURVEDFACE = 5;
var SNAP_PRECISION = 0.001;

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.Snapper = function(viewer, markupMode) {

    var _viewer = viewer;

    var _names = markupMode ? ["snapper-markup"] : ["snapper"];
    var _active = false;

    var _faceOverlayName = 'MeasureTool-snapper-face';
    var _vertexOverlayName = 'MeasureTool-snapper-vertex';
    var _edgeOverlayName = 'MeasureTool-snapper-edge';

    var _radius = null;
    var _distanceToEdge = Number.MAX_VALUE;
    var _distanceToVertex = null;

    var _geomFace = null;
    var _geomEdge = null;
    var _geomVertex = null;
    var _snapNode = null;

    var _geomHighlighted = null; //  {"VERTEX": 0, "EDGE": 1, "FACE": 2}

    var _intersectPoint = null;
    var _faceNormal = null;

    var _isDragging = false;

    var _isSnapped = false;

    var _viewportIndex2d = null;

    var _circularArcCenter = null;
    var _circularArcRadius = null;

    var _clip = null;
    var _firstClickVpId = null; // the viewport index of the first selection for 2D

    this.markupMode = markupMode;

    this.isActive = function() {
        return _active;
    };

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.activate = function() {
        _active = true;
    };

    this.deactivate = function() {
        _active = false;
        this.destroy();
    };

    this.getFace = function() {
        return _geomFace;
    };

    this.getEdge = function() {
        return _geomEdge;
    };

    this.getVertex = function() {
        return _geomVertex;
    };

    this.getGeometry = function() {

        switch (_geomHighlighted) {

            case SNAP_VERTEX: return this.getVertex(); break;
            case SNAP_EDGE: return this.getEdge(); break;
            case SNAP_FACE: return this.getFace(); break;
            case SNAP_CIRCULARARC: return this.getEdge(); break;
            case SNAP_CURVEDEDGE: return this.getEdge(); break;
            case SNAP_CURVEDFACE: return this.getFace(); break;
            default: break;
        }
    };

    this.getSnapNode = function() {
        return _snapNode;
    };

    this.getHighlightGeometry = function() {
        return _geomHighlighted;
    };

    this.getIntersectPoint = function() {
        return _intersectPoint;
    };

    this.getFaceNormal = function() {
        return _faceNormal;
    };

    this.getEndPointsInEdge = function(edge) {

        var vertices = edge.vertices;
        var endPoints = [];

        for (var i = 0; i < vertices.length; ++i) {

            var duplicate = false;

            for (var j = 0; j < vertices.length; ++j) {

                if (j !== i && vertices[j].equals(vertices[i])) {

                    duplicate = true;
                    break;
                }
            }

            if (!duplicate) {

                endPoints.push(vertices[i]);

            }
        }

        return endPoints;
    };

    this.getViewportIndex = function() {
        return _viewportIndex2d;
    };

    this.getCircularArcCenter = function() {
        return _circularArcCenter;
    };

    this.getCircularArcRadius = function() {
        return _circularArcRadius;
    };

    this.getDetectRadius = function() {
        return _radius;
    };

    this.isSnapped = function() {
        return _isSnapped;
    };

    this.setClip = function(clip) {
        _clip = clip;
    };

    this.setFirstClickVpId = function(vpId) {
        _firstClickVpId = vpId;
    };

    this.isEqualWithPrecision = function(a, b) {

        if (Math.abs(a - b) <= SNAP_PRECISION) {
            return true;
        }

        return false;
    };

    this.isEqualVectorsWithPrecision = function(v1, v2) {

        if (Math.abs(v1.x - v2.x) <= SNAP_PRECISION && Math.abs(v1.y - v2.y) <= SNAP_PRECISION && Math.abs(v1.z - v2.z) <= SNAP_PRECISION) {

            return true;
        }

        return false;
    };

    this.isInverseVectorsWithPrecision = function(v1, v2) {

        if (Math.abs(v1.x + v2.x) <= SNAP_PRECISION && Math.abs(v1.y + v2.y) <= SNAP_PRECISION && Math.abs(v1.z + v2.z) <= SNAP_PRECISION) {

            return true;
        }

        return false;
    };

    /**
     * 3D Snapping
     * @param result -Result of Hit Test.
     */
    this.snapping3D = function(result) {

        _snapNode = result.dbId;

        var face = result.face;
        _intersectPoint = result.intersectPoint;
        var fragIds;

        if (result.fragId.length === undefined) {
            fragIds = [result.fragId];
        } else {
            fragIds = result.fragId;
        }

        // This is for Fusion model with topology data
        if (_viewer.model.hasTopology()) {

            // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.
            if (_snapNode) {
                fragIds = [];

                _viewer.model.getData().instanceTree.enumNodeFragments(_snapNode, function(fragId) {
                    fragIds.push(fragId);
                }, true);
            }

            _geomFace = _geomEdge = _geomVertex = null;
            _distanceToEdge = Number.MAX_VALUE;

            for (var fi = 0; fi < fragIds.length; ++fi) {

                var fragId = fragIds[fi];
                var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragId);
                var geometry = mesh.geometry;

                var topoIndex = _viewer.model.getTopoIndex(fragId);
                var topology = _viewer.model.getTopology(topoIndex);
                var facesTopology = topology.faces;
                var edgesTopology = topology.edges;
                var verticesTopology = topology.vertices;

                if (!_geomFace) {
                    _geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);

                    if (_geomFace) {
                        _geomFace.fragId = fragId;
                    }

                    var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    _faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();
                }

                // Need to iterate all frags with same dbId, because when meshes are attached with each other, edges topology data will only be on one mesh.
                this.edgeSnappingWithTopology(_intersectPoint, geometry, edgesTopology, mesh);

            }

            _geomVertex = this.vertexSnappingWithTopology(_geomEdge, _intersectPoint);

            if (_geomFace) {

                // Determine which one should be drawn: face , edge or vertex
                _radius = this.setDetectRadius(_intersectPoint);

                if (_distanceToVertex < _radius) {

                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;

                }
                else if (_distanceToEdge < _radius) {

                    this.drawLine(_geomEdge);

                    var center = this.edgeIsCircle(_geomEdge);
                    if (center) {
                        _circularArcCenter = center;
                        _circularArcRadius = center.distanceTo(_geomEdge.vertices[0]);
                        _geomHighlighted = SNAP_CIRCULARARC;
                    }
                    else if (this.edgeIsCurved(_geomEdge)) {
                        _geomHighlighted = SNAP_CURVEDEDGE;
                    }
                    else {
                        _geomHighlighted = SNAP_EDGE;
                    }

                }
                else {

                    this.drawFace(_geomFace);

                    if (this.faceIsCurved(_geomFace)) {
                        _geomHighlighted = SNAP_CURVEDFACE;
                    }
                    else {
                        _geomHighlighted = SNAP_FACE;
                    }

                }
                
                _isSnapped = true;
            }
        }
        else {

            for (var fi = 0; fi < fragIds.length; ++fi) {

                var fragId = fragIds[fi];
                var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragId);
                var geometry = mesh.geometry;

                _geomFace = this.faceSnapping(face, geometry);

                if (_geomFace) {

                    _geomFace.applyMatrix(mesh.matrixWorld);
                    _geomEdge = this.edgeSnapping(_geomFace, _intersectPoint);
                    _geomVertex = this.vertexSnapping(_geomEdge, _intersectPoint);

                    var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    _faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();

                    // Determine which one should be drawn: face , edge or vertex
                    _radius = this.setDetectRadius(_intersectPoint);

                    if (_distanceToVertex < _radius) {

                        this.drawPoint(_geomVertex);
                        _geomHighlighted = SNAP_VERTEX;

                    }
                    else if (_distanceToEdge < _radius) {

                        this.drawLine(_geomEdge);
                        _geomHighlighted = SNAP_EDGE;

                    }
                    else {

                        this.drawFace(_geomFace);
                        _geomHighlighted = SNAP_FACE;

                    }

                    _isSnapped = true;

                    break;
                }
            }
        }
    };

    this.faceSnappingWithTopology = function(face, geometry, facesTopology, mesh) {

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();
        var vC = new THREE.Vector3();

        var geom = new THREE.Geometry();

        var attributes = geometry.attributes;

        if (attributes.index !== undefined) {

            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;

            // Find the index of face topology list which includes the intersect face(triangle)
            for (var i = 0; i < facesTopology.length; i++) {

                var indexList = facesTopology[i].indexList;
                var faceId = facesTopology[i].id;
                for (var j = 0; j < indexList.length; j += 3) {

                    if (face.a === indexList[j]) {
                        if ((face.b === indexList[j + 1] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j + 1])) {
                            break;
                        }
                    }
                    else if (face.a === indexList[j + 1]) {
                        if ((face.b === indexList[j] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j])) {
                            break;
                        }
                    }
                    else if (face.a === indexList[j + 2]) {
                        if ((face.b === indexList[j] && face.c === indexList[j + 1]) || (face.b === indexList[j + 1] && face.c === indexList[j])) {
                            break;
                        }
                    }
                }

                if (j < indexList.length) {
                    break;
                }
            }

            if (i < facesTopology.length) {

                for (var j = 0; j < indexList.length; j += 3) {
                    vA.set(
                        positions[ indexList[j] * stride ],
                        positions[ indexList[j] * stride + 1 ],
                        positions[ indexList[j] * stride + 2 ]
                    );
                    vB.set(
                        positions[ indexList[j + 1] * stride ],
                        positions[ indexList[j + 1] * stride + 1 ],
                        positions[ indexList[j + 1] * stride + 2 ]
                    );
                    vC.set(
                        positions[ indexList[j + 2] * stride ],
                        positions[ indexList[j + 2] * stride + 1 ],
                        positions[ indexList[j + 2] * stride + 2 ]
                    );

                    var vIndex = geom.vertices.length;

                    geom.vertices.push(vA.clone());
                    geom.vertices.push(vB.clone());
                    geom.vertices.push(vC.clone());

                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));
                }
            }
        }

        //console.log(face);

        if (geom.vertices.length > 0) {

            geom.faceId = faceId;
            geom.applyMatrix(mesh.matrixWorld);
            return geom;
        }
        else {

            return null;
        }

    };

    /**
     * Find the closest face next to the cast ray
     * @param face - the intersect triangle of Hit Test.
     * @param geometry - the geometry of mesh
     */
    this.faceSnapping = function(face, geometry) {

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();
        var vC = new THREE.Vector3();

        var geom = new THREE.Geometry();  //Geometry which includes all the triangles on the same plane.

        var attributes = geometry.attributes;

        if (attributes.index !== undefined) {

            var indices = attributes.index.array || geometry.ib;
            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;
            var offsets = geometry.offsets;

            if ( !offsets || offsets.length === 0) {

                offsets = [{start: 0, count: indices.length, index: 0}];

            }

            for (var oi = 0; oi < offsets.length; ++oi) {

                var start = offsets[oi].start;
                var count = offsets[oi].count;
                var index = offsets[oi].index;

                for (var i = start; i < start + count; i += 3) {

                    var a = index + indices[i];
                    var b = index + indices[i + 1];
                    var c = index + indices[i + 2];

                    vA.set(
                        positions[a * stride],
                        positions[a * stride + 1],
                        positions[a * stride + 2]
                    );
                    vB.set(
                        positions[b * stride],
                        positions[b * stride + 1],
                        positions[b * stride + 2]
                    );
                    vC.set(
                        positions[c * stride],
                        positions[c * stride + 1],
                        positions[c * stride + 2]
                    );

                    var faceNormal = THREE.Triangle.normal(vA, vB, vC);

                    var va = new THREE.Vector3();
                    va.set(
                        positions[ face.a * stride ],
                        positions[ face.a * stride + 1 ],
                        positions[ face.a * stride + 2 ]
                    );

                    if (this.isEqualVectorsWithPrecision(faceNormal, face.normal) && this.isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))
                    {

                        var vIndex = geom.vertices.length;

                        geom.vertices.push(vA.clone());
                        geom.vertices.push(vB.clone());
                        geom.vertices.push(vC.clone());

                        geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

                    }
                }
            }
        }

        if (geom.vertices.length > 0) {

            return this.getTrianglesOnSameFace(geom, face, positions, stride);
        }
        else {

            return null;
        }
    };

    /**
     * Find triangles on the same face with the triangle intersected with the cast ray
     * @param geom -Geometry which includes all the triangles on the same plane.
     * @param face -Triangle which intersects with the cast ray.
     * @param positions -Positions of all vertices.
     * @param stride -Stride for the interleaved buffer.
     */
    this.getTrianglesOnSameFace = function(geom, face, positions, stride) {

        var isIncludeFace = false; // Check if the intersect face is in the mesh
        var vertexIndices = geom.vertices.slice();

        var va = new THREE.Vector3();
        va.set(
            positions[ face.a * stride ],
            positions[ face.a * stride + 1 ],
            positions[ face.a * stride + 2 ]
        );
        var vb = new THREE.Vector3();
        vb.set(
            positions[ face.b * stride ],
            positions[ face.b * stride + 1 ],
            positions[ face.b * stride + 2 ]
        );
        var vc = new THREE.Vector3();
        vc.set(
            positions[ face.c * stride ],
            positions[ face.c * stride + 1 ],
            positions[ face.c * stride + 2 ]
        );
        var intersectFace = new THREE.Geometry();
        intersectFace.vertices.push(va);
        intersectFace.vertices.push(vb);
        intersectFace.vertices.push(vc);
        intersectFace.faces.push(new THREE.Face3(0, 1, 2));

        var vCount = [];

        do {

            vCount = [];

            for (var j = 0; j < vertexIndices.length; j += 3) {

                // The triangle which is intersected with the ray
                if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {

                    isIncludeFace = true;
                    vCount.push(j);
                    continue;
                }

                for (var k = 0; k < intersectFace.vertices.length; k += 3) {

                    // The triangles which are on the same face with the intersected triangle
                    if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],
                            intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {

                        var vIndex = intersectFace.vertices.length;
                        intersectFace.vertices.push(vertexIndices[j].clone());
                        intersectFace.vertices.push(vertexIndices[j + 1].clone());
                        intersectFace.vertices.push(vertexIndices[j + 2].clone());
                        intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

                        vCount.push(j);
                        break;
                    }
                }
            }

            for (var ci = vCount.length - 1; ci >= 0; --ci) {

                vertexIndices.splice(vCount[ci], 3);

            }

        } while (vCount.length > 0);

        if (isIncludeFace) {
            return intersectFace;
        }
        else {
            return null;
        }

    };

    /**
     * Check if the two triangle share edge, the inputs are their vertices
     */
    this.trianglesSharedEdge = function(a1, a2, a3, b1, b2, b3) {

        var c1 = false;
        var c2 = false;
        var c3 = false;

        if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {
            c1 = true;
        }
        if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {
            c2 = true;
        }
        if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {
            c3 = true;
        }

        if (c1 & c2 || c1 & c3 || c2 & c3) {
            return true;
        }

        return false;
    };

    this.edgeSnappingWithTopology = function(intersectPoint, geometry, edgesTopology, mesh) {

        var edgeGeom = new THREE.Geometry();
        var minDistTopoIndex;
        var minDist = Number.MAX_VALUE;

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();

        var attributes = geometry.attributes;

        if (attributes.index !== undefined && edgesTopology != undefined) {

            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;

            // Find the index of edge topology list which includes the nearest edge segment to the intersect point
            for (var i = 0; i < edgesTopology.length; i++) {

                var indexList = edgesTopology[i].indexList;
                // In edges topology index list the type is LineStrip
                for (var j = 0; j < indexList.length - 1; j++) {
                    vA.set(
                        positions[ indexList[j] * stride ],
                        positions[ indexList[j] * stride + 1 ],
                        positions[ indexList[j] * stride + 2 ]
                    );
                    vB.set(
                        positions[ indexList[j + 1] * stride ],
                        positions[ indexList[j + 1] * stride + 1 ],
                        positions[ indexList[j + 1] * stride + 2 ]
                    );

                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);

                    var dist = this.distancePointToLine(intersectPoint, vA, vB);
                    if (dist < minDist) {
                        minDist = dist;
                        minDistTopoIndex = i;
                    }
                }
            }

            if (minDistTopoIndex) {
                indexList = edgesTopology[minDistTopoIndex].indexList;
                for (var k = 0; k < indexList.length - 1; k++) {
                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));
                    // To make the line's type to LinePieces which is used by drawLine function
                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));
                }
            }
        }

        if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {

            _distanceToEdge = minDist;
            edgeGeom.applyMatrix(mesh.matrixWorld);
            _geomEdge = edgeGeom;
        }
    };

    /**
     * Find the closest edge next to the intersect point
     * @param face -Face which is found by faceSnapping.
     * @param intersectPoint -IntersectPoint between cast ray and face.
     * @param mesh -The whole mesh of one fragment.
     */
    this.edgeSnapping = function(face, intersectPoint) {

        var lineGeom = new THREE.Geometry();
        var isEdge_12 = true;
        var isEdge_13 = true;
        var isEdge_23 = true;

        for (var i = 0; i < face.vertices.length; i += 3) {

            for (var j = 0; j < face.vertices.length; j += 3) {

                if ( i !== j ) {
                    // Check edge 12
                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])
                        || face.vertices[i].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])
                        || face.vertices[i + 1].equals(face.vertices[j + 2]))) {

                        isEdge_12 = false;

                    }
                    // Check edge 13
                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])
                        || face.vertices[i].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])
                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {

                        isEdge_13 = false;

                    }
                    // Check edge 23
                    if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])
                        || face.vertices[i + 1].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])
                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {

                        isEdge_23 = false;

                    }
                }
            }

            if (isEdge_12) {

                lineGeom.vertices.push(face.vertices[i].clone());
                lineGeom.vertices.push(face.vertices[i + 1].clone());

            }
            if (isEdge_13) {

                lineGeom.vertices.push(face.vertices[i].clone());
                lineGeom.vertices.push(face.vertices[i + 2].clone());

            }
            if (isEdge_23) {

                lineGeom.vertices.push(face.vertices[i + 1].clone());
                lineGeom.vertices.push(face.vertices[i + 2].clone());

            }

            isEdge_12 = true;
            isEdge_13 = true;
            isEdge_23 = true;

        }

        //return lineGeom;

        var edgeGeom = new THREE.Geometry();
        var minDistIndex;
        var minDist = Number.MAX_VALUE;

        for (var k = 0; k < lineGeom.vertices.length; k += 2) {

            var dist = this.distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);

            if (dist < minDist) {
                minDist = dist;
                minDistIndex = k;
            }

        }

        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex ].clone());
        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex + 1 ].clone());

        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);

        _distanceToEdge = minDist;

        return edgeGeom;

    };

    this.distancePointToLine = function (point, lineStart, lineEnd) {

        var X0 = new THREE.Vector3();
        var X1 = new THREE.Vector3();
        var distance;
        var param;

        X0.subVectors(lineStart, point);
        X1.subVectors(lineEnd, lineStart);
        param = X0.dot(X1);
        X0.subVectors(lineEnd, lineStart);
        param = -param / X0.dot(X0);

        if (param < 0) {
            distance = point.distanceTo(lineStart);
        }
        else if (param > 1) {
            distance = point.distanceTo(lineEnd);
        }
        else {
            X0.subVectors(point, lineStart);
            X1.subVectors(point, lineEnd);
            X0.cross(X1);
            X1.subVectors(lineEnd, lineStart);

            distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));
        }

        return distance;
    };

    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {

        var vertices = lineGeom.vertices.slice();
        var va = edgeVertices[0];
        var vb = edgeVertices[1];

        var vCount = [];

        do {

            vCount = [];

            for (var j = 0; j < vertices.length; j += 2) {

                // The line which has min distance to intersection point
                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {

                    continue;
                }

                for (var k = 0; k < edgeVertices.length; k += 2) {

                    // The line segments which are connected on the same line
                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||
                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {

                        var V0 = new THREE.Vector3();
                        var V1 = new THREE.Vector3();

                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);
                        V0.normalize();
                        V1.subVectors(vertices[j],vertices[j + 1]);
                        V1.normalize();

                        //if (V0.equals(V1) || V0.equals(V1.negate())) {
                        if (this.isEqualVectorsWithPrecision(V0, V1) || this.isInverseVectorsWithPrecision(V0, V1))
                        {

                            vCount.push(j);
                            break;

                        }
                    }
                }
            }

            for (var ci = vCount.length - 1; ci >= 0; --ci) {

                edgeVertices.push(vertices[ vCount[ci] ]);
                edgeVertices.push(vertices[ vCount[ci] + 1 ]);
                vertices.splice(vCount[ci], 2);

            }

        } while (vCount.length > 0);

        return edgeVertices;

    };

    this.vertexSnappingWithTopology = function(edge, intersectPoint) {

        var minDist = Number.MAX_VALUE;
        var point = new THREE.Vector3();

        if (edge && edge.vertices.length > 1) {
            var dist1 = intersectPoint.distanceTo(edge.vertices[0]);
            var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);

            if (dist1 <= dist2) {
                minDist = dist1;
                point = edge.vertices[0].clone();
            }
            else {
                minDist = dist2;
                point = edge.vertices[edge.vertices.length - 1].clone();
            }
        }

        _distanceToVertex = minDist;

        return point;
    };

    /**
     * Find the closest vertex next to the intersect point
     * @param edge -Edge which is found by edgeSnapping.
     * @param intersectPoint -IntersectPoint between cast ray and face.
     */
    this.vertexSnapping = function(edge, intersectPoint) {

        var minDist = Number.MAX_VALUE;
        var point = new THREE.Vector3();

        for (var i = 0; i < edge.vertices.length; ++i) {

            var dist = intersectPoint.distanceTo(edge.vertices[i]);

            if (dist < minDist - SNAP_PRECISION) {

                minDist = dist;
                point = edge.vertices[i].clone();

            }
        }

        _distanceToVertex = minDist;

        return point;
    };

    // This is only a workaround to detect if an edge is circle
    this.edgeIsCircle = function(edge) {

        var vertices = edge.vertices;

        // Exclude squares and regular polygons
        if (vertices.length < 8) {
            return false;
        }

        if (vertices[0].equals(vertices[vertices.length - 1])) {

            var center = new THREE.Vector3(0, 0, 0);
            for (var i = 0; i < vertices.length; i += 2) {
                center.add(vertices[i]);
            }
            center.divideScalar(vertices.length / 2.0);

            var radius = center.distanceTo(vertices[0]);
            for (var i = 0; i < vertices.length; i += 2) {
                if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {
                    continue;
                }
                else {
                    return false;
                }
            }
            return center;
        }
        else {
            return false;
        }
    };

    this.edgeIsCurved = function (edge) {

        var vertices = edge.vertices;

        if (vertices.length <= 2) {
            return false;
        }
        else if (vertices[0].equals(vertices[vertices.length - 1])) {
            return true;
        }
        else {
            var V1 = new THREE.Vector3();
            V1.subVectors(vertices[0], vertices[1]);

            var V2 = new THREE.Vector3();
            for (var i = 2; i < vertices.length; i += 2) {
                V2.subVectors(vertices[i], vertices[i + 1]);
                if (!this.isEqualVectorsWithPrecision(V1, V2)) {
                    return true;
                }
            }

            return false;
        }
    };

    this.faceIsCurved = function (face) {

        var vertices = face.vertices;
        var faces = face.faces;

        if (faces.length <= 1) {
            return false;
        }
        else {
            var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);
            var vA1 = vertices[faces[0].a];

            for (var i = 1; i < faces.length; i++) {
                var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);
                var vA2 = vertices[faces[i].a];

                if (!this.isEqualVectorsWithPrecision(fN1, fN2) || !this.isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {
                    return true;
                }
            }

            return false;
        }
    };

    this.angleVector2 = function(vector) {

        if (vector.x > 0 && vector.y >= 0) {
            return Math.atan(vector.y / vector.x);
        }
        else if (vector.x >= 0 && vector.y < 0) {
            return Math.atan(vector.y / vector.x) + Math.PI * 2;
        }
        else if (vector.x < 0 && vector.y <= 0) {
            return Math.atan(vector.y / vector.x) + Math.PI;
        }
        else if (vector.x <= 0 && vector.y > 0) {
            return Math.atan(vector.y / vector.x) + Math.PI;
        }
        else{ // x = 0, y = 0
            return null;
        }
    };

    function GeometryCallback(viewer, snapper) {
        this.viewer = viewer;
        this.snapper = snapper;

        this.lineGeom = new THREE.Geometry();
        this.circularArc = null;
        this.circularArcCenter;
        this.circularArcRadius;
        this.ellipticalArc = null;
        this.ellipticalArcCenter;

        this.minDist = Number.MAX_VALUE;

        this.vpIdLine = null;
        this.vpIdCircular = null;
        this.vpIdElliptical = null;

        this.detectRadius = this.snapper.getDetectRadius();
    }

    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {
        var intersectPoint = this.snapper.getIntersectPoint();
        var vertices = this.lineGeom.vertices;
        var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);
        var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);

        var dist = this.snapper.distancePointToLine(intersectPoint, v1, v2);
        if (dist <= this.detectRadius && dist < this.minDist) {

            vertices.splice(0, 2, v1, v2);
            this.minDist = dist;

            this.vpIdLine = vpId;
        }
    };

    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {
        var intersectPoint = this.snapper.getIntersectPoint();
        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

        var center = new THREE.Vector2(cx, cy);
        var dist = point.distanceTo(center);
        point.sub(center);

        var angle = this.snapper.angleVector2(point);

        if (Math.abs(dist - radius) <= this.detectRadius) {

            if (end > start && angle >= start && angle <= end) {
                var arc = new THREE.CircleGeometry(radius, 100, start, end - start);
            }
            else if (end < start && (angle >= start || angle <= end)) {
                var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);
            }
            else {
                return;
            }
            arc.vertices.splice(0, 1);
            arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));
            this.circularArc = arc;
            this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);
            this.circularArcRadius = radius;

            this.vpIdCircular = vpId;
        }
    };

    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {
        var intersectPoint = this.snapper.getIntersectPoint();
        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

        var major1 = major - this.detectRadius;
        var minor1 = minor - this.detectRadius;
        var major2 = major + this.detectRadius;
        var minor2 = minor + this.detectRadius;

        var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);
        var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);

        var center = new THREE.Vector2(cx, cy);
        point.sub(center);
        point.x *= minor;
        point.y *= major;
        var angle = this.snapper.angleVector2(point);

        if (end > Math.PI * 2) {
            end = Math.PI * 2;
        }

        if (equation1 >= 1 && equation2 <= 1) {

            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){
                var curve = new THREE.EllipseCurve(cx, cy, major, minor, start, end, false);
                var path = new THREE.Path(curve.getPoints(50));
                var arc = path.createPointsGeometry(50);

                if (!this.snapper.isEqualWithPrecision(end - start, Math.PI * 2))
                {
                    arc.vertices.pop();
                }
                arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));
                this.ellipticalArc = arc;
                this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);

                this.vpIdElliptical = vpId;
            }
        }
    };


    this.snapping2D = function(result) {

        if (!result) {
            return;
        }
        
        var intersectPoint = result.intersectPoint;
        var fragIds = result.fragId;

        //if (_clip && !_viewer.model.pointInPolygon(intersectPoint.x, intersectPoint.y, _clip.contours, _clip.points)) {
        //    return;
        //}

        if (typeof fragIds === "undefined") {
            return;
        }
        else if (!Array.isArray(fragIds)) {
            fragIds = [fragIds];
        }

        _intersectPoint = intersectPoint;

        // Determine which one should be drawn: line, circular arc or elliptical arc
        _radius = this.setDetectRadius(intersectPoint);

        // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.
        var supportsGeomSnapping = (_viewer.model.getFragmentList()!=null);
        if (!supportsGeomSnapping) {

            // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure
            // distances between arbitrary points in rasters.
            _isSnapped       = true;
            _geomHighlighted = SNAP_VERTEX;
            _geomVertex      = intersectPoint;
            this.drawPoint(_geomVertex);

            return;
        }


        var gc = new GeometryCallback(_viewer, this);

        for (var fi = 0; fi < fragIds.length; ++fi) {

            var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragIds[fi]);

            var vbr = new Autodesk.Viewing.Private.VertexBufferReader(mesh.geometry);
            vbr.enumGeomsForObject(result.dbId, gc);

        }

        if (gc.circularArc) {

            _viewportIndex2d = gc.vpIdCircular;

            // Only snap the geometries which belong to the same viewport as the first selection
            if (_firstClickVpId !== null && _firstClickVpId !== _viewportIndex2d)
                return;

            if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _radius) {

                _geomVertex = gc.circularArc.vertices[0];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _radius) {

                _geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else {

                this.lineStripToPieces(gc.circularArc);
                _geomEdge = gc.circularArc;
                this.drawLine(_geomEdge);
                _circularArcCenter = gc.circularArcCenter;
                _circularArcRadius = gc.circularArcRadius;
                _geomHighlighted = SNAP_CIRCULARARC;
            }

            _isSnapped = true;

        }
        else if (gc.ellipticalArc) {

            _viewportIndex2d = gc.vpIdElliptical;

            // Only snap the geometries which belong to the same viewport as the first selection
            if (_firstClickVpId !== null && _firstClickVpId !== _viewportIndex2d)
                return;

            if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _radius) {

                _geomVertex = gc.ellipticalArc.vertices[0];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _radius) {

                _geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else {

                this.lineStripToPieces(gc.ellipticalArc);
                _geomEdge = gc.ellipticalArc;
                this.drawLine(_geomEdge);
                // Before we have measure design for elliptical arc, measure the center for now
                _circularArcCenter = gc.ellipticalArcCenter;
                _circularArcRadius = null;
                _geomHighlighted = SNAP_CIRCULARARC;
            }

            _isSnapped = true;

        }
        else if (gc.lineGeom.vertices.length) {

            _viewportIndex2d = gc.vpIdLine;

            // Only snap the geometries which belong to the same viewport as the first selection
            if (_firstClickVpId !== null && _firstClickVpId !== _viewportIndex2d)
                return;

            if (this.markupMode) {  // Markup mode
                var start = gc.lineGeom.vertices[0];
                var end = gc.lineGeom.vertices[1];
                var mid = new THREE.Vector3();
                mid.addVectors(start, end);
                mid.divideScalar(2);
                var md = intersectPoint.distanceTo(mid);
                var sd = intersectPoint.distanceTo(start);
                var ed = intersectPoint.distanceTo(end);

                // Store it for snapping to parallel/perpendicular of underlying vectors
                _geomEdge = gc.lineGeom;

                if (md < _radius) {
                    _geomVertex = mid;
                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;
                }
                else if (sd < _radius) {
                    _geomVertex = start;
                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;
                }
                else if (ed < _radius) {
                    _geomVertex = end;
                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;
                }
                else {
                    this.drawLine(_geomEdge);
                    _geomHighlighted = SNAP_EDGE;
                }

            }
            else {  // Measure mode
                if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _radius) {

                    _geomVertex = gc.lineGeom.vertices[0];
                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;
                }
                else if (intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _radius) {

                    _geomVertex = gc.lineGeom.vertices[1];
                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;
                }
                else {

                    _geomEdge = gc.lineGeom;
                    this.drawLine(_geomEdge);
                    _geomHighlighted = SNAP_EDGE;
                }
            }

            _isSnapped = true;
        }

    };

    this.lineStripToPieces = function(geom) {

        var vertices = geom.vertices;
        for (var i = vertices.length - 2; i > 0; i--) {
            vertices.splice(i, 0, vertices[i]);
        }
    };

    this.createOverlay = function(overlayName) {

        _viewer.impl.createOverlayScene(overlayName);

    };

    this.addOverlay = function(overlayName, mesh) {

        _viewer.impl.addOverlay(overlayName, mesh);

    };

    this.clearOverlay = function() {

        if (_viewer.impl.overlayScenes[_faceOverlayName]) {
            _viewer.impl.clearOverlay(_faceOverlayName);
        }

        if (_viewer.impl.overlayScenes[_vertexOverlayName]) {
            _viewer.impl.clearOverlay(_vertexOverlayName);
        }

        if (_viewer.impl.overlayScenes[_edgeOverlayName]) {
            _viewer.impl.clearOverlay(_edgeOverlayName);
        }

    };

    /**
     * Draw the planar face
     * @param geom -Geometry which needs to be draw.
     * @param mesh -Mesh which is loaded.
     */
    this.drawFace = function(geom) {

        this.createOverlay(_faceOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        //geom.attributes.index.array = new geom.attributes.index.array.constructor(indicesNew);
        var snapperPlane = new THREE.Mesh(geom, material, true);
        //snapperPlane.matrixWorld = mesh.matrixWorld;

        this.addOverlay(_faceOverlayName, snapperPlane);

    };

    this.cylinderMesh = function(pointX, pointY, material) {

        var direction = new THREE.Vector3().subVectors(pointY, pointX);
        var orientation = new THREE.Matrix4();
        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
            0, 0, 1, 0,
            0, -1, 0, 0,
            0, 0, 0, 1));
        var edgeGeometry = new THREE.CylinderGeometry(0.5, 0.5, direction.length(), 8, 1, true);
        var edge = new THREE.Mesh(edgeGeometry, material);
        edge.applyMatrix(orientation);
        edge.position.x = (pointY.x + pointX.x) / 2;
        edge.position.y = (pointY.y + pointX.y) / 2;
        edge.position.z = (pointY.z + pointX.z) / 2;
        return edge;

    };

    this.drawLine = function(geom) {

        this.createOverlay(_edgeOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        // Line Pieces
        for (var i = 0; i < geom.vertices.length; i += 2) {
            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material);
            this.setEdgeScale(cylinder);
            this.addOverlay(_edgeOverlayName, cylinder);
        }
    };

    this.drawArc = function(geom) {

        this.createOverlay(_edgeOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        // Line Strip
        for (var i = 0; i < geom.vertices.length - 1; i++) {
            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material);
            this.setEdgeScale(cylinder);
            this.addOverlay(_edgeOverlayName, cylinder);
        }
    };

    this.drawPoint = function(point) {

        this.createOverlay(_vertexOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        var pointMesh = new THREE.Mesh(new THREE.SphereGeometry(1.0), material);
        //point.applyMatrix4(mesh.matrixWorld);
        pointMesh.position.set(point.x, point.y, point.z);

        this.setPointScale(pointMesh);

        this.addOverlay(_vertexOverlayName, pointMesh);

    };

    this.setScale = function (mesh) {
        var pixelSize = 5;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var point = mesh.position.clone();

        var distance = camera.isPerspective ? point.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        return scale;
    };

    this.setPointScale = function (pointMesh) {

        var scale = this.setScale(pointMesh);
        pointMesh.scale.x = scale;
        pointMesh.scale.y = scale;
        pointMesh.scale.z = scale;

    };

    this.setEdgeScale = function (cylinderMesh) {

        var scale = this.setScale(cylinderMesh);
        cylinderMesh.scale.x = scale;
        cylinderMesh.scale.z = scale;
    };

    this.updatePointScale = function() {

        var overlay = _viewer.impl.overlayScenes[_vertexOverlayName];
        if (overlay) {
            var scene = overlay.scene;

            for (var i = 0; i < scene.children.length; i++) {
                var pointMesh = scene.children[i];
                if (pointMesh) {

                    this.setPointScale(pointMesh);
                }
            }
        }
    };

    this.updateEdgeScale = function() {

        var overlay = _viewer.impl.overlayScenes[_edgeOverlayName];
        if (overlay) {
            var scene = overlay.scene;

            for (var i = 0; i < scene.children.length; i++) {
                var cylinderMesh = scene.children[i];
                if (cylinderMesh) {

                    this.setEdgeScale(cylinderMesh);
                }
            }
        }
    };

    this.setDetectRadius = function(point) {

        //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of
        //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.
        var pixelSize = av.isMobileDevice() ? 25 : 10;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var p = point.clone();

        var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var radius = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        return radius;
    };

    this.drawIntersectFace = function(face, positions, stride, mesh) {

        this.createOverlay();

        var va = new THREE.Vector3();
        va.set(
            positions[ face.a * stride ],
            positions[ face.a * stride + 1 ],
            positions[ face.a * stride + 2 ]
        );
        var vb = new THREE.Vector3();
        vb.set(
            positions[ face.b * stride ],
            positions[ face.b * stride + 1 ],
            positions[ face.b * stride + 2 ]
        );
        var vc = new THREE.Vector3();
        vc.set(
            positions[ face.c * stride ],
            positions[ face.c * stride + 1 ],
            positions[ face.c * stride + 2 ]
        );

        var intersectFace = new THREE.Geometry();
        intersectFace.vertices.push(va);
        intersectFace.vertices.push(vb);
        intersectFace.vertices.push(vc);
        intersectFace.faces.push(new THREE.Face3(0, 1, 2));

        var faceMesh = new THREE.Mesh(intersectFace, mesh.material, true);
        faceMesh.matrixWorld = mesh.matrixWorld;

        this.addOverlay(faceMesh);

    };

    this.handleWheelInput = function (delta) {
        this.updatePointScale();
        this.updateEdgeScale();
        return false;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        return false;
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        return false;
    };

    this.handleMouseMove = function (event) {

        if (!_isDragging) {

            this.clearOverlay();

            _geomFace = null;
            _geomEdge = null;
            _geomVertex = null;

            _isSnapped = false;

            var result = _viewer.impl.snappingHitTest(event.canvasX, event.canvasY, false);

            if (result && result.intersectPoint) {

                //console.log("intersect node is " + result.node.dbId);
                //console.log("fragId is " + result.node.fragIds);

                // 3D Snapping
                if (result.face) {

                    this.snapping3D(result);
                }
                // 2D Snapping
                else {

                    this.snapping2D(result);
                }
            }
        }
        return false;
    };

    this.handleSingleTap = function(event) {

        return this.handleMouseMove(event);
    };

    this.destroy = function() {

        this.clearOverlay();

        _viewer.impl.removeOverlayScene(_faceOverlayName);
        _viewer.impl.removeOverlayScene(_vertexOverlayName);
        _viewer.impl.removeOverlayScene(_edgeOverlayName);

    };

    /**
     * Handler to mouse move events, used to snap in markup edit mode.
     * @private
     */
    this.onMouseMove = function(mousePosition) {
        this.clearOverlay();

        _geomFace = null;
        _geomEdge = null;
        _geomVertex = null;

        _geomHighlighted = null;

        _isSnapped = false;

        var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);

        if (result && result.intersectPoint) {

            // 3D Snapping
            if (result.face) {

                this.snapping3D(result);
            }
            // 2D Snapping
            else {

                this.snapping2D(result);
            }
        }
    };

    // Get the nearest point on edge from point to edge
    this.nearestPointInPointToEdge = function(edge, point) {

        var vertices = edge.vertices;
        var minDist = Number.MAX_VALUE;
        var nearestPoint = null;

        for (var i = 0; i < vertices.length; i += 2) {

            var nP = this.nearestPointInPointToSegment(point, vertices[i], vertices[i + 1]);
            var dist = point.distanceTo(nP);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = nP;
            }
        }

        return nearestPoint;
    };

    // Get the nearest point on the line segment from point to line segment
    this.nearestPointInPointToSegment = function (point, lineStart, lineEnd) {

        var X0 = new THREE.Vector3();
        var X1 = new THREE.Vector3();
        var nearestPoint;
        var param;

        X0.subVectors(lineStart, point);
        X1.subVectors(lineEnd, lineStart);
        param = X0.dot(X1);
        X0.subVectors(lineEnd, lineStart);
        param = -param / X0.dot(X0);

        if (param < 0) {
            nearestPoint = lineStart;
        }
        else if (param > 1) {
            nearestPoint = lineEnd;
        }
        else {
            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);
        }

        return nearestPoint;
    };

    // Get the nearest point on the line from point to line
    this.nearestPointInPointToLine = function(point, lineStart, lineEnd) {

        var X0 = new THREE.Vector3();
        var X1 = new THREE.Vector3();
        var nearestPoint;
        var param;

        X0.subVectors(lineStart, point);
        X1.subVectors(lineEnd, lineStart);
        param = X0.dot(X1);
        X0.subVectors(lineEnd, lineStart);
        param = -param / X0.dot(X0);

        X0.subVectors(lineEnd, lineStart);
        X0.multiplyScalar(param);
        nearestPoint = X0.add(lineStart);

        return nearestPoint;
    };

};

(function() {

    /*
     * First Person View tool for LMV
     *
     * This tool provides a first person view with movement using the standard WASD keys
     * to forward/backward/left/right and the QE keys to move vertically.  The mouse or
     * cursor is used to orient the view.  Movement is always along or perpendicular to
     * the view direction.
     *
     * The SHIFT key may be used when moving to increase the speed.  Or the default
     * movement speed may be increased/decreased with the MINUS or EQUAL keys.  The
     * ZERO (0) will reset to the default speed values.
     *
     * @author Hans Kellner (Oct 2014)
     *
     */

    AutodeskNamespace('Autodesk.Viewing.Extensions.FirstPerson');

    Autodesk.Viewing.Extensions.FirstPerson.FirstPersonTool = function ( viewerapi ) {

        var avp = Autodesk.Viewing.Private;

        var _isMac = (navigator.userAgent.search("Mac OS") != -1);
        var _navapi = viewerapi.navigation;
        var _container = viewerapi.container;
        var _camera = _navapi.getCamera();
        var _names = ["firstperson"];

        var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };  // TODO: Use the hotkeymanager for these.
        var _keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;

        var _isActive = false;


        // true to disable mouse & keyboard navigation.  Used when a HUD is visible to simulate
        // a modal dialog.
        var _ignoreMouseAndKeyNav = false;

        // if true then mouse drag changes view orientation, otherwise just mouse move.
        // If this is set to false then auto-tracking is enabled which might be a usability
        // issue depending on where the cursor is locate when the tool is enabled.
        // Movement is based on the distance the cursor is located from the center of
        // the screen.  If the cursor is away from center when the tool is enabled then
        // in auto-tracking (non-drag) mode the camera will begin moving.  This may be
        // disconcerting to the user.
        var _mouseDraggingLookMode = true;

        var _isDragging = false;
        var _mouseButtons = 0;
        var _touchType = null;

        var _clock = new THREE.Clock(true);

        var _hudMessageStartShowTime = -1;
        var _hudMessageShowTime = 5000;     // milliseconds to show HUD

        var _modelUnitScale = 1.0; // meters
        var _modelScaleFactor = 1.0;

        // These values define how fast/slow the camera movements are made.
        // Adjust these to fine tune the movement.
        var _movementSpeedDefault = 2.0;
        var _movementSpeed = 2.0;
        var _wheelMovementSpeed = 1.0;
        var _verticalMovementSpeed = 0.5;
        var _lookSpeed = 0.0035;

        // Distance from middle of screen (non-drag) or start position (drag) that's
        // considered a neutral no-move zone when in non-drag movement mode.
        var _neutralZoneDist = 40;

        var _wheelDelta = 0;

        // Current cursor
        var _mouseXstart = 0, _mouseDX = 0, _lastX = -1e20;
        var _mouseYstart = 0, _mouseDY = 0, _lastY = -1e20;

        // Limits on mouse distance to throttle look speed
        var _mouseXMaxLimit = 400;
        var _mouseYMaxLimit = 400;

        // Relative movement
        var _deltaYaw = 0;
        var _deltaPitch = 0;

        // Key movement flags
        var _moveForward = false;
        var _moveBackward = false;
        var _moveLeft = false;
        var _moveRight = false;
        var _moveUp = false;
        var _moveDown = false;

        // Previous FOV and Perspective settings
        var _previousFov = _camera.fov;
        var _restorePreviousFov = false;

        var _wasPerspective = _camera.isPerspective;
        var _restorePreviousPerspective = false;

        // Help HUD
        var _bDontShowAgain_HelpHUD = false;

        //gamepad
        var _gamepadModule;
        //if this browser supports gamepad, instantiate GamepadModule
        if(navigator.getGamepads || !!navigator.webkitGetGamepads || !!navigator.webkitGamepads){
            _gamepadModule = new Autodesk.Viewing.Extensions.GamepadModule(viewerapi);
        }
        // ToolInterface

        this.isActive = function()
        {
            return _isActive;
        };

        this.getNames = function()
        {
            return _names;
        };

        this.getName = function()
        {
            return _names[0];
        };

        this.activate = function(name)
        {
            _clock.start();

            // Switch to perspective
            _wasPerspective = _camera.isPerspective;
            _navapi.toPerspective();

            // Change FOV to a wide value for a better 1st person experience
            _previousFov = _camera.fov;
            _navapi.setVerticalFov(75, true);

            // Unit scale
            _modelUnitScale = viewerapi.model.getUnitScale();

            // Calculate a movement scale factor based on the model bounds.
            var boundsSize = viewerapi.model.getBoundingBox().size();
            _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x,boundsSize.y),boundsSize.z) / 10.0, 0.0001);

            // HACK: Place focus in canvas so we get key events.
            viewerapi.canvas.focus();

            _isActive = true;

            // Display the HUD on startup but only if "don't show me again" wasn't requested
            if (viewerapi.getFirstPersonToolPopup() && !_bDontShowAgain_HelpHUD) {
                showHelpHUD();
            }

            addCrosshair();

            if (_gamepadModule) {
                _gamepadModule.activate(this.getName());
            }
        };

        this.deactivate = function(name)
        {
            _isActive = false;

            _clock.stop();

            hideHUD();
            removeCrosshair();

            if (_restorePreviousFov) {
                _navapi.setVerticalFov(_previousFov, true);
            }

            if (_restorePreviousPerspective) {
                if (!_wasPerspective)
                    _navapi.toOrthographic();
            }

            if(_gamepadModule)
                _gamepadModule.deactivate();

        };

        this.getCursor = function()
        {
            return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3goOFQoQszohGAAAA9hJREFUSMedll1oHGUUhp8zuzP5291pEvNTomgVjFCCCa0NpAqJEJTUFVv8uWxQLwKCF6IUr7wJ6J30QvBCAlZssA0EkYJaAm1FwU3iakrbVNNuutlukk3dzWyT/ZnJ7ufFTtokbmvX72Y45+N73/Oe8858I+xYSikBJJFI7AmFQh9alvVWoVC47vP5ho4cOXJeRGwqWN4yOQ2oHh0dPROJRNo7OjqIRCKPRxeiP66srBxSSn0vIsX/RaCU0gDV399vNjQ0tB8/fpxAIEAsFuP06dPEYrFvgHqguEMxIqLKdUPbmnArU52dnb2maWJUGeRyOWzbpqGxgXg87gOMncDlwLe2Y5uCwcHBFp/P90k4PE349xkWolGi0SjhPy5hF+UmIEopz/1AtxRcqmJzDQ8P7750+Wq8e9+TPGLe4sSp39jz9LMsxm/izE6gOVnquoIcOHDgnddfe/VEU3PLWkUzSCQSesCzxNtvHKZu11O0137OuTMneYY1+l+px99sci5zgU+/Pv/Z5OTkWeCvigja2tqqri3/RPbiMfSWLvY+/wJ7XwxCOoyz+gPF5C0OzsFZv8NEOOxU7KL5+fkcooFUo9avYt+4htTU43noJVTmIPYvp8hnChSKCr/fr1VMkEqlCgEATUDTAIVykhSWRtj4M4/KKzZ9Z9u2ehCCbVUYhlEaurg7m09NB/GWYhe2r69vV8UEvb29DeIWL+6uIG6w6b1SGAqF0hUTZDKZ7GLKy1w0h+Z1keQuMEDOKbK+oZFIJOyKZqCUEsuy/k4mk6kr0ZH6/Z2CkrttEl1QjuJkKI3z6KGp6vTFpYoVmKaZ9Xg8lleDoq3IzOdBILuygbVgs2YVSNrgOM7o1NTURkUE7qufX15evo5A0VHcnrNRgFgFJF6gsVmntlaIxWKNIlK/s8D/VCAianZ29spmv0vfVoVuaNT6PYhWMpGIGIZhNAGtQC3bbXDfj51YlrWObHeOKu3didfX1x3btgGqgADgu5eafyXT6XT2zmDLnVDg9Xq9uq573fMeQAeqy+HtTAgguq7h0aUsgyZCJpPZcBxnE1xz3fhACqp7enoe+3ZimVg8j6ELiIACEUETWErnsCwrD2h1dXW6C+4A2a033T0VfPD+e8dePvoFb36sM/LzKomkQ1FgMW3z7neL3Gh6jtbW1rmamhrDNM0NYAVIAYWyl06ZPwoNeHh6evqJmZmZiV8vnCBw+yLRRCv7gkdpamr6aGho6KuBgQFnfHx88V7AZQlcEt01jgD+sbGx3V+OjPR07d8fDQaDl1OpVLK7u9swTXP1Qa7NfwCi46BIaoRmhAAAAABJRU5ErkJggg==), auto";
        };

        this.adjustSpeed = function( direction )
        {
            if ( direction === 0 ) { // reset to default
                _movementSpeed = _movementSpeedDefault;
            }
            else {
                _movementSpeed *= (direction > 0) ?  1.10 : 0.90;
                if ( _movementSpeed < 0.01 ) {
                    _movementSpeed = 0.01;
                }
            }
        };

        function getEventModifierState(event)
        {
            if ( !!_touchType )
                return false;

            var ctrlKey = event.ctrlKey || (_isMac && event.metaKey);
            var metaKey = event.metaKey && !_isMac;

            //console.log("Mod keys: ctrl = "+ctrlKey+" meta = "+metaKey+" alt^ctrl = "+ (event.altKey ^ ctrlKey));

            return ctrlKey || metaKey || event.shiftKey || event.altKey;
        }

        /////////////////////////////////////////////////////////////////////////
        // Tool event handler callbacks - can use "this".

        this.handleGesture = function( event )
        {
            // Convert Hammer touch-event X,Y into mouse-event X,Y.
            if (event.pointers && event.pointers.length > 0) {
                event.pageX = event.pointers[0].pageX;
                event.pageY = event.pointers[0].pageY;
            }

            switch( event.type )
            {
                case "dragstart":
                    _touchType = "drag";
                    // Single touch, fake the mouse for now...
                    return this.handleButtonDown(event, 0);

                case "dragmove":
                    return (_touchType === "drag") ? this.handleMouseMove(event) : false;

                case "dragend":
                    if( _touchType === "drag" )
                    {
                        this.handleButtonUp(event, 0);
                        _touchType = null;
                        return true;
                    }
                    return false;
            }

            return false;
        };

        this.handleSingleClick = function( event, button )
        {
            return false;
        };

        this.handleButtonDown = function( event, button )
        {
            hideHUD();

            _mouseButtons += 1 << button;

            var modifierState = getEventModifierState(event);
            if (button === 0 && !modifierState) {

                _mouseXstart = event.pageX - window.innerWidth / 2;
                _mouseYstart = event.pageY - window.innerHeight / 2;

                _lastX = event.pageX;
                _lastY = event.pageY;

                _deltaYaw = _deltaPitch = 0;
                _mouseDX = _mouseDY = 0;
                _isDragging = true;
                return true;
            }

            return true;    // Eat all these so default tools don't screw with view
        };

        this.handleMouseMove = function( event )
        {
            var dx = (_lastX < -1e10) ? 0 : event.pageX - _lastX;
            var dy = (_lastY < -1e10) ? 0 : event.pageY - _lastY;
            _lastX = event.pageX;
            _lastY = event.pageY;

            if ( (_isDragging === _mouseDraggingLookMode) && !_ignoreMouseAndKeyNav)
            {
                // Joystick Camera Orientation
                /** DISABLED
                 var xNew = event.pageX - window.innerWidth / 2;
                 var yNew = event.pageY - window.innerHeight / 2;
                 if (_mouseDraggingLookMode) {
                // If in drag mode then movement is relative to start point
                _mouseDX = xNew - _mouseXstart;
                _mouseDY = yNew - _mouseYstart;
            }
                 else {
                _mouseDX = xNew;
                _mouseDY = yNew;
            }
                 // A circular area in the middle of the screen or around the start point
                 // defines a neutral area in which no movement occurs.
                 var mouseMoveDist = Math.sqrt( _mouseDX * _mouseDX + _mouseDY * _mouseDY );
                 if ( mouseMoveDist < _neutralZoneDist ) {
                _mouseDX = _mouseDY = 0;
            }
                 DISABLED **/

                    // Discrete Camera Orientation
                _deltaYaw   += dx * _lookSpeed;
                _deltaPitch += dy * _lookSpeed;
            }

            return true;    // Eat all these so default tools don't screw with view
        };

        this.handleButtonUp = function( event, button )
        {
            _mouseButtons -= 1 << button;

            // If are dragging for a specific button then end dragging no matter
            // what the state of the modifiers.  Otherwise you won't end dragging.
            if (button === 0 && _isDragging) {
                _deltaYaw = _deltaPitch = 0;
                _mouseDX = _mouseDY = 0;
                _isDragging = false;
                return true;
            }

            return true;    // Eat all these so default tools don't screw with view
        };

        this.handleKeyDown = function( event, keyCode )
        {
            if (_ignoreMouseAndKeyNav) {
                return false;
            }

            hideHUD();

            var isModKey = false;
            var handled = false;

            switch( keyCode )
            {
                case _keys.ESCAPE:
                    break;

                case _keys.TAB: handled = false; break;

                // Eat the modifiers so defualt tools don't activate and mess with cam
                case _keys.SHIFT:   _modifierState.SHIFT = 1;   isModKey = handled = true; break;
                case _keys.CONTROL: _modifierState.CONTROL = 1; isModKey = handled = true; break;
                case _keys.ALT:     _modifierState.ALT = 1;     isModKey = handled = true; break;
                case _keys.SPACE:   _modifierState.SPACE = 1;   isModKey = handled = true; break;

                case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
                case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
                case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

                case _keys.UP:
                case _keys.w:
                    _moveForward = true; handled = true;
                    break;

                case _keys.LEFT:
                case _keys.a:
                    _moveLeft = true; handled = true;
                    break;

                case _keys.DOWN:
                case _keys.s:
                    _moveBackward = true; handled = true;
                    break;

                case _keys.RIGHT:
                case _keys.d:
                    _moveRight = true; handled = true;
                    break;

                case _keys.q:
                    _moveUp = true; handled = true;
                    break;

                case _keys.e:
                    _moveDown = true; handled = true;
                    break;

                case _keys.g:
                    handled = true;
                    break;

                case _keys.F1:
                    handled = true;
                    break;
            }

            return handled;
        };

        this.handleKeyUp = function( event, keyCode )
        {
            if (_ignoreMouseAndKeyNav) {
                return false;
            }

            var isModKey = false;
            var handled = false;

            switch( keyCode )
            {
                case _keys.TAB:
                    handled = false;
                    break;

                // Eat the modifiers so defualt tools don't activate and mess with cam
                case _keys.SHIFT:   _modifierState.SHIFT = 0;   isModKey = handled = true; break;
                case _keys.CONTROL: _modifierState.CONTROL = 0; isModKey = handled = true; break;
                case _keys.ALT:     _modifierState.ALT = 0;     isModKey = handled = true; break;
                case _keys.SPACE:   _modifierState.SPACE = 0;   isModKey = handled = true; break;

                case _keys.UP:
                case _keys.w:
                    _moveForward = false; handled = true;
                    break;

                case _keys.LEFT:
                case _keys.a:
                    _moveLeft = false; handled = true;
                    break;

                case _keys.DOWN:
                case _keys.s:
                    _moveBackward = false; handled = true;
                    break;

                case _keys.RIGHT:
                case _keys.d:
                    _moveRight = false; handled = true;
                    break;

                case _keys.q:
                    _moveUp = false; handled = true;
                    break;

                case _keys.e:
                    _moveDown = false; handled = true;
                    break;

                case _keys.g:
                    _mouseDX = _mouseDY = 0;
                    _mouseDraggingLookMode = !_mouseDraggingLookMode;
                    showDraggingLookModeHUD(_mouseDraggingLookMode);
                    handled = true;
                    break;

                case _keys.F1:
                    showHelpHUD();
                    handled = true;
                    break;
            }

            return handled;
        };

        this.handleWheelInput = function(delta)
        {
            if (_ignoreMouseAndKeyNav) {
                return false;
            }

            if ( _navapi.getReverseZoomDirection() )
                delta *= -1;

            _wheelDelta += delta;

            return true;
        };

        this.handleSingleClick = function( event, button ) {
            return false;
        };

        this.handleDoubleClick = function( event, button ) {
            return false;
        };

        this.handleSingleTap = function( event )
        {
            return this.handleSingleClick(event, 0);
        };

        this.handleDoubleTap = function( event ) {
            return false;
        };

        this.handleBlur = function(event)
        {
            // Reset things when we lose focus...
            _moveForward = _moveBackward = false;
            _moveLeft = _moveRight = false;
            _moveUp = _moveDown = false;

            return false;
        };

        this.update = function()
        {

            if (!_isActive || !_navapi.isActionEnabled('walk'))
                return false;

            var delta = _clock.getDelta();//returns delta in unit seconds

            if (_hudMessageStartShowTime > -1) {
                var curTime = new Date().getTime();
                if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) { // seconds
                    hideHUD();
                }
            }

            // From the Collaboration extension:
            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective) {
                console.log("Lost perspective mode: resetting view.");
                _navapi.toPerspective();
            }

            var localCam = _camera.clone();   // Copy of camera to modify

            // Handle movement changes

            var actualMoveSpeed         = delta * _movementSpeed         * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
            var actualVerticalMoveSpeed = delta * _verticalMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);


            if (_wheelDelta != 0) {
                var actualWheelMoveSpeed = _wheelDelta * _wheelMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
                localCam.translateZ( -actualWheelMoveSpeed );
                _wheelDelta = 0;
            }

            if ( _moveForward ) {
                localCam.translateZ(-actualMoveSpeed);
            }

            if ( _moveBackward ) {
                localCam.translateZ( actualMoveSpeed );
            }

            if ( _moveLeft ) {
                localCam.translateX( -actualMoveSpeed );
            }

            if ( _moveRight ) {
                localCam.translateX( actualMoveSpeed );
            }

            if ( _moveUp ) {
                localCam.translateY( actualVerticalMoveSpeed );
            }

            if ( _moveDown ) {
                localCam.translateY( -actualVerticalMoveSpeed );
            }

            var newPosition = localCam.position;
            var posChanged = (newPosition.distanceToSquared(_camera.position) !== 0);

            // Handle look changes

            var actualLookSpeed = delta * _lookSpeed;

            var newTarget = localCam.target;

            var directionFwd = _camera.target.clone().sub(_camera.position);
            //directionFwd = directionFwd.sub((directionFwd.multiply(_camera.worldup)).multiply(_camera.worldup));

            var directionRight = directionFwd.clone().cross(_camera.up).normalize();

            /** Joystick Camera Orientation
             ** This code enabled continuous movement of camera as apposed to the
             ** discrete movement mode below.  Moving the cursor outside of the
             ** center of the view orients the camera in that direction and continues
             ** moving while cursor is outside neutral center.  It works like a
             ** virtual joystick.
             **
             ** Uncomment/Comment these sections to switch the style of camera orientation.
             **/

            /** DISABLED
             var dyawAngle = 0, dpitchAngle = 0;
             if (Math.abs(_mouseDX) > _neutralZoneDist) {
            if (_mouseDX > 0) {
                _mouseDX = Math.min(_mouseDX, _mouseXMaxLimit); // Throttle look speed.
                dyawAngle = (_mouseDX - _neutralZoneDist) * actualLookSpeed;
            }
            else {
                _mouseDX = Math.max(_mouseDX, -_mouseXMaxLimit); // Throttle look speed.
                dyawAngle = (_mouseDX + _neutralZoneDist) * actualLookSpeed;
            }
        }
             if (Math.abs(_mouseDY) > _neutralZoneDist) {
            if (_mouseDY > 0) {
                _mouseDY = Math.min(_mouseDY, _mouseYMaxLimit); // Throttle look speed.
                dpitchAngle = (_mouseDY - _neutralZoneDist) * actualLookSpeed;
            }
            else {
                _mouseDY = Math.max(_mouseDY, -_mouseYMaxLimit); // Throttle look speed.
                dpitchAngle = (_mouseDY + _neutralZoneDist) * actualLookSpeed;
            }
        }
             if (dpitchAngle) {
            var pitchQ = new THREE.Quaternion();
            pitchQ.setFromAxisAngle(directionRight, -dpitchAngle);
            // Need to limit pitch to +-85 degrees so we don't create
            // camera jumping at vertical limits.
            var dirFwdTmp = directionFwd.clone();
            dirFwdTmp.applyQuaternion(pitchQ);
            var vertical = _camera.worldup.clone();
            var vertAngle = dirFwdTmp.angleTo(vertical);
            var vertLimit = THREE.Math.degToRad(5);
            // If new angle is within limits then update values; otherwise ignore
            if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {
                directionFwd.applyQuaternion(pitchQ);
                localCam.up.applyQuaternion(pitchQ);
            }
        }
             if (dyawAngle) {
            var yawQ = new THREE.Quaternion();
            yawQ.setFromAxisAngle(_camera.worldup, -dyawAngle);
            directionFwd.applyQuaternion(yawQ);
            localCam.up.applyQuaternion(yawQ);
        }
             DISABLED **/

            /** Discrete Camera Orientation
             ** Movement based on the delta changes in position or cursor.  See the
             ** the "Dynamic Move" code for an alternative.  In this mode the camera
             ** is oriented based on the delta movement of the cursor.  Movement
             ** stops as camera is oriented to new change of cursor.
             ** TODO: Add logic to smooth motion so camera position ramps towards
             ** the new location rather than discrete jumps.
             **/

            if (_deltaPitch != 0) {
                var pitchQ = new THREE.Quaternion();
                pitchQ.setFromAxisAngle(directionRight, -_deltaPitch);
                // Need to limit pitch to +-85 degrees so we don't create
                // camera jumping at vertical limits.
                var dirFwdTmp = directionFwd.clone();
                dirFwdTmp.applyQuaternion(pitchQ);

                var vertical = _camera.worldup.clone();
                var vertAngle = dirFwdTmp.angleTo(vertical);
                var vertLimit = THREE.Math.degToRad(5);

                // If new angle is within limits then update values; otherwise ignore
                if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {
                    directionFwd.applyQuaternion(pitchQ);
                    localCam.up.applyQuaternion(pitchQ);
                }

                _deltaPitch = 0.0;
            }

            if (_deltaYaw != 0) {
                var yawQ = new THREE.Quaternion();
                yawQ.setFromAxisAngle(_camera.worldup, -_deltaYaw);
                directionFwd.applyQuaternion(yawQ);
                localCam.up.applyQuaternion(yawQ);
                _deltaYaw = 0.0;
            }

            // Now calc new target location and if it changed.
            newTarget = newPosition.clone().add(directionFwd);
            //now fix newPosition for lockInPlane
            var targetChanged = (newTarget.distanceToSquared(_camera.target) !== 0);
            // If position or target changed then update camera.
            if (posChanged || targetChanged) {

                _navapi.setView(newPosition, newTarget);
                //_camera.position = newPosition.clone();
                //_camera.target = newTarget.clone();
                //_camera.dirty = true;s
                // Force the camera to stay orientated up with world up.
                _navapi.orientCameraUp();
            }

            //gamepad integration
            if(_gamepadModule){
                _camera =  _gamepadModule.update(_camera);
            }

            return _camera.dirty;


        };

        /////////////////////////////////////////////////////////////////////////
        // HUD helpers

        // Show a HUD for a specific amount of time (showDelay > 0) or until closed.
        var showHUD = function(messageSpecs, showDelay, closeCB, buttonCB, checkboxCB)
        {
            // TODO: Tool should not be trying to interact with UI
            // Does not comply with headless viewer policy.
            if (!Autodesk.Viewing.Private.HudMessage) {
                return;
            }

            Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCB, buttonCB, checkboxCB);

            if (showDelay > 0) {
                _hudMessageStartShowTime = new Date().getTime();
                _hudMessageShowTime = showDelay;
            }
            else {
                _hudMessageStartShowTime = -1;
                _hudMessageShowTime = 0;
            }
        };

        var hideHUD = function()
        {
            // TODO: Tool should not be trying to interact with UI
            // Does not comply with headless viewer policy.
            if (Autodesk.Viewing.Private.HudMessage) {
                Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
            }
            _hudMessageStartShowTime = -1;
        };

        var showDraggingLookModeHUD = function(enabled)
        {
            hideHUD();

            var messageSpecs = {
                "msgTitleKey"   : "View Orientation Drag Mode Toggled",
                "messageKey"    : "View Orientation Drag Mode Toggled",
                "messageDefaultValue"  : (enabled
                    ? "Press the primary mouse button and drag to change the view orientation"
                    : "Move the cursor to change the view orientation")
            };

            var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
            showHUD(messageSpecs, 0, closeCallback);
        };


        var showHelpHUD = function()
        {
            hideHUD();

            // TODO: Sadly, the HudMessage api doesn't support html formatted messages
            var messageSpecs = {
                "msgTitleKey"           : "First Person Tool",
                "messageKey"            : "Use the WASD and QE keys to move",
                "messageDefaultValue"   : "Use the WASD and QE keys to move", // simplify key and remove peroid
                "checkboxChecked"       : _bDontShowAgain_HelpHUD
            };

            var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
            showHUD(messageSpecs, 0, closeCallback, null, function(e) {
                _bDontShowAgain_HelpHUD = e.target.checked;
                viewerapi.setFirstPersonToolPopup(!e.target.checked);
            });
        };

        addCrosshair = function() {
            if (avp.stringToDOM) {
                this.crosshair = avp.stringToDOM('<div id="remote-crosshair"><div class="crosshair-v"></div><div class="crosshair-h"></div></div>f');
                viewerapi.canvasWrap.appendChild(this.crosshair);
            }
        };

        removeCrosshair = function() {
            if (this.crosshair && this.crosshair.parentNode) {
                this.crosshair.parentNode.removeChild(this.crosshair);
            }
        };
    };

})();

(function() {

//
// First Person
//

'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.FirstPerson');

    /**
     * First Person navigation tool, similar to those found in videogames.
     *
     * It will also replace the default walk tool button when {@link Autodesk.Viewing.GuiViewer3D} is present.
     * @constructor
     * @extends {Autodesk.Viewing.Extension}
     * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
     * @param {object} options - Not used.
     * @category Extensions
     */
Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.constructor = Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension;

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var avu = Autodesk.Viewing.UI;

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.FirstPerson.FirstPersonTool(viewer);
    viewer.toolController.registerTool(this.tool);

    // Add the ui to the viewer.
    this.createUI();

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('firstperson') === -1) {
            return;
        }
        if (self.firstPersonToolButton) {
            var state = e.active ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE;
            self.firstPersonToolButton.setState(state);
        }
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    if (!viewer.getToolbar) return; // Adds support for Viewer3D instance

    var self   = this;
    var avu = Autodesk.Viewing.UI;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    // Create a button for the tool.
    this.firstPersonToolButton = new avu.Button('toolbar-firstPersonTool');
    this.firstPersonToolButton.setToolTip('First person');
    this.firstPersonToolButton.onClick = function(e) {
        var state = self.firstPersonToolButton.getState();
        if (state === avu.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("firstperson");
        } else if (state === avu.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    };
    this.firstPersonToolButton.setIcon("adsk-icon-first-person");

    var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.addControl(this.firstPersonToolButton, {index: navTools.indexOf(cameraSubmenuTool.getId())});
    } else {
        navTools.addControl(this.firstPersonToolButton);
    }
};

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.unload = function()
{
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    if (this.firstPersonToolButton) {
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.firstPersonToolButton.getId());
        }
        this.firstPersonToolButton = null;
    }

    //Uh, why does the viewer need to keep track of this in addition to the tool stack?
    if (viewer.getActiveNavigationTool() == this.tool.getName())
        viewer.setActiveNavigationTool();

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.FirstPerson', Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension);


})();

/**
 * VR tool for LMV
 *
 * @author Hans Kellner (Oct 2014)
 */

AutodeskNamespace('Autodesk.Viewing.Extensions.VR');

Autodesk.Viewing.Extensions.VR.VRTool = function ( viewer, vrExtension ) {

    var av = Autodesk.Viewing;

    var _self = this;

    var _navapi = viewer.navigation;
    var _container = viewer.container;
    var _camera = _navapi.getCamera();
    var _names = ["vr"];

    var _isActive = false;

    var _renderContext = null;    // stereo render context

    var _isXUp = false;
    var _isYUp = true;
    var _isZUp = false;

    // HACK: The first two delta mouse moves are extreme jumps and need to be
    // rejected.  This is used to skip those moves.  Note, it must also be reset
    // to zero whenever switching on/off pointer lock
    var _hackMouseMoveCounter = 0;

    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };  // TODO: Use the hotkeymanager for these.
    var _keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;

    var _wheelDelta = 0;

    var _moveForward = false;
    var _moveBackward = false;
    var _moveLeft = false;
    var _moveRight = false;
    var _moveUp = false;
    var _moveDown = false;

    var _touchDragging = false;

    var _clock = new THREE.Clock(true);

    var _hudMessageStartShowTime = -1;
    var _hudMessageShowTime = 5000;         // milliseconds to show HUD

    var _modelScaleFactor = 1.0;

    var _movementSpeedDefault = 16.0;       // for VR make slower (35 for 1st person tool)
	var _movementSpeed = 16.0;
	var _verticalMovementSpeed = 15.0;
	var _wheelMovementSpeed = 3.0;

    var _autoMove = false;                  // true to automatically move camera forward
    var _autoMoveDefaultSpeed = 1.75;       // Default auto-move speed
    var _autoMoveDir = 1;                   // 1 == forward, -1 == reverse (TODO: disabled for now)
    var _autoMoveStartingSpeed = 16.0;      // Save the _movementSpeed at the start of auto-move

    var _darknessThresholdAutoMove = 15;    // avg gray scale pixel value of camera image to trigger auto-move

	var _previousFov = _camera.fov;
    var _wasPerspective = _camera.isPerspective;

    //
    // Google Goggle VR
    //
    var _deviceOrientationVR = null;
    var _noSleepVR = null;
    var _videoHelper = null;

    var _deviceAutoMoveTrigger = false;   // true if device pointed down (trigger); stays true until device tilted back up

    var _toggleAutoMoveStartTime = -1;
    var _firstAutoMoveSpeedChange = true;

    //
    // WebVR Device initialization (Oculus, etc)
    //
    var _deviceWebAPIVR = null;
    var _deviceSensorVR = null;
    var _vrMode = false;

    var _toggleDeviceVRMovementActivateDistance = 0.15;  // distance in meters before active movement
    var _toggleDeviceVRMovement = false;
    var _toggleDeviceVRMovementOrigin = new THREE.Vector3(0,0,0);
    var _toggleDeviceVRMovementLast = new THREE.Vector3(0,0,0);

    //
    // Wearality HMD
    //
    var _deviceWearalityHMD = false;

    // Constants

    var PI_2 = Math.PI / 2.0;

    /////////////////////////////////////////////////////////////////////////
    // ToolInterface

    this.isActive = function()
    {
        return _isActive;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        if (_isActive)
            return;

        _isXUp = (_camera.worldup && _camera.worldup.x === 1);
        _isYUp = (_camera.worldup && _camera.worldup.y === 1);
        _isZUp = (_camera.worldup && _camera.worldup.z === 1);

        console.log("VRTool : camera world up = "+_camera.worldup.x+","+_camera.worldup.y+","+_camera.worldup.z);

        _clock.start();

        // First check for Oculus or similar device through Web API
        if (getWebAPIVRDevice()) {
            showHelpVRDeviceHMD();
            showUIElements(false);
            console.log("VR Supported (Web API): Oculus, etc.");
        }
        else {
            // Next check for Google Goggle style support
            showHelpVRDeviceOrientation();
            window.addEventListener('deviceorientation', setOrientationControls, true);
        }

        var useVR = (viewer.config && viewer.config.useVR) ? viewer.config.useVR : "";

        // Check for Wearality setting to enable by default
        _deviceWearalityHMD = (useVR.toLowerCase() === "wearality");

        // Create the custom render context for stereo and HMDs
        enableRenderContext(true);

        // NOTE: Handled in stereorendercontext
        //_previousFov = _camera.fov;
        //_navapi.setVerticalFov(75, true);

        // Calculate a movement scale factor based on the model bounds (ignore selection).
        var boundsSize = viewer.utilities.getBoundingBox(true).size();
        _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x,boundsSize.y),boundsSize.z) / 100.0, 1.0);

        this.resetPointerTracking();

        // HACK: Attempt to place focus in canvas so we get key events.
        viewer.canvas.focus();

        showHelpHUD();

        _isActive = true;
    };

    this.deactivate = function(name)
    {
        if (!_isActive)
            return;

        _isActive = false;

        hideHUD();

        if (_deviceOrientationVR) {

            if (_videoHelper) {
                _videoHelper.stop();
                _videoHelper = null;
            }

            _deviceOrientationVR.disconnect();
            _deviceOrientationVR = null;

            // turn off no-sleep mode
            if (_noSleepVR)
                _noSleepVR.disable();
        }

        enableRenderContext(false);

        av.exitFullscreen();

        _clock.stop();

		//_navapi.setVerticalFov(_previousFov, true);
        //if (!_wasPerspective)
        //    _navapi.toOrthographic();

        showUIElements(true);
    };

    this.getCursor = function()
    {
        return "url(data:image/gif;base64,R0lGODlhGAAYAMIDAAQEBH19feDg4P///////////////////yH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEKAAQALAAAAAAYABgAAAMqSLrc/jDKSau9OOvN8fjDNghBIITZEABAgHpr+15jeYpgp+987//AICEBADs=), auto";
    };


    /////////////////////////////////////////////////////////////////////////

    var showUIElements = function(show)
    {
        // Show/hide the toolbar
        var toolbarMenuElements = document.getElementsByClassName('toolbar-menu');
        if (toolbarMenuElements.length > 0) { // HACK: Assume only 1
            if (toolbarMenuElements[0] !== '')
                toolbarMenuElements[0].style.display = show ? 'block' : 'none';
        }
    };

    var adjustSpeed = function( direction )
    {
        if ( direction === 0 ) // reset to default
        {
        	_movementSpeed = _movementSpeedDefault;
        }
        else
        {
            _movementSpeed *= (direction > 0) ?  1.10 : 0.90;
            if ( _movementSpeed < 0.000001 )
                _movementSpeed = 0.000001;
        }
        //console.log("Move Speed = "+_movementSpeed);
    };

    var enableRenderContext = function(enable)
    {
        if ( enable === !!_renderContext )
            return; // no change

        console.log("Enable Render Context: "+enable);

        if (enable)
        {
            viewer.displayViewCube(false, false);

            _wasPerspective = viewer.navigation.isPerspective;
            if (!_wasPerspective)
                viewer.navigation.toPerspective();

            // Enable WarpShade if using an HMD like the Oculus.
            var bUseWarpShader = !!_deviceWebAPIVR;

            var options = null;

            // Support for Wearality HMD?
            if (_deviceWearalityHMD)
            {
                // From Wearality:
                var DEFAULT_IPD = 0.075;  // meters (this kinda depends on person, and latest device has a physical IPD of 0.069  or 69 mm)
                var DEFAULT_CAMERA_ANGLE_OFFSET = -1.5;  // degrees
                var DEFAULT_ASYMMETRY = 0.07;

                // Here is how to set Asytemtric frusum:
                //
                //var horizOblLeft = -DEFAULT_ASYMMETRY;
                //var horizOblRight = DEFAULT_ASYMMETRY;
                //SetObliqueness(horizOblLeft , horizOblRight);
                //
                //private void SetObliqueness(float horizOblLeft, float horizOblRight)
                //{
                //    Matrix4x4 mat1 = camLeft.camera.projectionMatrix;
                //    mat1[0, 2] = horizOblLeft;
                //    mat1[1, 2] = 0;
                //    camLeft.camera.projectionMatrix = mat1;
                //
                //    Matrix4x4 mat2 = camRight.camera.projectionMatrix;
                //    mat2[0, 2] = horizOblRight;
                //    mat2[1, 2] = 0;
                //    camRight.camera.projectionMatrix = mat2;
                //}

                options = {
                    useWarp: bUseWarpShader,

                    HMD: {
                        // Parameters from the Wearality HMD
                        // TODO: Set eyeToScreenDistance, distortionK, and chromaAbParameter values
                        // to match Wearality's.
                        hResolution: 1920,
                        vResolution: 1080,
                        hScreenSize: 0.12576,
                        vScreenSize: 0.07074,
                        interpupillaryDistance: DEFAULT_IPD, // Oculus == 0.0635,
                        lensSeparationDistance: DEFAULT_IPD, // Oculus == 0.0635,
                        eyeToScreenDistance: 0.041,
                        distortionK : [1.0, 0.22, 0.24, 0.0],
                        chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]
                    }
                };
            }
            else {
                // Default HMD options
                options = {
                    useWarp: bUseWarpShader
                };
            }

            _renderContext = new Autodesk.Viewing.Extensions.Oculus.StereoRenderContext( options );
            viewer.impl.setUserRenderContext(_renderContext);

            //TODO: Not sure why we need this call in order to force the
            //stereo layout to fix itself.
            viewer.resize(viewer.canvas.clientWidth, viewer.canvas.clientHeight);

            // Go fullscreen
            if (_deviceWebAPIVR) {
                av.launchFullscreen(viewer.impl.canvas, { vrDisplay: _deviceWebAPIVR });
            } else {
                av.launchFullscreen(viewer.impl.canvas);
            }
        }
        else {
            // disable
            _renderContext = null;
            viewer.impl.setUserRenderContext(null);

            // Restore screen to normal and re-enable viewcube
            viewer.setScreenMode(Autodesk.Viewing.ScreenMode.kNormal);
            viewer.displayViewCube(viewer.prefs.get("viewCube"), false);
        }
    };

    /////////////////////////////////////////////////////////////////////////
    // Tool event handler callbacks - can use "this".

    this.handleSingleTap = function( event )
    {
        //console.log("single tap ("+ (event.pointers ? event.pointers.length : 0)+")");

        // Only interested if we are being run on a mobile device using the
        // Device Orientation api.
        if (_deviceOrientationVR) {
            if ( event.pointers ) {

                if ( event.pointers.length === 1 ) {
                    // Exit VRTool and activate default tool
                    setTimeout(function () {
                        viewer.setActiveNavigationTool(viewer.defaultNavigationToolName);
                    }, 10);
                    return true;
                }
                else if ( event.pointers.length === 2 ) {
                    toggleAutoMove();
                    return true;
                }
            }
        }

        return false;
    };

    this.handleDoubleTap = function( event )
    {
        //console.log("double tap ("+ (event.pointers ? event.pointers.length : 0)+")");
        return false;
    };

    this.handlePressHold = function( event )
    {
        //console.log("press hold ["+(event.type ? event.type : "none")+"] ("+ (event.pointers ? event.pointers.length : 0)+")");
        //if( event.type === "press" )
        //{
        //    event.clientX = event.pointers[0].clientX;
        //    event.clientY = event.pointers[0].clientY;
        //}

        return false;
    };

    this.handleGesture = function( event )
    {
        //console.log("handle gesture ["+(event.type ? event.type : "none")+"]");

        // Only interested if we are being run on a mobile device using the
        // Device Orientation api.
        if (_deviceOrientationVR)
        {
            switch( event.type )
            {
            case "dragstart":
                _touchDragging = true;
                //var x = (event.normalizedX + 1.0) * 0.5;
                //var y = (event.normalizedY + 1.0) * 0.5;
                //console.log("DragStart: "+x+","+y);
                break;

            case "dragmove":
                if (_touchDragging) {
                    //var x = (event.normalizedX + 1.0) * 0.5;
                    //var y = (event.normalizedY + 1.0) * 0.5;
                    //console.log("DragMove: "+x+","+y);
                    // TODO: Use this to adjust auto move speed
                }
                break;

            case "dragend":
                //console.log("DragEnd");
                _touchDragging = false;
                break;
            }
        }

        return false;
    };

    this.handleKeyDown = function( event, keyCode )
    {
        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.TAB: handled = true; break;

            case _keys.SHIFT:   _modifierState.SHIFT = 1;   isModKey = true; handled = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; isModKey = true; handled = true; break;
            case _keys.ALT:     _modifierState.ALT = 1;     isModKey = true; handled = true; break;

            case _keys.SPACE:
                handled = true; break;

            case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
            case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
            case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

            case _keys.w:
                // If Ctrol+Shift+W pressed then skip move handling
                if ( _modifierState.CONTROL === 1 && _modifierState.SHIFT === 1) {
                    handled = true;
                    break;
                }
                // fall through
            case _keys.UP:
                _moveForward = true; handled = true;
                break;

			case _keys.LEFT:
			case _keys.a:
                _moveLeft = true; handled = true;
                break;

			case _keys.DOWN:
			case _keys.s:
                _moveBackward = true; handled = true;
                break;

			case _keys.RIGHT:
			case _keys.d:
                _moveRight = true; handled = true;
                break;

			case _keys.q:
                _moveDown = true; handled = true;
                break;

			case _keys.e:
                _moveUp = true; handled = true;
                break;

            case _keys.h:
                handled = true;
                break;
        }

        return handled;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   isModKey = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; isModKey = true; break;
            case _keys.ALT:     _modifierState.ALT = 0;     isModKey = true; break;

            case _keys.SPACE:
                // HMD support?
                if ( !!_deviceWebAPIVR ) {
                    // Toggle movement on/off.
                    toggleDeviceVRMovement();
                }
                handled = true;
                break;

            case _keys.w:
                // Ctrl+Shift+W pressed?
                if ( !_moveForward && _modifierState.CONTROL === 1 && _modifierState.SHIFT === 1) {
                    // Toggle Wearality HMD on/off

                    // Exit VRTool and activate default tool
                    setTimeout(function () {
                        enableRenderContext(false);
                        _deviceWearalityHMD = !_deviceWearalityHMD;
                        enableRenderContext(true);
                    }, 10);

                    handled = true;
                    break;
                }
                // fall through for movement handling
            case _keys.UP:
                _moveForward = false; handled = true;
                break;

			case _keys.LEFT:
			case _keys.a:
                _moveLeft = false; handled = true;
                break;

			case _keys.DOWN:
			case _keys.s:
                _moveBackward = false; handled = true;
                break;

			case _keys.RIGHT:
			case _keys.d:
                _moveRight = false; handled = true;
                break;

			case _keys.q:
                _moveDown = false; handled = true;
                break;

			case _keys.e:
                _moveUp = false; handled = true;
                break;

            case _keys.h:
                showHelpHUD();
                handled = true;
                break;
        }

        return handled;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
		_moveForward = false;
		_moveBackward = false;
		_moveLeft = false;
		_moveRight = false;

        return false;
    };

	this.update = function(timeStamp)
    {
        if (!_isActive)
            return;

        var delta = _clock.getDelta();

        if (_hudMessageStartShowTime > -1) {
            var curTime = new Date().getTime();
            if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) { // seconds
                hideHUD();
            }
        }

        var vrUpdatedCameraTarget = false;

        // Oculus support?
        if ( !!_deviceWebAPIVR && updateVRDevice(delta) ) {
            vrUpdatedCameraTarget = true;
        } // Controlling via a VR device?  Then use that rather than default keyboard/mouse controls.
        else if ( !!_deviceOrientationVR && updateDeviceOrientationVR(delta) ) {
            vrUpdatedCameraTarget = true;
        }

		var localCam = _camera.clone();   // Copy of camera to modify

        // Handle movement changes
		var actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
        //console.log("Actual speed = "+actualMoveSpeed);

        var actualVerticalMoveSpeed = delta * _verticalMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);

        if (_wheelDelta != 0)
        {
            var actualWheelMoveSpeed = _wheelDelta * _wheelMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
			localCam.translateZ( -actualWheelMoveSpeed );
            _wheelDelta = 0;
        }

        var autoMoveF = false,
            autoMoveB = false,
            autoMoveL = false,
            autoMoveR = false;

        if (_autoMove) {
            if (0) { //_deviceOrientationVR) {
                // IMPORTANT: The screen orientation effects the direction of camera movement.
                switch(_deviceOrientationVR.screenOrientation) // 0/180 = portait, 90/-90 = landscape
                {
                case 0:
                    autoMoveL = true;
                    break;
                case 180:
                    autoMoveR = true;
                    break;
                case 90:
                    autoMoveF = true;
                    break;
                case -90:
                    autoMoveB = true;
                    break;
                }
            }
            else {
                autoMoveF = true;
            }
        }

		if ( _moveForward || autoMoveF ) {
             localCam.translateZ( -actualMoveSpeed );
        }

		if ( _moveBackward || autoMoveB ) {
		     localCam.translateZ( actualMoveSpeed );
        }

		if ( _moveLeft || autoMoveL ) {
			localCam.translateX( -actualMoveSpeed );
        }

		if ( _moveRight || autoMoveR ) {
			localCam.translateX( actualMoveSpeed );
        }

		if ( _moveUp ) {
            localCam.translateY( actualVerticalMoveSpeed );
        }

		if ( _moveDown ) {
		    localCam.translateY( -actualVerticalMoveSpeed );
        }

        var newPosition = localCam.position;
        var posChanged = (newPosition.distanceToSquared(_camera.position) !== 0);
        if (posChanged) {

    		var newTarget = localCam.target;

            var dxyz = newPosition.clone().sub(_camera.position);
            newTarget.add(dxyz);

		    _navapi.setView(newPosition, newTarget);
        }

        return _camera.dirty;
	};

    this.resetPointerTracking = function()
    {
        _moveForward = _moveBackward = false;
        _moveLeft = _moveRight = false;
        _moveUp = _moveDown = false;

        _mouseDraggingLookMode = false;
    };


    /////////////////////////////////////////////////////////////////////////
    // Auto movement support

    var toggleAutoMove = function()
    {
        // Toggle auto-move state
        _autoMove = !_autoMove;

        // If starting to move then save current speed so it can be restored
        if (_autoMove) {
            _autoMoveStartingSpeed = _movementSpeed;
            _movementSpeed = _autoMoveDefaultSpeed;
            _toggleAutoMoveStartTime = new Date().getTime();
        }
        else {
            // Restore speed after auto-move
            _movementSpeed = _autoMoveStartingSpeed;
        }

        showHelpVRMove(_autoMove);

        return _autoMove;
    };


    /////////////////////////////////////////////////////////////////////////
    // Web API VR Support

    var getWebAPIVRDevice = function()
    {
        var foundVRDevice = false;

        // First check for Oculus style support
        function EnumerateVRDevices(devices) {
            // First find an HMD device
            for (var i = 0; i < devices.length; ++i) {
                if (devices[i] instanceof HMDVRDevice) {
                    _deviceWebAPIVR = devices[i];
                }
            }

            // Next find a sensor that matches the HMD hardwareUnitId
            for (var i = 0; i < devices.length; ++i) {
                if (devices[i] instanceof PositionSensorVRDevice &&
                    (!_deviceWebAPIVR || devices[i].hardwareUnitId == _deviceWebAPIVR.hardwareUnitId)) {
                    _deviceSensorVR = devices[i];

                    foundVRDevice = true;
                }
            }
        }

        if (navigator.getVRDevices) {
            navigator.getVRDevices().then(EnumerateVRDevices);
        } else if (navigator.mozGetVRDevices) {
            navigator.mozGetVRDevices(EnumerateVRDevices);
        } else {
            foundVRDevice = false; // WebVR API not supported
        }

        return foundVRDevice;
    };

    var updateVRDevice = function(delta)
    {
        if (!_deviceSensorVR)
            return false;

        var vrState = _deviceSensorVR.getState();

        if (_camera)
        {
            if (_isZUp) {
                _toggleDeviceVRMovementLast.x = vrState.position.x;
                _toggleDeviceVRMovementLast.y = -vrState.position.z;
                _toggleDeviceVRMovementLast.z = vrState.position.y;
            }
            else {
                _toggleDeviceVRMovementLast.x = vrState.position.x;
                _toggleDeviceVRMovementLast.y = vrState.position.y;
                _toggleDeviceVRMovementLast.z = vrState.position.z;
            }

            if (_toggleDeviceVRMovement)
            {
                // If head movement is greater than a specific amount then start
                // applying movement to camera.  This creates a neutral zone at
                // the "center of the joystick".
                var dist = _toggleDeviceVRMovementOrigin.distanceTo(_toggleDeviceVRMovementLast);
                if (dist >= _toggleDeviceVRMovementActivateDistance)
                {
                    // Every X inches from neutral scale
                    var distMovedFromNeutralScaleFactor = (dist - _toggleDeviceVRMovementActivateDistance) / 0.0762/*3in*/;
                    var actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * distMovedFromNeutralScaleFactor;

                    var dir = _toggleDeviceVRMovementLast.clone().sub(_toggleDeviceVRMovementOrigin).normalize().multiplyScalar(actualMoveSpeed);

                    _camera.position.add(dir);
                }
            }

            if (_isZUp) {
                _camera.quaternion.x = vrState.orientation.x;
                _camera.quaternion.y = -vrState.orientation.z;
                _camera.quaternion.z = vrState.orientation.y;
                _camera.quaternion.w = vrState.orientation.w;
            }
            else {
                _camera.quaternion.x = vrState.orientation.x;
                _camera.quaternion.y = vrState.orientation.y;
                _camera.quaternion.z = vrState.orientation.z;
                _camera.quaternion.w = vrState.orientation.w;
            }

            // TODO: The LMV camera still uses the old target value which threejs no longer uses.
            // Therefore we need to set it so the view changes.

            // Apply the camera's rotation to the vector looking down the Z axis
            var lookAtDir = new THREE.Vector3( 0, 0, -1 );

            // Models can have different up vectors.  The code above defaults to Y up.
            // Check for other Up directions.
            if (_isZUp) {
                lookAtDir = new THREE.Vector3(lookAtDir.x, -lookAtDir.z, lookAtDir.y);
            }

            lookAtDir.applyQuaternion( _camera.quaternion );

            // then update the target
            _camera.target = _camera.position.clone().add(lookAtDir.clone().multiplyScalar(10));

            _camera.dirty = true;
        }

        return true;
    };

    // Toggle movement on/off.
    //
    // When toggled on the current HMD postion is the new origin.  Movements away from that
    // origin will be used as a virtual joystick.
    var toggleDeviceVRMovement = function()
    {
        // Oculus support?
        if ( !_deviceWebAPIVR )
            return;

        _toggleDeviceVRMovement = !_toggleDeviceVRMovement;

        if (_toggleDeviceVRMovement) {
            _toggleDeviceVRMovementOrigin.copy(_toggleDeviceVRMovementLast);
        }

        showHelpVRMove(_toggleDeviceVRMovement);
    };

    /////////////////////////////////////////////////////////////////////////
    // Device Orientaton VR Support
    var updateDeviceOrientationVR = function(delta)
    {
        if (!_deviceOrientationVR)
            return false;

        // Get the current device orientation quaternion.
        // The quaternion can be applied to the current camera but that will *not* update
        // the target value nor handle world UP differences.  Therefore we need to also
        // update those values.
        var qOrientation = _deviceOrientationVR.update();
        if (!qOrientation)
            return false;
        //qOrientation.rotation.reorder( "YXZ" );

        // For Z-Up models we need to re-orient YZ values.
        if (_isZUp) {
            var t = qOrientation.z;
            qOrientation.z = qOrientation.y;
            qOrientation.y = -t;
        }

        // Models can have different up vectors.  Adjust for that.
        var lookAtDir = _isZUp ? new THREE.Vector3( 0, 1, 0 ) : new THREE.Vector3( 0, 0, -1 );

        // The LMV camera still uses the old target value which threejs no longer uses.
        // Therefore we need to set it so the view changes.
        var newTargetDir = lookAtDir.clone().applyQuaternion( qOrientation );

        // Distance to current target
        var dist = _camera.target.clone().sub(_camera.position).length();

        // then update the target
        _navapi.setTarget(_camera.position.clone().add(newTargetDir.multiplyScalar(dist)));

        // Handle screen orientation?
        //_deviceOrientationVR.screenOrientation == 90 // landscape 90

        // AUTO-MOVE support using video camera
        //
        // Check for a covered video camera.  That will toggle the movement.
        if (_videoHelper)
        {
            // Check if user has allowed video and video can be acquired.
            // NOTE: If the video helper fails to start then the user will
            // not be able to move the camera's position.
            if (_videoHelper.isStarted())
            {
                // Is it ok to check for a "button" press?
                if (_toggleAutoMoveStartTime <= 0)
                {
                    // Yes, so check for a "dark" image from camera.  Use this to
                    // toggle movement on/off
                    if ( _videoHelper.checkVideoThreshold(_darknessThresholdAutoMove) ) {
                        toggleAutoMove();
                    }
                }
                else
                {
                    // We get here if auto-move has been toggled.  Check if the
                    // camera image is still "dark"?
                    var isDark = _videoHelper.checkVideoThreshold(_darknessThresholdAutoMove);

                    // If not then it was uncovered.  Reset timer so toggle can occur again
                    if (!isDark) {
                        _toggleAutoMoveStartTime = -1;
                    }
                    // Else if still covererd and auto-move enabled then increase speed
                    else if (_autoMove)
                    {
                        var curTime = new Date().getTime();
                        var dTime = curTime - _toggleAutoMoveStartTime;

                        // Every 1/4sec increase by orginal speed
                        if (dTime > 250) { // milliseconds
                            _toggleAutoMoveStartTime = curTime; // restart counter

                            _movementSpeed += _autoMoveStartingSpeed;

                            // Reshow HUD so new speed is displayed
                            showHelpVRMove(true);
                        }
                    }
                }
            }
            //console.log("AUTO_MOVE = "+(_autoMove?"TRUE":"FALSE")+" Toggled(50) = "+ (toggled?"TRUE":"FALSE"));
        }
        else // Alternate move support if not using video camera
        {
            // Auto move support.  Tilt down increases speed.
            var lookDownDir = _isZUp ? new THREE.Vector3( 0, 0, -1 ) : new THREE.Vector3( 0, -1, 0 );
            var viewAngle = THREE.Math.radToDeg(newTargetDir.angleTo(lookDownDir));
            //console.log("View angle = "+viewAngle);

            if ( viewAngle < 30 ) {

                // Is this the first time tilting and the trigger hasn't been activated?
                if ( !_deviceAutoMoveTrigger )
                {
                    // Yes, toggle auto-move.
                    toggleAutoMove();

                    _deviceAutoMoveTrigger = true;  // Stays true until device tilted level.

                    // Beginning to move?
                    if (_autoMove) {
                        _firstAutoMoveSpeedChange = true;
                    }
                }
                else
                {
                    // If the user remains tilting device while auto-move
                    // is on then increase speed
                    if (_autoMove)
                    {
                        var curTime = new Date().getTime();
                        var dTime = curTime - _toggleAutoMoveStartTime;

                        // Every X seconds delay, increase by orginal speed.  But the first
                        // delay is longer so speed doesn't increase immediately.
                        var delay = _firstAutoMoveSpeedChange ? 1500 : 1000; // milliseconds

                        if (dTime >= delay)
                        {
                            _firstAutoMoveSpeedChange = false;
                            _toggleAutoMoveStartTime = curTime; // restart counter

                            _movementSpeed += _autoMoveStartingSpeed; // increase speed

                            // Reshow HUD so new speed is displayed
                            showHelpVRMove(true);
                        }
                    }
                }
            }
            // If device tilt is leveled then clear trigger
            else if ( viewAngle >= 30 ) {
                _deviceAutoMoveTrigger = false;
                _toggleAutoMoveStartTime = -1;
            }
        }

        _camera.dirty = true;
        return true;
    };

    var setOrientationControls = function(e)
    {
        if (!e.alpha) {
            return false;
        }

        window.removeEventListener('deviceorientation', setOrientationControls, true);

        _deviceOrientationVR = new THREE.DeviceOrientationControls();
        _deviceOrientationVR.connect();

        // turn on no-sleep mode.  This plays a hidden video that will cause the
        // phone to say awake.
        if (!_noSleepVR) {
            _noSleepVR = new window.NoSleep();
            _noSleepVR.enable();
        }

        // create the video helper.  note that this will enable the video
        // camera which the user will need to allow.  If the user disallows
        // then they may use the "tilt" mode for auto-move.
        _videoHelper = new VideoHelper("videoVR","videoVR-canvas", 1/*camera index*/);  // change cam index for front vs. back
        if (!_videoHelper.start()) {
            _videoHelper = null;    // failed.
            console.log("VideoHelper : Failed to start.");
        }

        showUIElements(false);

        console.log("VR Supported (DeviceOrientation): Google Goggles, etc.");
        return true;
    };

    /////////////////////////////////////////////////////////////////////////
    // HUD helpers

    var showHUD = function(messageSpecs, showDelay)
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs);
        _hudMessageStartShowTime = new Date().getTime();
        if (!showDelay || showDelay <= 0)
            showDelay = 5000;
        _hudMessageShowTime = showDelay;
    };

    var hideHUD = function()
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        _hudMessageStartShowTime = -1;
    };

    var showHelpHUD = function()
    {
        // TODO: Sadly, the HudMessage api doesn't support html formatted messages
        var messageSpecs = {
            "msgTitleKey"   : "Virtual Reality Tool",
            "messageKey"    : "Virtual Reality Tool",
            "messageDefaultValue"  : "This is the Virtual Reality tool"
        };

        showHUD(messageSpecs, 3000);
    };

    var showHelpVRMove = function(enable, showDelay)
    {
        if (!showDelay || showDelay <= 0)
            showDelay = 250;

        var string1 = Autodesk.Viewing.i18n.translate("START Auto Move");
        var string2 = Autodesk.Viewing.i18n.translate("STOP Auto Move");
        var msg = (enable ? string1 + " ("+Math.floor(_movementSpeed)+")" : string2);

        var messageSpecs = {
            "msgTitleKey"   : "VR Toggle Move",
            "messageKey"    : "VR Toggle Move",
            "messageDefaultValue"  : msg
        };

        showHUD(messageSpecs, showDelay);
    };

    var showHelpVRDeviceOrientation = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "VR Device Orientation",
            "messageKey"    : "VR Device Orientation",
            "messageDefaultValue"  : "VR Mode Enabled Device Orientation"
        };

        showHUD(messageSpecs, 2000);
    };

    var showHelpVRDeviceHMD = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "VR Head Mounted Display",
            "messageKey"    : "VR Head Mounted Display",
            "messageDefaultValue"  : "VR Mode Enabled Head Mounted Display"
        };

        showHUD(messageSpecs, 2000);
    };
};

//
// VR
//

'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.VR');

Autodesk.Viewing.Extensions.VR.VRExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.VR.VRExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.VR.VRExtension.prototype.constructor = Autodesk.Viewing.Extensions.VR.VRExtension;

Autodesk.Viewing.Extensions.VR.VRExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var avu = Autodesk.Viewing.UI;

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.VR.VRTool(viewer, this);
    viewer.toolController.registerTool(this.tool);

    // Add the ui to the viewer.
    this.createUI(toolbar);

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('vr') === -1) {
            return;
        }

        var state = e.active ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE;

        self.vrToolButton.setState(state);
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.VR.VRExtension.prototype.createUI = function(toolbar)
{
    var self   = this;
    var viewer = this.viewer;
    var avu = Autodesk.Viewing.UI;

    var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    // Create a button for the tool.
    this.vrToolButton = new avu.Button('toolbar-vrTool');
    this.vrToolButton.setToolTip('Virtual Reality Tool');
    this.vrToolButton.setIcon("toolbar-vrToolButton");
    this.vrToolButton.onClick = function(e) {
        var state = self.vrToolButton.getState();
        if (state === avu.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("vr");
        } else if (state === avu.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    };

    var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.addControl(this.vrToolButton, {index: navTools.indexOf(cameraSubmenuTool.getId())});
    } else {
        navTools.addControl(this.vrToolButton);
    }
};

Autodesk.Viewing.Extensions.VR.VRExtension.prototype.unload = function ()
{
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.vrToolButton.getId());
    }
    this.vrToolButton = null;

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.VR', Autodesk.Viewing.Extensions.VR.VRExtension);

(function() { 'use strict';

    var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.RaaS');

    /**
     *
     * @param viewer
     * @param options
     * @constructor
     */
    function RaaS(viewer, options) {

        Autodesk.Viewing.Extension.call(this, viewer, options);
    }

    proto = Object.create(Autodesk.Viewing.Extension.prototype);
    proto.constructor = RaaS;
    namespace.RaaS = RaaS;

    var proto = RaaS.prototype;

    proto.load = function () {

        return true;
    };

    proto.unload = function() {

        return true;
    };

    proto.setShot = function(shoot) {

    };

    proto.getShot = function() {

    };

    proto.getCameraAsRenderDescriptor = function() {

        return cameraFromLMVToRaaS(this.viewer);
    };

    /**
     *
     * @param name
     */
    proto.setCameraFromViewName = function(name) {

        var docNode = this.viewer.model.getDocumentNode();
        docNode.search({type:'3d',role:'view'});

        this.viewer.setViewCube(name);
    };

    /**
     *
     * @param camera
     * @returns {*}
     */
    proto.setCameraFromRenderDescriptor = function(camera) {

        return cameraFromRaaSToLMV(this.viewer, camera);
    };

    /**
     *
     * @param viewer
     * @returns {{Projection: {Extent: *, IsOrthographic: *, NativeAspect: *}, Units: *, View: {Eye: *, At: Array, Up: *}}}
     */
    function cameraFromLMVToRaaS(viewer) {

        function getUnitsScale() {

            return  viewer.model.getUnitScale() * 100;
        }

        function swapUpFromYtoZ(point) {

            var y = point[1];
            point[1] =-point[2];
            point[2] = y;

            return point;
        }

        function applyGlobalOffset(point, viewer) {

            var globalOffset = viewer.model.getData().globalOffset;

            if (globalOffset) {
                point[0] += globalOffset.x;
                point[1] += globalOffset.y;
                point[2] += globalOffset.z;
            }

            return point;
        }

        function getExtent(viewport) {

            if (viewport.isOrthographic) {
                return viewport.orthographicHeight * viewport.aspectRatio;
            } else {
                return atanWithWrap(Math.tan(degreesToRadians(viewport.fieldOfView) * viewport.aspectRatio));
            }
        }

        function applyUnitsScale(camera) {

            var scale = getUnitsScale(camera.Units);

            camera.View.Eye[0] *= scale;
            camera.View.Eye[1] *= scale;
            camera.View.Eye[2] *= scale;

            if (camera.Projection.IsOrthographic) {
                camera.Projection.Extent *= scale;
            }
        }

        var state = new Autodesk.Viewing.Private.ViewerState(viewer).getState();
        var viewport = state.viewport;

        var ey = viewport.eye;
        var at = viewport.target;
        var up = viewport.up;

        ey = applyGlobalOffset(ey, viewer);
        at = applyGlobalOffset(at, viewer);

        ey = swapUpFromYtoZ(ey);
        at = swapUpFromYtoZ(at);
        up = swapUpFromYtoZ(up);

        at = normalize([at[0] - ey[0], at[1] - ey[1], at[2] - ey[2]]);
        up = normalize(up);

        var extent = getExtent(viewport);
        var units =  getUnits(viewer);

      //var focalDistance = focalDistance(viewer);
        var result = {
            Projection: {
                Extent: extent,
                IsOrthographic: viewport.isOrthographic,
                NativeAspect: viewport.aspectRatio
            },
            Units: units,
            View: {
                Eye: ey,
                At: at,
                Up: up
            }
    //      FocalDistance: focalDistance,
    //      Aperture: 0
        };

        applyUnitsScale(result);
        result.Units = 'CENTIMETER';
        return result;
    }

    /**
     *
     * @param viewer
     * @param camera
     */
    function cameraFromRaaSToLMV(viewer, camera) {

        function getUnitsScale(units, viewer) {

            // Units are in centimeters, convert to meters and apply current model scale.
            var viewerUnitScale =  1/(viewer.model.getUnitScale() * 100);

            // Remove conversion to RaaS.
            var raasUnitScale = 1.0;
            switch (units.toUpperCase()) {
                case 'FOOT':
                    raasUnitScale = 1/30.48;
                    break;
                case 'INCH':
                    raasUnitScale = 1/2.54;
                    break;
                case 'KILOMETER':
                    raasUnitScale = 1/100000.0;
                    break;
                case 'METER':
                    raasUnitScale = 1.0/100.0;
                    break;
                case 'CENTIMETER':
                    raasUnitScale = 1.0;
                    break;
                case 'MILLIMETER':
                    raasUnitScale = 1/0.1;
                    break;
            }

            return viewerUnitScale;
        }

        function swapUpFromZtoY(point) {

            var y = point[1];
            point[1] = point[2];
            point[2] =-y;

            return point;
        }

        function applyUnitsScale(state, camera, viewer) {

            var scale = getUnitsScale(camera.Units, viewer);

            state.viewport.eye[0] *= scale;
            state.viewport.eye[1] *= scale;
            state.viewport.eye[2] *= scale;

            if (state.viewport.isOrthographic) {
                state.viewport.orthographicHeight *= scale;
            }
        }

        function applyGlobalOffset(point, viewer) {

            var globalOffset = viewer.model.getData().globalOffset;
            if (globalOffset) {
                point[0] -= globalOffset.x;
                point[1] -= globalOffset.y;
                point[2] -= globalOffset.z;
            }

            return point;
        }

        function setExtent(state, camera) {

            var projection = camera.Projection;
            var aspectRatio = projection.NativeAspect;

            if (projection.IsOrthographic) {
                state.viewport["orthographicHeight"] = projection.Extent /  aspectRatio;
            } else {
                state.viewport["fieldOfView"] = radiansToDegrees(atanWithWrap(Math.tan(projection.Extent)) / aspectRatio);
            }
        }

        // Fix/Normalize structure, change all members to camel case starting with uppercase.
        camera = JSON.parse(JSON.stringify(camera));
        camera.Projection.IsOrthographic = camera.Projection.IsOrthographic || camera.Projection.isOrthographic;

        var ey = swapUpFromZtoY(camera.View.Eye);
        var at = normalize(swapUpFromZtoY(camera.View.At));
        var up = normalize(swapUpFromZtoY(camera.View.Up));

        var ratio = camera.Projection.NativeAspect;
        var isOrthographic = camera.Projection.IsOrthographic;
        var projection = isOrthographic ? 'orthographic' : 'perspective';

        var state = {
            viewport: {
                eye: ey,
                target: [ey[0] + at[0], ey[1] + at[1], ey[2] + at[2]],
                up: up,
                aspectRatio: ratio,
                projection: projection,
                isOrthographic: isOrthographic
            }
        };

        setExtent(state, camera);
        applyUnitsScale(state, camera, viewer);
        applyGlobalOffset(state.viewport.eye, viewer);
        state.viewport.target = [
            state.viewport.eye[0] + at[0] * 10,
            state.viewport.eye[1] + at[1] * 10,
            state.viewport.eye[2] + at[2] * 10
        ];

        new Autodesk.Viewing.Private.ViewerState(viewer).restoreState(state);
    }

    function getUnits(viewer) {

        var unitScale = viewer.model.getUnitScale();
        switch (unitScale) {
            case 1.0:
                return 'METER';
            case 0.3048:
                return 'FOOT';
            case 0.0254:
                return 'INCH';
            case 0.01:
                return 'CENTIMETER';
            case 0.001:
                return 'MILLIMETER';
            case 1000:
                return 'KILOMETER';
            default:
                return 'METER';
        }
    }
    
    function normalize(point) {

        var x = point[0];
        var y = point[1];
        var z = point[2];

        var length = Math.sqrt(x * x + y * y + z * z);
        if (length === 0) {
            return point;
        }

        var invLength = 1 / length;
        return [x * invLength, y * invLength, z * invLength];
    }

    function atanWithWrap(radians) {

        var atan = Math.atan(radians);
        return atan < 0 ? atan + Math.PI : atan;
    }

    function radiansToDegrees(radians) {

        return radians * (180 / Math.PI);
    }

    function degreesToRadians(degrees) {

        return degrees * (Math.PI / 180);
    }

    Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.RaaS', RaaS);
})();
(function() { 'use strict';

    var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.ZoomWindow');

    function ZoomWindow(viewer, options) {
        Autodesk.Viewing.Extension.call(this, viewer, options);
    }

    ZoomWindow.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
    ZoomWindow.prototype.constructor = ZoomWindow;

    var proto = ZoomWindow.prototype;

    proto.load = function() {
        var viewer = this.viewer;
        var toolbar = viewer.getToolbar(true);
        //var toolbar = viewer.getToolbar ? viewer.getToolbar(true) : undefined;

        // Init & Register tool
        this.tool = new namespace.ZoomWindowTool(viewer);
        viewer.toolController.registerTool(this.tool);

        // Add the ui to the viewer.
        this.createUI(toolbar);
        return true;
    };

    proto.createUI = function(toolbar) {
        var self = this;
        var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);
        // remove default zoom tool
        if(navTools.dollybutton)
        {
            navTools.removeControl(navTools.dollybutton.getId());
            this.defaultDollyButton = navTools.dollybutton;
        }
        // add combo button for zoom tool
        this.zoomWindowToolButton = new Autodesk.Viewing.UI.ComboButton('toolbar-zoomTools');
        this.zoomWindowToolButton.setIcon('adsk-icon-zoom');
        this.createZoomSubmenu(this.zoomWindowToolButton);
        navTools.addControl(this.zoomWindowToolButton);

        // Escape hotkey to exit tool.
        //
        var hotkeys = [{
            keycodes: [
                Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
            ],
            onRelease: function () {
                if (self.zoomWindowToolButton.getState() === Autodesk.Viewing.UI.Button.State.ACTIVE) {
                    self.viewer.setActiveNavigationTool();
                    self.zoomWindowToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
                }
            }
        }];
        Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, hotkeys);
    };

    proto.destroyUI = function() {
        var viewer = this.viewer;
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);
            if (navTools) {
                if (this.zoomWindowToolButton) {
                    this.zoomWindowToolButton.subMenu.removeEventListener(
                        Autodesk.Viewing.UI.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED,
                        this.zoomWindowToolButton.subMenuActiveButtonChangedHandler(navTools));
                    navTools.removeControl(this.zoomWindowToolButton.getId());
                }
                this.zoomWindowToolButton = null;
                // set back dolly button
                if (navTools.panbutton && this.defaultDollyButton) {
                    navTools.addControl(this.defaultDollyButton);
                }
                else {
                    this.defaultDollyButton = null;
                }
            }
        }
        Autodesk.Viewing.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
    };

    proto.createNavToggler = function(viewer, button, name) {
        return function() {
            var state = button.getState();
            if (state === Autodesk.Viewing.UI.Button.State.INACTIVE) {
                viewer.setActiveNavigationTool(name);
                button.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
            } else if (state === Autodesk.Viewing.UI.Button.State.ACTIVE) {
                viewer.setActiveNavigationTool();
                button.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
            }
        };
    };

    proto.createZoomSubmenu = function(parentButton){

        var viewer = this.viewer;
        var toolbar = viewer.getToolbar(true);
        var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

        // zoom window
        var zoomWindowToolBut = new Autodesk.Viewing.UI.Button('toolbar-zoomWindowTool');
        zoomWindowToolBut.setToolTip(Autodesk.Viewing.i18n.translate("Zoom window"));
        zoomWindowToolBut.setIcon('toolbar-zoomWindowTool');
        zoomWindowToolBut.onClick = this.createNavToggler(viewer, zoomWindowToolBut, 'zoomwindow');
        parentButton.addControl(zoomWindowToolBut);
        // zoom
        var dollyBut = new Autodesk.Viewing.UI.Button('toolbar-zoomTool');
        dollyBut.setToolTip('Zoom');
        dollyBut.setIcon('adsk-icon-zoom');
        dollyBut.onClick = this.createNavToggler(viewer, dollyBut, 'dolly');
        parentButton.addControl(dollyBut);
        parentButton.onClick = dollyBut.onClick; // default
    };

    proto.unload = function() {
        var viewer = this.viewer;
        if (viewer.getActiveNavigationTool() === "dolly" ||
            viewer.getActiveNavigationTool() === "zoomwindow") {
            viewer.setActiveNavigationTool();
        }
        // Remove the UI
        this.destroyUI();
        // Deregister tool
        viewer.toolController.deregisterTool(this.tool);
        this.tool = null;

        return true;
    };

    Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.ZoomWindow', ZoomWindow);
})();
(function() { 'use strict';

    AutodeskNamespace('Autodesk.Viewing.Extensions.ZoomWindow');

    var _DEG_TO_RAD = 0.017453292519943295769;
    var _CROSS_MAX_WIDTH = 20;

    /**
     *
     * @constructor
     */
    function ZoomWindowTool(viewer) {
        var _names = ["zoomwindow"];
        var _isActive = false;
        var _isDragging = false;
        var _mouseStart = new THREE.Vector3(0,0,-10);
        var _mouseEnd = new THREE.Vector3(0,0,-10);

        var materialLine = null;
        var lineGeom = null;
        var crossGeomX = null;
        var crossGeomY = null;

        var rectGroup = null;
        var _camera = viewer.navigation.getCamera();

        this.isActive = function() {
            return _isActive;
        };

        this.getNames = function() {
            return _names;
        };

        this.getName = function() {
            return _names[0];
        };

        this.onResize = function() {
            rectGroup = null;
            var canvas = viewer.canvas;
            var canvasWidth = canvas.clientWidth;
            var canvasHeight = canvas.clientHeight;
            var camera = new THREE.OrthographicCamera(0,canvasWidth,0,canvasHeight,1,1000);
            viewer.impl.overlayScenes["ZoomWindowRect"].camera = camera;
        };

        this.activate = function(name) {
            _isActive = true;
            // predefine material for rect
            if(materialLine === null) {
                // for 2d file draw rectangle in black
                var rectColor = null;
                if (viewer.navigation.getIs2D()) {
                    rectColor = new THREE.Color(0x000000);
                }
                else {
                    rectColor = new THREE.Color(0xffffff);
                }
                materialLine = new THREE.LineBasicMaterial({
                    color: rectColor,
                    opacity: .6,
                    linewidth: 1
                });
            }
            // create overlay scene, with orthographic Camera
            var canvas = viewer.canvas;
            var canvasWidth = canvas.clientWidth;
            var canvasHeight = canvas.clientHeight;
            var camera = new THREE.OrthographicCamera(0,canvasWidth,0,canvasHeight,1,1000);

            viewer.impl.createOverlayScene("ZoomWindowRect", materialLine, materialLine,camera);
            viewer.impl.api.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);

            // ??? In zoom window tool, we let orbitDollyPanTool to handle
            // ??? pan and dolly. And also we need get correct cursor info
            // ??? in orbitDollyPanTool. But in 2D, orbitDollyPanTool's default
            // ??? cursor is pan, then we have no idea whether orbitDollyPanTool
            // ??? is handling the message.
            // ??? So set orbit tool as active tool when zoom window tool active.
            // ??? On deactive we need set back the correct active tool to orbitDollyPanTool
            var tool = viewer.toolController.getTool("dolly");
            tool.activate("orbit");
        };

        this.deactivate = function(name) {
            rectGroup = null;
            viewer.impl.removeOverlayScene("ZoomWindowRect");
            _isActive = false;
            _isDragging = false;
            viewer.impl.api.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);

            // ??? Refer to the comments in activate
            var tool = viewer.toolController.getTool("dolly");
            tool.deactivate("orbit");
        };

        this.getCursor = function() {
            var tool = viewer.toolController.getTool("dolly");
            var mode = tool.getTriggeredMode();
            switch( mode )
            {
                case "dolly":
                    return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAgVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8mJiYAAADNzc2/v7+fn59paWlPT08MDAwICAj6+vqpqak7Ozv29vby8vLp6em2traAgIBkZGRZWVlAQEAaGhpISEgkS7tbAAAAFHRSTlMAOvhpZD8mkQWegMy9qY1YVE01EYiqlE0AAADZSURBVCjPbY9ZloMgEAAbEbfsmRZZXbJn7n/AAX2RQVN/VD26AXLOeZLDGo6IbfI9tHq8cdxuj1HwvgCoaiHqKoRk+M3hB9jueUW8PnfsE/bJ3vms7nCkq7NoE3s99AXxoh8vFoXCpknrn5faAuJCenT0xPkYqnxQFJaU0gdZrsKm8aHZrAIffBj40mc1jsTfIJRWegq6opTMvlfqLqYg7kr1ZB7jFgeaMC59N//8O4WZ1IiPF8b5wMHcJn8zB4g4mc77zpxgAbMSUVoGK4iV0hL4wrksz+H0Bw5+E+HrniDQAAAAAElFTkSuQmCC), auto";
                case "pan":
                    return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAABHVBMVEUAAABPTk4AAAAAAAAJCQkRERE0MzQQEBAODg4QEBB4d3dbWlo9PDw/Pj4vLy8sLCwZGBgWFhYcHBwKCgoSEhIAAAAKCgoICAgKCgoQEBAODg4EBAQICAgPDw8REREMDAx2dnY0NDQvLy9QUFAaGhomJSYjIyM7OjokJCQNDA0mJiYNDQ0AAAAUFBQJCQkQEBAEBAQNDQ0PDw8VFRX///+amJkAAAD5+fnz8/PKycn9/f339vbi4eLR0dDNzMyAgIB8e3xycHH7+/vw7+/o6OjX1ta7urq4t7iwsLCnp6eioqKbmppva21OTk74+Pjl5eXc3Nzb29vLy8vDw8PDwsKrqqqdnZ2WlpaSkpKTkZKMiouEg4NkZGRISEgxLzBpgbsEAAAANHRSTlMA+fiQXgngKSYG/vX17uvBuqackpCNg3BpUkpAPBwTDvj18+vl0s/NwrOwoZZ+TDg4NBkBGrzX8QAAAP5JREFUKM99j9Vuw0AQRdeuKZyGkyZNmbnXDLHDVGb8/8/oy7paK1bO0+oc7WiGnGiaxq+QRTQAOh8f9Jv4H/Ge8PZPrCdlvkxfYluUT2WyyCq3mZ7unwlKVLcqOzA/Mf71j0TWJ/Ym6rPeca05Ni4iIevYc7yoUD2zQFhq71BdI9nvBeBabFDSPe8DswlUc1Riw3VxbH0NHBUPQ0jrbDnPYDjALQBMq9E7nkC5y7VDKTZlUg8Q0lmjvl74zlYErgvKa42GPKf3/a0kQmYCDY1SYMDosqMoiWrGwz/uAbNvc/fNon4kXRKGq+PUo2Mb96afV0iUxqGU2s4VBbKUP65NL/LKF+7ZAAAAAElFTkSuQmCC), auto";
            }
            return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAADWSURBVEiJ1ZVNEsIwCEYfTg/UjTPuemcvojfCRRMlNKGdKguZyaLkK4/8EERVybQJQERCUU3C63p+n/Bk9QHDRtbIX2GqKh6woRfxLdL0/M1KzYRaA+7AXDW9wN5fvrXEWud6AOABLD7QwREDgCdw7WV6ZjSAsi0Lzn4JmEcHeHbYWxQXw3FTEWmvaWY1X9Iie4CIKHE1fwfIsnSAZD/X/79FGbdISyzA9QMDG3axTTTVwx3NaNbm5B2dRHY1DWCUyd4qIs0bUB8nuz32/11Cu+KPM7sOXlrOS4sOkzb1AAAAAElFTkSuQmCC), auto";
        };


        function getEventModifierState(event) {
            return true;
        }

        /////////////////////////////////////////////////////////////////////////
        // Tool event handler callbacks - can use "this".

        this.handleGesture = function(event) {
            return true;
        };

        this.handleSingleClick = function(event, button) {
            return true;
        };

        this.startDrag = function(event) {
            if(_isDragging === false){
                // begin dragging
                _isDragging = true;
                _mouseStart.x = event.canvasX;
                _mouseStart.y = event.canvasY;
                _mouseEnd.x = event.canvasX;
                _mouseEnd.y = event.canvasY;
                if(rectGroup === null) {
                    lineGeom = new THREE.Geometry();
                    // rectangle of zoom window
                    lineGeom.vertices.push(
                        _mouseStart.clone(),
                        _mouseStart.clone(),
                        _mouseStart.clone(),
                        _mouseStart.clone(),
                        _mouseStart.clone());
                    // cross for identify zoom window center.
                    crossGeomX = new THREE.Geometry();
                    crossGeomX.vertices.push(
                        _mouseStart.clone(),
                        _mouseStart.clone());
                    crossGeomY = new THREE.Geometry();
                    crossGeomY.vertices.push(
                        _mouseStart.clone(),
                        _mouseStart.clone());

                    // add geom to group
                    var line_mesh = new THREE.Line(lineGeom, materialLine, THREE.LineStrip);
                    var line_cross_x = new THREE.Line(crossGeomX,materialLine, THREE.LineStrip);
                    var line_cross_y = new THREE.Line(crossGeomY,materialLine, THREE.LineStrip);

                    rectGroup = new THREE.Group();
                    rectGroup.add(line_mesh);
                    rectGroup.add(line_cross_x);
                    rectGroup.add(line_cross_y);
                }
                else {
                    lineGeom.vertices[0] = _mouseStart.clone();
                    lineGeom.vertices[1] = _mouseStart.clone();
                    lineGeom.vertices[2] = _mouseStart.clone();
                    lineGeom.vertices[3] = _mouseStart.clone();
                    lineGeom.vertices[4] = _mouseStart.clone();

                    crossGeomX.vertices[0] = _mouseStart.clone();
                    crossGeomX.vertices[1] = _mouseStart.clone();
                    crossGeomY.vertices[0] = _mouseStart.clone();
                    crossGeomY.vertices[1] = _mouseStart.clone();


                    crossGeomX.verticesNeedUpdate = true;
                    crossGeomY.verticesNeedUpdate = true;
                    lineGeom.verticesNeedUpdate = true;
                }
                viewer.impl.addOverlay("ZoomWindowRect",rectGroup);
            }
        };

        this.handleButtonDown = function(event, button) {
            // only handle left button down
            if(button === 0) {
                this.startDrag(event);
                return true;
            }
            return false;
        };

        this.handleMouseMove = function(event) {
            if(lineGeom && _isDragging)
            {
                _mouseEnd.x = event.canvasX;
                _mouseEnd.y = event.canvasY;
                return true;
            }

            return false;    // Eat all these so default tools don't screw with view
        };

        this.endDrag = function(event) {
            if(_isDragging === true) {
                viewer.impl.removeOverlay("ZoomWindowRect",rectGroup);
                _isDragging = false;

            }
        };

        this.handleButtonUp = function(event, button) {
            if(button === 0)
            {
                this.endDrag();
                return true;
            }
            return false;
        };

        this.handleKeyDown = function(event, keyCode) {
            return false;
        };

        this.handleKeyUp = function(event, keyCode) {
            return false;
        };

        this.handleWheelInput = function(delta) {
            return false;
        };

        this.handleSingleClick = function(event, button) {
            return false;
        };

        this.handleDoubleClick = function(event, button) {
            return false;
        };

        this.handleSingleTap = function(even) {
            return false;
        };

        this.handleDoubleTap = function(event) {
            return false;
        };

        this.handleBlur = function(event) {
            return false;
        };

        this.update = function() {
            //
            if(!this.isActive())
                return ;

            if(lineGeom && _isDragging) {
                // draw rectangle
                lineGeom.vertices[1].x = _mouseStart.x;
                lineGeom.vertices[1].y = _mouseEnd.y;
                lineGeom.vertices[2] = _mouseEnd.clone();
                lineGeom.vertices[3].x = _mouseEnd.x;
                lineGeom.vertices[3].y = _mouseStart.y;
                lineGeom.vertices[4] = lineGeom.vertices[0];

                // draw cross
                var width = Math.abs(_mouseEnd.x - _mouseStart.x);
                var height = Math.abs(_mouseEnd.y - _mouseStart.y);
                var length = width>height ? height : width;
                if(length > _CROSS_MAX_WIDTH) {
                    length = _CROSS_MAX_WIDTH;
                }
                var half_length = length*0.5;

                var cross_center = [(_mouseEnd.x + _mouseStart.x)*0.5,
                    (_mouseEnd.y + _mouseStart.y)*0.5];

                crossGeomX.vertices[0].x = cross_center[0] - half_length;
                crossGeomX.vertices[0].y = cross_center[1];
                crossGeomX.vertices[1].x = cross_center[0] + half_length;
                crossGeomX.vertices[1].y = cross_center[1];

                crossGeomY.vertices[0].x = cross_center[0];
                crossGeomY.vertices[0].y = cross_center[1] - half_length;
                crossGeomY.vertices[1].x = cross_center[0];
                crossGeomY.vertices[1].y = cross_center[1] + half_length;

                crossGeomX.verticesNeedUpdate = true;
                crossGeomY.verticesNeedUpdate = true;
                lineGeom.verticesNeedUpdate = true;
                // only redraw overlay
                viewer.impl.invalidate(false, false, true);
            }
            else {
                return this.zoomWindow();
            }

            return false;
        };

        this.getScreenRay = function(mouseX, mouseY, screenWidth, screenHeight, camera) {
            var eye = camera.position.clone();
            var center = camera.target.clone();
            var eye2Center = center.clone().sub(eye);
            var up = camera.up.clone();
            var right = eye2Center.clone().cross(up);

            var dist = eye2Center.length();

            var halfFrustumHeight = dist*Math.tan(camera.fov*_DEG_TO_RAD);
            var halfFrustumWidth = halfFrustumHeight*camera.aspect;

            var rightLength = mouseX * 2*halfFrustumWidth/screenWidth;
            var center2RightLength = rightLength - halfFrustumWidth;

            var upLength = mouseY * 2*halfFrustumHeight/screenHeight;
            var center2UpLength = upLength - halfFrustumHeight;

            up = up.normalize().multiplyScalar(center2UpLength);
            right = right.normalize().multiplyScalar(center2RightLength);

            var rayOri = new THREE.Vector3();
            var rayDirection = new THREE.Vector3();

            if(camera.isPerspective) {
                rayOri = eye.clone();

                rayDirection = eye2Center.clone();
                rayDirection.add(up);
                rayDirection.add(right);
            }
            else {
                rayOri = eye.clone();
                rayOri.add(right);
                rayOri.add(up);

                rayDirection.add(eye2Center);
            }

            return {
                rayOrigin: rayOri,
                rayDirection: rayDirection
            };
        };

        this.queryMouseRaySceneIntersection = function(centerX,centerY) {
            if(viewer == null)
                return null;

            if(viewer.model == null)
                return null;

            if(viewer.model.is2d()) {
                return null;
            }

            var result = viewer.impl.hitTest(centerX,centerY,false);
            return result ? result.intersectPoint : null;
        };

        var _getCameraPlane = function(pos, nor) {
            var planeNor = nor || pos.clone().sub(_camera.position).normalize();
            return new THREE.Plane(
                planeNor, -planeNor.x*pos.x - planeNor.y*pos.y - planeNor.z*pos.z
            );
        };

        this.zoomWindow = function() {
            var camera = _camera;
            var canvasWidth = viewer.canvas.clientWidth;
            var canvasHeight = viewer.canvas.clientHeight;
            var rectMinX = _mouseStart.x;
            var rectMinY = _mouseStart.y;
            var rectMaxX = _mouseEnd.x;
            var rectMaxY = _mouseEnd.y;

            var rectWidth = Math.abs(rectMaxX - rectMinX);
            var rectHeight = Math.abs(rectMaxY - rectMinY);
            if(rectWidth === 0 || rectHeight ===0) {
                return false;
            }

            _mouseEnd.copy(_mouseStart);

            if (viewer.navigation.getIs2D()) {
                var vpVec = {
                    x:(rectMinX + rectMaxX)*0.5,
                    y:(rectMinY + rectMaxY)*0.5
                };

                // Pan to the center of the zoom window first.
                var distance = viewer.navigation.getEyeVector().length();
                var delta = viewer.impl.clientToViewport(vpVec.x, vpVec.y);
                var on = viewer.impl.clientToViewport(canvasWidth/2, canvasHeight/2);
                delta.subVectors(delta, on);
                viewer.navigation.panRelative(delta.x/2, delta.y/2, distance);

                // Get scale
                var scaleX = rectWidth/canvasWidth;
                var scaleY = rectHeight/canvasHeight;
                var scale = scaleX > scaleY?scaleX:scaleY;

                // Dolly
                distance = viewer.navigation.getEyeVector().length();
                var dollyTarget = viewer.navigation.getWorldPoint(0.5, 0.5);
                viewer.navigation.dollyFromPoint(distance*(scale-1), dollyTarget);

                return true;
            }

            // ??? Should pick with rect first but currently LMV doesn't support rectangle selection
            // ??? So, do hit test only
            var hit = false;
            var pivot = null;
            // if pick up nothing, try ray pick
            if(!hit) {
                var rayOri, rayDirection, intersection;
                var centerX = (rectMinX + rectMaxX)*0.5;
                var centerY = (rectMinY + rectMaxY)*0.5;
                var screenRay = this.getScreenRay(centerX, centerY, canvasWidth, canvasHeight, _camera);
                pivot = this.queryMouseRaySceneIntersection(centerX,centerY);
                // if pick up nothing, set pivot as intersection point from ray to project plane.
                if(pivot === null) {
                    pivot = screenRay.rayOrigin.add(screenRay.rayDirection);
                }
            }

            // calculate the basis vectors for the camera frame
            var eye = camera.position.clone();
            var target = camera.target.clone();
            var viewDir = target.clone().sub(eye);
            viewDir.normalize();
            var upDir = camera.up.clone();
            upDir.normalize();

            // calculate z camera translation for pan and zoom
            var scaleFactor = rectWidth/rectHeight > canvasWidth/canvasHeight ? canvasWidth/rectWidth: canvasHeight/rectHeight;
            var distEye2Pivot = pivot.distanceTo(eye);

            var zoomDist = distEye2Pivot * 1/scaleFactor;

            var zoomDir = viewDir.clone().negate().multiplyScalar(zoomDist);
            eye = pivot.clone().add(zoomDir);

            camera.position.set(eye.x,eye.y,eye.z);

            target = pivot.clone();

            var viewDir_copy = target.clone().sub(eye);
            viewDir_copy.normalize();


            camera.target.set(target.x,target.y,target.z);
            camera.dirty = true;

            return true;
        };
    }

    Autodesk.Viewing.Extensions.ZoomWindow.ZoomWindowTool = ZoomWindowTool;
})();

AutodeskNamespace('Autodesk.Viewing.Private.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        avpc = avp.Collaboration;


    function RemoteControllerTool(viewer, client, p2p) {

        var _stick1 = new THREE.Vector2();
        var _stick2 = new THREE.Vector2();
        var _explodeSpeed = 0;
        var _flydir = null;
        var _camera;
        var _viewer = viewer;

        var MOVE_SCALE = 0.02;
        var AUTOMOVE_SCALE = 0.002;
        var LOOK_SCALE = 0.05;
        var EXPLODE_SCALE = 0.01;
        var _modelScale = 1.0;


        var _viewerState;
        var _savepoints = [];
        var _nextsavepoint = 0;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: true,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };

        var initScale = function() {
            if (!viewer.impl.model.is2d()) {
                var size = viewer.impl.model.getData().bbox.size();
                var diagLength = size.length();
                MOVE_SCALE *= diagLength;
                AUTOMOVE_SCALE *= diagLength;
                viewer.removeEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, initScale);
            }
        };

        viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, initScale);


        //viewtx.client.addEventListener("joystick", this.onJoystick);

        this.getNames = function() {
            return ["joystick"];
        };

        this.getName = function() {
            return "joystick";
        };


        this.activate = function(name) {
            client.addEventListener("joystick", onJoystick);
            p2p.addEventListener("joystick", onJoystick);
            _camera = _viewer.navigation.getCamera();

            if (_viewer.model) {
                var box = _viewer.model.getBoundingBox();
                _modelScale = box.size().length() * 0.001;
                _viewerState = new avp.ViewerState(_viewer);
            }
        };

        this.deactivate = function(name) {
            client.removeEventListener("joystick", onJoystick);
            p2p.removeEventListener("joystick", onJoystick);
            _camera = null;
            _viewerState = null;
            _savepoints.length = 0;
        };

        this.update = function(timeStamp) {

            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective)
                viewer.navigation.toPerspective();

            if (_flydir) {
                var automove = _flydir.clone().multiplyScalar(AUTOMOVE_SCALE);
                _camera.position.add(automove);
                _camera.target.add(automove);
            }

            if (_explodeSpeed != 0) {
                var ns = viewer.getExplodeScale() + _explodeSpeed * EXPLODE_SCALE;
                if (ns > 1) ns = 1;
                if (ns < 0) ns = 0;
                viewer.explode(ns);
            }

            if (_stick1.x == 0 && _stick1.y == 0 && _stick2.x == 0 && _stick2.y == 0)
                return !!(_flydir || _explodeSpeed);

            var direction = _camera.target.clone().sub(_camera.position);
            var distance = direction.length();
            direction.multiplyScalar(1.0/distance);
            var right = direction.clone().cross(_camera.up).normalize();

            var forwardMove = direction.clone().multiplyScalar(_stick1.y * MOVE_SCALE);
            _camera.position.add(forwardMove);
            _camera.target.add(forwardMove);


            var strafeMove = right.clone().multiplyScalar(_stick1.x * MOVE_SCALE);
            _camera.position.add(strafeMove);
            _camera.target.add(strafeMove);

            var lookUpDown = new THREE.Quaternion();
            lookUpDown.setFromAxisAngle(right, _stick2.y * LOOK_SCALE);
            var ndir = direction.clone().applyQuaternion(lookUpDown);
            _camera.up.applyQuaternion(lookUpDown);

            var lookLeftRight = new THREE.Quaternion();
            lookLeftRight.setFromAxisAngle(_camera.worldup, -_stick2.x * LOOK_SCALE);
            ndir.applyQuaternion(lookLeftRight);
            _camera.up.applyQuaternion(lookLeftRight);

            ndir.multiplyScalar(distance);
            _camera.target.copy(_camera.position).add(ndir);

            // update automove direction
            if (_flydir)
                _flydir.copy(_camera.target).sub(_camera.position).normalize();

            return true;
        };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};
        this.handleWheelInput = function(delta) { return false; };
        this.handleButtonDown = function(event, button) { return false; };
        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {return false;};
        this.handleGesture = function(event, touches) {return false;};
        this.handleTouchChange = function(event, touches) {return false;};
        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};


        function onJoystick(e) {
            var state = e.data.msg;
            _stick1.x = state.x1;
            _stick1.y = state.y1;
            _stick2.x = state.x2;
            _stick2.y = state.y2;
            _explodeSpeed = state.explode;

            if (state.command) {
                if (state.command == "gohome") {
                    _stick1.x = _stick1.y = 0;
                    _stick2.x = _stick2.y = 0;
                    viewer.navigation.setRequestHomeView(true);
                    viewer.showAll();
                    viewer.impl.selector.clearSelection();
                    viewer.explode(0);
                    _flydir = null;
                }
                else if (state.command == "select") {
                    var res = viewer.impl.hitTestViewport(new THREE.Vector3(0,0,0));

                    if (res) {
                        viewer.impl.selector.toggleSelection(res.dbId, res.model);
                    } else {
                        viewer.impl.selector.clearSelection();
                    }

                }
                else if (state.command == "hide") {
                    var res = viewer.impl.hitTestViewport(new THREE.Vector3(0,0,0));

                    if (res) {
                        viewer.hide(res.dbId);
                    }
                }
                else if (state.command == "fly") {
                    if (!_flydir) {
                        _flydir = _camera.target.clone().sub(_camera.position).normalize();
                    } else {
                        _flydir = null;
                    }
                } else if (state.command == "savepoint") {
                    var state = _viewerState.getState(VIEWER_STATE_FILTER);
                    _savepoints.push(state);
                    alertify.success("Savepoint created.");
                } else if (state.command == "nextsavepoint") {
                    if (_savepoints.length) {
                        if (_nextsavepoint >= _savepoints.length)
                            _nextsavepoint = 0;

                        _viewerState.restoreState(_savepoints[_nextsavepoint++]);
                    }
                }
            }

            //console.log(state);
        };

    };


    //==================================================================================
    //Extension interface

    /** @constructor */
    ave.RemoteControl = function (viewer, options) {
        av.Extension.call(this, viewer, options);

        this.viewer = viewer;
        this.client = avp.MessageClient.GetInstance();
        this.p2p = new avp.P2PClient(this.client);
        this.controllerTool = new RemoteControllerTool(viewer, this.client, this.p2p);
        viewer.toolController.registerTool(this.controllerTool);

    };

    ave.RemoteControl.prototype = Object.create(av.Extension.prototype);
    ave.RemoteControl.prototype.constructor = ave.RemoteControl;


    ave.RemoteControl.prototype.createUI = function() {
        var scope = this;
        var viewer = this.viewer;

        this.controlButton = new avu.Button('toolbar-remoteControlTool');
        this.controlButton.setToolTip('Pair with controller device');
        this.controlButton.onClick = function() {
            if (this.getState() === avu.Button.State.INACTIVE) {
                scope.connect();
                this.setState(avu.Button.State.ACTIVE);
            }
            else {
                scope.disconnect();
                this.setState(avu.Button.State.INACTIVE);
            }
        };

        this.controlButton.setIcon("adsk-icon-game-controller");
        viewer.modelTools.addControl(this.controlButton);

        this.panel = new Autodesk.Viewing.UI.DockingPanel(viewer.container, "remote-panel", "Remote Control");
        this.panel.width = 300;
        this.panel.height = 375;
        this.panel.container.style.width = this.panel.width+"px";
        this.panel.container.style.height = this.panel.height+"px";
        this.panel.container.style.top = (window.innerHeight-this.panel.height)/2 + "px";
        this.panel.container.style.left = (window.innerWidth-this.panel.width)/2 + "px";
        this.panel.body = document.createElement("div");
        this.panel.body.classList.add("body");
        this.panel.container.appendChild(this.panel.body);
        var text1 = Autodesk.Viewing.i18n.translate("Go to this link");
        var text2 = Autodesk.Viewing.i18n.translate("Scan the QR code with your device");
        var text3 = Autodesk.Viewing.i18n.translate("or");
        this.panel.body.innerHTML = [
            '<p data-i18n="' + text1 + '">' + text1 + '</p>',
            '<p><a class="url" target="_blank" href="#">Link</a></p>',
            '<p data-i18n="'+ text3 +'">' + text3 + '</p>',
            '<p data-i18n="' + text2 + '">' + text2 + '</p>',
            '<img class="qr-img" src="">',
        ].join("\n");
        this.panel.link = this.panel.container.querySelector(".url");
        this.panel.code = this.panel.container.querySelector(".code");
        this.panel.qrImg = this.panel.container.querySelector(".qr-img");
    };

    ave.RemoteControl.prototype.load = function () {
        var viewer = this.viewer;
        var scope = this;

        // add the button to the toolbar
        if(viewer.modelTools && viewer.modelTools.getNumberOfControls() > 0) {
            scope.createUI();
        } else {
            viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        }

        function onToolbarCreated(e) {
            viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            scope.createUI();
        }

        return true;
    };

    ave.RemoteControl.prototype.unload = function () {

        var viewer = this.viewer;

        this.p2p.hangup();
        this.client.disconnect();

        viewer.toolController.deactivateTool(this.controllerTool.getName());

        if (this.panel) {
            this.panel.setVisible(false);
            this.panel = null;
        }

        // TODO_HACK: Find out why removing the button fails
        if (this.controlButton) {
            try {
                viewer.modelTools.removeControl(this.controlButton);
                this.controlButton = null;
            } catch (err) {
                avp.logger.error('RemoteControlReceiver - Failed to remove controlButton');
                this.controlButton = null;
            }
        }

        return true;
    };

    ave.RemoteControl.prototype.addCrosshair = function() {
        this.crosshair = avp.stringToDOM('<div id="remote-crosshair"><div class="crosshair-v"></div><div class="crosshair-h"></div></div>');
        this.viewer.canvasWrap.appendChild(this.crosshair);
    };

    ave.RemoteControl.prototype.removeCrosshair = function() {
        if (this.crosshair) this.crosshair.remove();
    };

    ave.RemoteControl.prototype.connect = function(cb) {
        if (this.client.isConnected()) {
            console.log("RemoteControl already connected");
            return;
        }

        var scope = this;
        avp.loadDependency("lmv_io", "socket.io-1.3.5.js", function(){
            scope.connectAux(cb);
        });
    };

    ave.RemoteControl.prototype.connectAux = function(cb) {
        var scope = this;
        var viewer = this.viewer;
        scope.client.addEventListener("connectSucceeded", function(e) {
            avp.logger.log("connect succeeded");
            var sessionId = e.data.id + "rc";
            scope.client.join(sessionId);

            var rcURL = (LMV_RESOURCE_ROOT.length ? LMV_RESOURCE_ROOT : window.location.origin + "/") + "rc.html?sessionId=" + sessionId + "&env=" + avp.env;

            var qrImgURL = "http://chart.googleapis.com/chart?cht=qr&chs=200x200&choe=UTF-8&chld=H|0&chl=" + escape(rcURL);

            var panel = scope.panel;
            if (panel) {
                panel.link.href = rcURL;
                panel.link.innerHTML = (LMV_RESOURCE_ROOT.length ? LMV_RESOURCE_ROOT : window.location.origin + "/") + "rc.html";
                panel.qrImg.src = qrImgURL;
                panel.setVisible(true);
            }

            function popupRemover() {
                if (panel) panel.setVisible(false);
                scope.p2p.removeEventListener("dataChannelAdded", popupRemover);
                scope.addCrosshair();
            }
            scope.p2p.addEventListener("dataChannelAdded", popupRemover);

            if (cb && cb instanceof Function)
                cb(rcURL);
        });

        viewer.navigation.toPerspective();
        scope.client.connect();

        viewer.toolController.activateTool(scope.controllerTool.getName());
    };

    ave.RemoteControl.prototype.disconnect = function() {
        this.p2p.hangup();
        this.client.disconnect();
        this.viewer.toolController.deactivateTool(this.controllerTool.getName());
        this.removeCrosshair();
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.RemoteControl', ave.RemoteControl);



})();

(function(){

AutodeskNamespace('Autodesk.Viewing.Extensions.GamepadModule');

/***
* GamepadModule is a tool (not an extension) that reacts to input from
* a gamepad controller plugged into the hosting machine.
 *
* @param viewerapi
* @constructor
*/
Autodesk.Viewing.Extensions.GamepadModule = function ( viewerapi ) {

    var avp = Autodesk.Viewing.Private;

    var _navapi = viewerapi.navigation;
    var _container = viewerapi.container;
    var _camera = _navapi.getCamera();

    var _modelScaleFactor = 1.0;

    var _explodeSpeed = 0;

    var _THRESHOLD = 0.1;
    var _SPEED_ADJUST = 5.5,
        _INITIAL_SPEED_SCALAR = 6,
        _speed_scalar = _INITIAL_SPEED_SCALAR;


    var _btnPressMap = {};
    var _gamepad;
    var _hudMessageStartShowTime;
    var _hudMessageShowTime;
    var _viewerState;
    var _savepoints;
    var _nextsavepoint;

    //Nav mode toggle
    var _lockInPlane;

    var _clock = new THREE.Clock(true);

    var VIEWER_STATE_FILTER = {
        seedURN: false,
        objectSet: true,
        viewport: true,
        renderOptions: {
            environment: false,
            ambientOcclusion: false,
            toneMap: {
                exposure: false
            },
            appearance: false
        }
    };
    var _actualMoveSpeed;
    var _movementSpeed = 2.0;
    var _INITIAL_FOV = 75;
    var _ZOOM_SCALAR = -45;//smaller => closer zoom
    var _altitudeLockCoord;
    var _currentTool;

    /*Face Buttons*/
    var _BUTTONS = {
        SOUTH_BTN : 0,
        EAST_BTN : 1,
        WEST_BTN : 2,
        NORTH_BTN : 3,

        /*Shoulder and trigger buttons*/
        LEFT_SHOULDER : 4,
        RIGHT_SHOULDER : 5,
        LEFT_TRIGGER : 6,//ANALOG
        RIGHT_TRIGGER : 7,//ANALOG

        /*directional pad (DPad)*/
        SOUTH_DPAD : 13,
        EAST_DPAD : 15,
        WEST_DPAD : 14,
        NORTH_DPAD : 12,

        /*Joystick buttons (press joystick in)*/
        LEFT_STICK_BUTTON: 10,
        RIGHT_STICK_BUTTON: 11

    };

    var _STICKS = {
        //Axis//
        /*Left and right joysticks*/
        LEFT_STICK_X : 0,//ANALOG
        LEFT_STICK_Y : 1,//ANALOG
        RIGHT_STICK_X : 2,//ANALOG
        RIGHT_STICK_Y : 3//ANALOG
    };

    var _BLANK_FUNC = function() {};
    var _BUTTON_MAPPING = {};
    for (var k in _BUTTONS) {
        if(_BUTTONS.hasOwnProperty(k))
            _BUTTON_MAPPING[_BUTTONS[k]] = _BLANK_FUNC;
    }

    var init = function() {

    };

    this.activate = function (toolName) {
        // Calculate a movement scale factor based on the model bounds.
        var boundsSize = viewerapi.model.getBoundingBox().size();
        _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x, boundsSize.y), boundsSize.z) / 10.0, 0.0001);
        _gamepad = navigator.getGamepads()[0];
        _viewerState = new Autodesk.Viewing.Private.ViewerState(viewerapi);
        _savepoints = [];
        _nextsavepoint = 0;
        _currentTool = toolName;
        setMapping(toolName);
    };

    this.deactivate = function(){
        //console.log("DEACTIVATE");
        _currentTool = null;
        _viewerState = null;
    };

    this.update = function (delta, camera) {

        if(camera)
            _camera = camera;
        delta = _clock.getDelta();

        //poll for gamepad connection
        _gamepad = navigator.getGamepads()[0];

        if (_hudMessageStartShowTime > -1) {
            var curTime = new Date().getTime();
            if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) { // seconds
                hideHUD();
            }
        }

        if(_gamepad) {
            _actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * _speed_scalar;// (_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value > _THRESHOLD ? _SPEED_ADJUST * _gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value + _MAX_SPEED_SCALAR : _MAX_SPEED_SCALAR);
            // From the Collaboration extension:
            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective) {
                //console.log("Lost perspective mode: resetting view.");
                _navapi.toPerspective();
            }
            if (_gamepad) {//TODO test for connection (change of state?)
                if (inputDetected()) {//need to update camera scene
                   // console.log("needs update");
                    _camera.dirty = true;
                    if (_lockInPlane) {
                        _altitudeLockCoord = _camera.position.z;
                    }

                    var direction = _camera.target.clone().sub(_camera.position);
                    var distance = direction.length();
                    direction.multiplyScalar(1.0 / distance);
                    var right = direction.clone().cross(_camera.up).normalize();
                    if (Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_Y]) > _THRESHOLD) {
                        var forwardMove = direction.clone().multiplyScalar(-_gamepad.axes[_STICKS.LEFT_STICK_Y] * _actualMoveSpeed);
                        _camera.position.add(forwardMove);
                        _camera.target.add(forwardMove);
                    }

                    if (Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_X]) > _THRESHOLD) {
                        var strafeMove = right.clone().multiplyScalar(_gamepad.axes[_STICKS.LEFT_STICK_X] * _actualMoveSpeed);
                        _camera.position.add(strafeMove);
                        _camera.target.add(strafeMove);
                    }

                    var lookUpDown = new THREE.Quaternion();
                    var ndir = direction;
                    if (Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_Y]) > _THRESHOLD) {

                        var tempCam = _camera.clone();//modify this camera to see if it will be in viable range
                        var tempDir = direction.clone();

                        lookUpDown.setFromAxisAngle(right, -_gamepad.axes[_STICKS.RIGHT_STICK_Y] * _actualMoveSpeed / 2);//lookscale

                        tempDir.applyQuaternion(lookUpDown);
                        tempCam.up.applyQuaternion(lookUpDown);
                        var vertical = tempCam.worldup.clone();
                        var vertAngle = tempDir.angleTo(vertical);
                        var vertLimit = THREE.Math.degToRad(5);

                        // If new angle is within limits then update values; otherwise ignore
                        if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {
                            ndir = direction.clone().applyQuaternion(lookUpDown);
                            _camera.up.applyQuaternion(lookUpDown);
                        }
                    }

                    var lookLeftRight = new THREE.Quaternion();
                    if (Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_X]) > _THRESHOLD) {
                        lookLeftRight.setFromAxisAngle(_camera.worldup, -_gamepad.axes[_STICKS.RIGHT_STICK_X] * _actualMoveSpeed / 2);//lookscale
                        ndir.applyQuaternion(lookLeftRight);
                        _camera.up.applyQuaternion(lookLeftRight);
                    }

                    /*HANDLE ALL BUTTON INPUTS*/
                    handleGamepadFaceButtons();
                    /**************************/

                    if (_lockInPlane)
                        _camera.position.z = _altitudeLockCoord;

                    ndir.multiplyScalar(distance);
                    _camera.target.copy(_camera.position).add(ndir);
                }
            }
        }
        return _camera;
    };


    // Show a HUD for a specific amount of time (showDelay > 0) or until closed.
    var showHUD = function(messageSpecs, showDelay, closeCB, buttonCB, checkboxCB)
    {
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCB, buttonCB, checkboxCB);

        if (showDelay > 0) {
            _hudMessageStartShowTime = new Date().getTime();
            _hudMessageShowTime = showDelay;
        }
        else {
            _hudMessageStartShowTime = -1;
            _hudMessageShowTime = 0;
        }
    };

    var hideHUD = function()
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        _hudMessageStartShowTime = -1;
    };

    var showDPadHud = function(direction)
    {
        hideHUD();
        var message;
        switch(direction) {
            case "up":
                message = _lockInPlane ? "Vertical Lock Mode" : "Fly mode"; break;
            case "left":
                break;
            case "right":
                break;
            case "down":
                break;
        }

        var messageSpecs = {
            "msgTitleKey"   : "View Orientation Drag Mode Toggled",
            "messageKey"    : "View Orientation Drag Mode Toggled",
            "messageDefaultValue"  : message

        };
        showHUD(messageSpecs, 2000);//show hud for 2secs

    };

    //checks for any button doing anything important
    function inputDetected(){
        //check to see if we pressed a button last frame
        //loop through mapping to only check buttons we care about
        for (var btn in _BUTTON_MAPPING) {
            if (_BUTTON_MAPPING.hasOwnProperty(btn)) {
                if(_gamepad.buttons[btn].pressed){
                    if(_gamepad.buttons[btn].value != 0.5) {
                        _btnPressMap[btn] = true;//its pressed!
                        return true;
                    }
                }
            }
        }
        for (var btn in _btnPressMap) {
            if (_btnPressMap.hasOwnProperty(btn)) {
                if(_btnPressMap[btn]){
                    //_btnPressMap[btn] = false;//
                    return true;
                }
            }
        }
        //now check movement
        return !(Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_X]) < _THRESHOLD &&
                Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_Y]) < _THRESHOLD &&
                Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_X]) < _THRESHOLD &&
                Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_Y]) < _THRESHOLD);

    }

    /*
    will check face buttons (including Directional Pad) for input
     */
    function handleGamepadFaceButtons(){
        for(var btn in _BUTTONS){
            if(_BUTTONS.hasOwnProperty(btn)){
                handleGamepadButton(_BUTTONS[btn]);
            }
        }
    }

    function handleGamepadButton(buttonIdx) {
        //buttons in first IF are testing for being held (good for analog inputs and held down buttons)
        //ELSE IF will activate upon RELEASE of a button
        if (_gamepad.buttons[buttonIdx].value > _THRESHOLD) {
            _btnPressMap[buttonIdx] = true;//set was_pressed
            switch (buttonIdx) {
                case _BUTTONS.LEFT_SHOULDER:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.RIGHT_SHOULDER:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.LEFT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.LEFT_TRIGGER].value); break;
                case _BUTTONS.RIGHT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value); break;
            }
        }
        //ON RELEASE
        else if (_btnPressMap[buttonIdx]) {
            _btnPressMap[buttonIdx] = false;
            switch (buttonIdx) {
                case _BUTTONS.SOUTH_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.EAST_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.WEST_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.NORTH_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.NORTH_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.SOUTH_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.WEST_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.EAST_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.RIGHT_STICK_BUTTON:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.LEFT_STICK_BUTTON:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.LEFT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.LEFT_TRIGGER].value); break;
                case _BUTTONS.RIGHT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value); break;
            }
        }
    }

    var setMapping = function(mapping){
        switch(mapping) {
            case "headtracker":
                _BUTTON_MAPPING[_BUTTONS.SOUTH_BTN] = selectObject;
                _BUTTON_MAPPING[_BUTTONS.SOUTH_DPAD] = goHome;
                _BUTTON_MAPPING[_BUTTONS.NORTH_DPAD] = toggleNavMode;
                _BUTTON_MAPPING[_BUTTONS.WEST_BTN] = hideObject;
                _BUTTON_MAPPING[_BUTTONS.LEFT_SHOULDER] = decAltitude;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_SHOULDER] = incAltitude;
                _BUTTON_MAPPING[_BUTTONS.LEFT_TRIGGER] = explode;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_TRIGGER] = fineSpeedAdjust;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_STICK_BUTTON] = deselectAll;
                _BUTTON_MAPPING[_BUTTONS.LEFT_STICK_BUTTON] = unhideAll;
                break;
            default:
                _BUTTON_MAPPING[_BUTTONS.SOUTH_BTN] = selectObject;
                _BUTTON_MAPPING[_BUTTONS.EAST_BTN] = createSavePoint;
                _BUTTON_MAPPING[_BUTTONS.WEST_BTN] = hideObject;
                _BUTTON_MAPPING[_BUTTONS.NORTH_BTN] = showPropertyPanel;
                _BUTTON_MAPPING[_BUTTONS.SOUTH_DPAD] = goHome;
                _BUTTON_MAPPING[_BUTTONS.WEST_DPAD] = previousSavePoint;
                _BUTTON_MAPPING[_BUTTONS.EAST_DPAD] = nextSavePoint;
                _BUTTON_MAPPING[_BUTTONS.NORTH_DPAD] = toggleNavMode;
                _BUTTON_MAPPING[_BUTTONS.LEFT_SHOULDER] = decAltitude;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_SHOULDER] = incAltitude;
                _BUTTON_MAPPING[_BUTTONS.LEFT_TRIGGER] = triggerZoom;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_TRIGGER] = fineSpeedAdjust;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_STICK_BUTTON] = deselectAll;
                _BUTTON_MAPPING[_BUTTONS.LEFT_STICK_BUTTON] = unhideAll;
                break;
        }
    };

    //things buttons can do below
    var goHome = function(){
        viewerapi.navigation.setRequestHomeView(true);
        viewerapi.showAll();
        viewerapi.impl.selector.clearSelection();
        viewerapi.explode(0);
    };

    //Shoulder buttons and triggers
    var decAltitude = function() {
        if (_lockInPlane)
            _altitudeLockCoord += (-_gamepad.buttons[_BUTTONS.LEFT_SHOULDER].pressed) * _actualMoveSpeed;
        else
            _camera.translateY(-_gamepad.buttons[_BUTTONS.LEFT_SHOULDER].pressed * _actualMoveSpeed);
    };

    var incAltitude = function() {
        if (_lockInPlane)
            _altitudeLockCoord += (_gamepad.buttons[_BUTTONS.RIGHT_SHOULDER].pressed) * _actualMoveSpeed;
        else
            _camera.translateY(_gamepad.buttons[_BUTTONS.RIGHT_SHOULDER].pressed * _actualMoveSpeed);
    };

    var explode = function(analog_value){
        if (analog_value > _THRESHOLD) {
            if (analog_value == 0.5) {//not set yet
                viewerapi.explode(0);
                return;
            }
            _explodeSpeed = analog_value;
            var ns = _explodeSpeed;
            if (ns > 1) ns = 1;
            if (ns < 0) ns = 0;
            viewerapi.explode(ns);
        }
        else
            viewerapi.explode(0);
    };


    //Triggers are analog, so pass in value of trigger
    var triggerZoom = function(analog_value){
        if (analog_value > _THRESHOLD) {
            if(analog_value == 0.5) {
                _camera.fov = _INITIAL_FOV;
                _btnPressMap[_BUTTONS.LEFT_TRIGGER] = false;
                return;
            }
            //linear interp: y = -40x + 75
            ///75 is original fov angle. smaller slope = greater max zoom.
            // equation will interpolate between based on trigger pressure (analog)
            _camera.fov = _ZOOM_SCALAR * analog_value + _INITIAL_FOV;
        }
        else {
            _camera.fov = _INITIAL_FOV;//originally 75
        }
    };

    var fineSpeedAdjust = function(analog_value){
        if(analog_value > _THRESHOLD){
            if(analog_value == 0.5) {//ignore
                //TODO set speed correctly before input received AND have whole speedadjust down here!!
                _btnPressMap[_BUTTONS.RIGHT_TRIGGER] = false;
                return;
            }
            _speed_scalar = -(_SPEED_ADJUST * analog_value) + _INITIAL_SPEED_SCALAR;
        }
        else{
            _speed_scalar = _INITIAL_SPEED_SCALAR;
        }

    };

    var createSavePoint = function(){
        var state = _viewerState.getState(VIEWER_STATE_FILTER);
        _savepoints.push(state);
        avp.logger.log("Savepoint created.");
    };

    var previousSavePoint = function(){
        if (_savepoints.length) {
            _nextsavepoint--;
            if (_nextsavepoint < 0)
                _nextsavepoint = _savepoints.length - 1;
            _viewerState.restoreState(_savepoints[_nextsavepoint]);
        }
    };

    var nextSavePoint = function(){
        if (_savepoints.length) {
            _nextsavepoint++;
            if (_nextsavepoint >= _savepoints.length)
                _nextsavepoint = 0;
            _viewerState.restoreState(_savepoints[_nextsavepoint]);
        }
    };

    var selectObject = function(){
        var res = viewerapi.impl.hitTestViewport(new THREE.Vector3(0, 0, 0));
        if(_currentTool == "headtracker"){
            //vr tool forgets to do this, necessary for center selection
            _camera.updateMatrixWorld();
        }
        if (res) {
            viewerapi.impl.selector.toggleSelection(res.dbId, res.model);
            //viewerapi.fitToView(res.dbId);
        } else {
            viewerapi.impl.selector.clearSelection();
        }
    };

    var deselectAll = function() {
        viewerapi.impl.selector.clearSelection();
    };

    var unhideAll = function() {
        viewerapi.showAll();
        viewerapi.impl.selector.clearSelection();
        viewerapi.explode(0);
    };

    var hideObject = function(){
        var res = viewerapi.impl.hitTestViewport(new THREE.Vector3(0, 0, 0), false);
        if (res) {
            if (res.dbId in viewerapi.getHiddenNodes())
                viewerapi.show(res.dbId);
            else
                viewerapi.hide(res.dbId);
        }
    };

    var showPropertyPanel = function(){
        viewerapi.getPropertyPanel(true).setVisible(!viewerapi.getPropertyPanel(true).isVisible());
    };

    var toggleNavMode = function(){
        _lockInPlane = !_lockInPlane;
        if(_lockInPlane)
            _altitudeLockCoord = _camera.position.z;
        showDPadHud("up");
    };

    init();
};

})(); // closure

'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Section');

/**
 * SectionExtension adds UI elements for section analysis
 */
Autodesk.Viewing.Extensions.Section.SectionExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.viewer = viewer;

};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.constructor = Autodesk.Viewing.Extensions.Section.SectionExtension;


/**
 * Registers the SectionTool, hotkeys and event handlers.
 *
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.load = function() {
    var that = this;
    var viewer = this.viewer;

    this.tool = new Autodesk.Viewing.Extensions.Section.SectionTool(viewer);
    viewer.toolController.registerTool(this.tool);
    this.sectionStyle = null;
    this.supportedStyles = ["X", "Y", "Z", "BOX"];

    if (viewer.getToolbar) {
        var toolbar = viewer.getToolbar(true);
        if (toolbar) {
            this.onToolbarCreated();
        } else {
            this.onToolbarCreatedBinded = this.onToolbarCreated.bind(this);
            viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        }
    }

    this.onResetBinded = this.onReset.bind(this);
    viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, this.onResetBinded);

    this.HOTKEYS_ID = "Autodesk.Section.Hotkeys";
    var hotkeys = [{
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return that.enableSectionTool(false);
        }
    }];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, hotkeys);

    return true;
};

/**
 * Unregisters the SectionTool, hotkeys and event handlers.
 *
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    this.destroyUI();

    viewer.removeEventListener(Autodesk.Viewing.RESET_EVENT, this.onResetBinded);
    this.onResetBinded = null;

    if (this.onToolbarCreatedBinded) {
        viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }

    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Whether the section planes are active or not.
 *
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.isActive = function() {
    return this.tool.isActive();
};

/**
 * Toggles activeness of section planes.
 *
 * @returns {boolean} Whether the section plane is active or not.
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.toggle = function() {
    if (this.isActive()) {
        this.enableSectionTool(false);
    } else {
        var style = this.sectionStyle || "X";
        this.setSectionStyle(style, true);
    }
    return this.isActive(); // Need to check for isActive() again.
};

/**
 * Returns the current type of plane that will cut-though the geometry.
 *
 * @returns {null|String} Either "X" or "Y" or "Z" or "BOX" or null.
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.getSectionStyle = function() {
    return this.sectionStyle;
};

/**
 * Sets the Section plane style.
 *
 * @param {String} style - Accepted values are 'X', 'Y', 'Z' and 'BOX' (in Caps)
 * @param {Boolean} [preserveSection] - Whether sending the current style value resets the cut planes.
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.setSectionStyle = function(style, preserveSection) {

    if (this.supportedStyles.indexOf(style) === -1) {
        return false;
    }

    var bActive = this.isActive();
    var bNewStyle = (this.sectionStyle !== style) || !preserveSection;
    this.sectionStyle = style;

    if (bActive && bNewStyle) {
        this.tool.setSection(style);
    }
    else if (!bActive) {
        this.enableSectionTool(true);
        if (bNewStyle) {
            this.tool.setSection(style);
        } else {
            this.tool.attachControl(true);
        }
    }
    return true;
};


/**
 *
 * @param enable
 * @returns {boolean}
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.enableSectionTool = function(enable) {
    var toolController = this.viewer.toolController,
        isActive = this.tool.isActive();

    if (enable && !isActive) {
        toolController.activateTool("section");
        if (this.sectionToolButton) {
            this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        }
        return true;

    } else if (!enable && isActive) {
        toolController.deactivateTool("section");
        if (this.sectionToolButton) {
            this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        }
        return true;
    }
    return false;
};

/**
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.onToolbarCreated = function() {
    if (this.onToolbarCreatedBinded) {
        this.viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }
    this.createUI();
};

/**
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.onReset = function() {
    this.tool.resetSection();
};

/***
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    this.sectionToolButton = new AVU.ComboButton("toolbar-sectionTool");
    this.sectionToolButton.setToolTip('Section analysis');
    this.sectionToolButton.setIcon("adsk-icon-section-analysis");
    this.createSubmenu(this.sectionToolButton);

    // make sure inspect tools is visible
    var toolbar = viewer.getToolbar(false);
    var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);

    // place section tool before reset tool
    if (modelTools) {
        var resetTool = modelTools.getControl("toolbar-resetTool");
        if (resetTool) {
            modelTools.addControl(this.sectionToolButton, {index: modelTools.indexOf(resetTool.getId())});
        } else {
            modelTools.addControl(this.sectionToolButton, {index: 0});
        }
    }
};

/**
 *
 * @param parentButton
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.createSubmenu = function(parentButton)
{
    var that = this;
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    function createNavToggler(button, name) {
        return function() {
            var state = button.getState();
            var enable = function() {
                that.enableSectionTool(true);
                if (button instanceof AVU.ComboButton === false) {
                    that.tool.setSection(name);
                } else {
                    that.tool.attachControl(true);
                }
            };

            if (state === AVU.Button.State.INACTIVE) {
                button.setState(AVU.Button.State.ACTIVE);
                // Long initialization may cause issues on touch enabled devices, make it async
                if (Autodesk.Viewing.isMobileDevice()) {
                    setTimeout(enable, 1);
                } else {
                    enable();
                }
            } else if (state === AVU.Button.State.ACTIVE) {
                button.setState(AVU.Button.State.INACTIVE);
                that.enableSectionTool(false);
            }
            that.sectionStyle = name;
        };
    }

    function updateSectionButtons() {
        var areVectorsEqual = (function () {
            var v = new THREE.Vector3();
            return function(a, b, sqtol) {
                v.subVectors(a, b);
                return v.lengthSq() < sqtol;
            };
        })();

        var unitx = new THREE.Vector3(1, 0, 0);
        var unity = new THREE.Vector3(0, 1, 0);
        var unitz = new THREE.Vector3(0, 0, 1);
        var right = viewer.autocam.getWorldRightVector();
        var up = viewer.autocam.getWorldUpVector();
        var front = viewer.autocam.getWorldFrontVector();

        var tol = 0.0001;
        if (areVectorsEqual(up, unitx, tol)) {
            that.sectionYButton.setIcon("adsk-icon-plane-x");
        } else if (areVectorsEqual(up, unitz, tol)) {
            that.sectionYButton.setIcon("adsk-icon-plane-z");
        } else {
            that.sectionYButton.setIcon("adsk-icon-plane-y");
        }

        if (areVectorsEqual(right, unity, tol)) {
            that.sectionXButton.setIcon("adsk-icon-plane-y");
        } else if (areVectorsEqual(right, unitz, tol)) {
            that.sectionXButton.setIcon("adsk-icon-plane-z");
        } else {
            that.sectionXButton.setIcon("adsk-icon-plane-x");
        }

        if (areVectorsEqual(front, unitx, tol)) {
            that.sectionZButton.setIcon("adsk-icon-plane-x");
        } else if (areVectorsEqual(front, unity, tol)) {
            that.sectionZButton.setIcon("adsk-icon-plane-y");
        } else {
            that.sectionZButton.setIcon("adsk-icon-plane-z");
        }

        viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
    }

    var sectionXButton = this.sectionXButton = new AVU.Button("toolbar-sectionTool-x");
    sectionXButton.setToolTip('Add X plane');
    sectionXButton.setIcon("adsk-icon-plane-x");
    sectionXButton.onClick = createNavToggler(sectionXButton, 'X');
    parentButton.addControl(sectionXButton);

    var sectionYButton = this.sectionYButton = new AVU.Button("toolbar-sectionTool-y");
    sectionYButton.setToolTip('Add Y plane');
    sectionYButton.setIcon("adsk-icon-plane-y");
    sectionYButton.onClick = createNavToggler(sectionYButton, 'Y');
    parentButton.addControl(sectionYButton);

    var sectionZButton = this.sectionZButton = new AVU.Button("toolbar-sectionTool-z");
    sectionZButton.setToolTip('Add Z plane');
    sectionZButton.setIcon("adsk-icon-plane-z");
    sectionZButton.onClick = createNavToggler(sectionZButton, 'Z');
    parentButton.addControl(sectionZButton);

    var sectionBoxButton = this.sectionBoxButton = new AVU.Button("toolbar-sectionTool-box");
    sectionBoxButton.setToolTip('Add box');
    sectionBoxButton.setIcon("adsk-icon-box");
    sectionBoxButton.onClick = createNavToggler(sectionBoxButton, 'BOX');
    parentButton.addControl(sectionBoxButton);

    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
};

/**
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.destroyUI = function()
{
    var viewer = this.viewer;

    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
        if (modelTools && this.sectionToolButton) {
            var inspectSubmenu = modelTools.getControl("toolbar-inspectSubMenu");
            if (inspectSubmenu) {
                inspectSubmenu.removeControl(this.sectionToolButton.getId());
            } else {
                modelTools.removeControl(this.sectionToolButton.getId());
            }
            this.sectionToolButton = null;
        }
    }
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Section', Autodesk.Viewing.Extensions.Section.SectionExtension);

AutodeskNamespace('Autodesk.Viewing.Extensions.Section');


Autodesk.Viewing.Extensions.Section.tintColor = { r: 1, g: 1, b: 0 };
Autodesk.Viewing.Extensions.Section.tintIntensity = 0.2;


/**
 * Tool that provides visual controls for the user to change the cutplane's position and angle.
 * It can (and should) be hooked to [ToolController's registerTool]{@Autodesk.Viewing.ToolController#registerTool}
 *
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer3D instance
 * @param {Object} [options] - This component is not customizable.
 * @constructor
 */
Autodesk.Viewing.Extensions.Section.SectionTool = function(viewer, options)
{
    var _viewer  = viewer.impl;

    var _names = ["section"];
    var _active = false;

    var _isDragging = false;
    var _isPlaneOn = true;

    var _transRotControl;
    var _transControl;
    var _sectionGroups = [];
    var _sectionPlanes = [];
    var _sectionPicker = [];
    var _activeMode = "";
    var _overlayName = "gizmo";
    var _touchType = null;
    var _initialized = false;
    var _visibleAtFirst = true;
    var _outlineIndices = [[0, 1], [1, 3], [3, 2], [2, 0]];
    var AVES = Autodesk.Viewing.Extensions.Section;
    
    init_TransformGizmos();
    init_SectionMesh();

    function initControl() {

        if (_initialized)
            return;

        _transRotControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "transrotate");
        _transRotControl.addEventListener('change', updateViewer);
        _transRotControl.setSnap(Math.PI/2, Math.PI/36); // snap to 90 degs within 5 degs range 

        _transControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "translate");
        _transControl.addEventListener('change', updateViewer);

        // add to overlay scene
        if (_viewer.overlayScenes[_overlayName] === undefined) {
            _viewer.createOverlayScene(_overlayName);
        }
        _viewer.addOverlay(_overlayName, _transRotControl);
        _viewer.addOverlay(_overlayName, _transControl);

        viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
        viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
        viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
        viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);
    
        _initialized = true;
    }

    function deinitControl() {
        
        if (!_initialized)
            return;
    
        _viewer.removeOverlay(_overlayName, _transRotControl);
        _transRotControl.removeEventListener('change', updateViewer);
        _transRotControl = null;
        _viewer.removeOverlay(_overlayName, _transControl);
        _transControl.removeEventListener('change', updateViewer);
        _transControl = null;
        _viewer.removeOverlayScene(_overlayName);

        viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
        viewer.removeEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
        viewer.removeEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
        viewer.removeEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);
        
        _initialized = false;
    }

    function updateViewer() {
        _viewer.invalidate(false, false, true);
    }

    function updateControls() {
        if (_transRotControl) {
            _transRotControl.update();
        }
        if (_transControl) {
            _transControl.update();
        }
    }

    function updateSections() {
        if (_sectionPlanes.length === 1) {
            updatePlaneMeshes(true);
            updateControls();
            updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
        }
    }

    function mix(a, b, val) {
        return a * (1.0 - val) + b * val;
    }
    
    function getDiffuseColor(material) {
       return material.color || new THREE.Color(0xffffff);
    }

    function getSpecularColor(material) {
        return material.specular || new THREE.Color(0xffffff);
    }

    function tintColor(c) {
        var intensity = Autodesk.Viewing.Extensions.Section.tintIntensity;
        var tc = Autodesk.Viewing.Extensions.Section.tintColor;
        c.r = mix(c.r, tc.r, intensity);
        c.g = mix(c.g, tc.g, intensity);
        c.b = mix(c.b, tc.b, intensity);
    }
    
    function updateCapMeshes(plane) {

        init_three_triangulator();
        init_three_intersector();
    

        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);
            
        var section = new THREE.Object3D();
        section.name = "section";
        _viewer.sceneAfter.add(section);
        
        var section3D = new THREE.Object3D();
        section.add(section3D);
        var section2D = new THREE.Object3D();
        section.add(section2D);

        var avp = Autodesk.Viewing.Private;


        var toPlaneCoords = avp.Intersector.makePlaneBasis(plane);
        var fromPaneCoords = new THREE.Matrix4().getInverse(toPlaneCoords);

        var mat2dname = _viewer.matman().create2DMaterial(null, {skipCircles:true, skipEllipticals:true}, false, false);
        var mat2d = _viewer.matman().findMaterial(null, mat2dname);
        mat2d.transparent = true;
        mat2d.depthTest = true;
        mat2d.polygonOffset = true;
        mat2d.polygonOffsetFactor = -1;
        mat2d.polygonOffsetUnits = 0.1;    // 1.0 is usually way too high, see LMV-1072

        var box = new THREE.Box3();

        var worldBox = _viewer.getVisibleBounds(true);   
        
        //some heuristic for line width of the section outline based on model size
        //half a percent of the model size is what we do here.
        var lineWidth = 0.5 * 5e-5 * worldBox.size().length();

        var models = _viewer.modelQueue().getModels();

        models.forEach(function(model) {

            var it = model.getData().instanceTree;
            if (!it)
                return;
            var frags = model.getFragmentList();

            //We have to go node by node and combine the fragments for each node into
            //a single 2D slice polygon.
            it.enumNodeChildren(model.getRootId(), function(dbId) {

                if (it.isNodeHidden(dbId) || it.isNodeOff(dbId)) {
                    return;
                }

                var intersects = [];
                var m;

                //All fragments that belong to the same node make part of the
                //same object so we have to accumulate all their intersections into one list
                it.enumNodeFragments(dbId, function(fragId) {

                    frags.getWorldBounds(fragId, box);
                    if (!avp.Intersector.intersectBoxPlane(plane, box))
                        return;

                    m = frags.getVizmesh(fragId);

                    if (!m.geometry)
                        return;
                    if (m.geometry.is2d || m.geometry.isLines)
                        return;
                    if (!m.material.cutplanes)
                        return;

                    avp.Intersector.intersectMeshPlane(plane, m, intersects);

                 }, false);


                if (intersects.length) {

                    var bbox = new THREE.Box3();
                    avp.Intersector.convertToPlaneCoords(toPlaneCoords, intersects, bbox);

                    //Create the 2D line geometry
                    var vbb = new avp.VertexBufferBuilder(false, 8 * intersects.length);

                    var color = getDiffuseColor(m.material);
                    var r = 0|(color.r * 0.25)*255.5;
                    var g = 0|(color.g * 0.25)*255.5;
                    var b = 0|(color.b * 0.25)*255.5;

                    var c = 0xff000000 | (b<<16) | (g<<8) | r;

                    var cset = new avp.Triangulator.ContourSet(intersects, bbox);
                    cset.snapEdges();
                    cset.sanitizeEdges();
                    cset.stitchContours();

                    for (var j=0; j<cset.contours.length; j++) {

                        var cntr = cset.contours[j];

                        var r = 0|Math.random()*255.5;
                        var g = 0|Math.random()*255.5;
                        var b = 0|Math.random()*255.5;
                        var rc = 0xff000000 | (b<<16) | (g<<8) | r;

                        var isClosed = (cntr[0] === cntr[cntr.length-1]);

                        for (var k=1; k<cntr.length; k++) {
                            var pt1 = cset.pts[cntr[k-1]];
                            var pt2 = cset.pts[cntr[k]];
                            vbb.addSegment(pt1.x, pt1.y, pt2.x, pt2.y, 0, 0.02, /*isClosed ? c : rc*/c, dbId, 0);
                        }

                    }


                    var mdata = { mesh: vbb.toMesh() };

                    avp.BufferGeometryUtils.meshToGeometry(mdata);

                    var bg2d = mdata.geometry;
                    bg2d.streamingDraw = true;
                    bg2d.streamingIndex = true;

                    var mesh2d = new THREE.Mesh(bg2d, mat2d);

                    mesh2d.matrix.copy(fromPaneCoords);
                    mesh2d.matrixAutoUpdate = false;
                    mesh2d.frustumCulled = false;
                    section2D.add(mesh2d);


                    //Create triangulated capping polygon
                    if (true) {

                        //Create the 3D mesh
                        var tin = new avp.Triangulator.TriangulatedSurface(cset);

                        if (tin.indices.length) {

                            var bg = new THREE.BufferGeometry();

                            var pos = new Float32Array(3*tin.pts.length);
                            for (var j=0; j<tin.pts.length; j++) {
                                pos[3*j] = tin.pts[j].x;
                                pos[3*j+1] = tin.pts[j].y;
                                pos[3*j+2] = 0;
                            }
                            bg.addAttribute("position", new THREE.BufferAttribute(pos, 3));

                            var packNormals = m.material.packedNormals;
                            var normal = packNormals ? new Uint16Array(2*tin.pts.length) : new Float32Array(3*tin.pts.length);

                            for (var j=0; j<tin.pts.length; j++) {

                                if (packNormals) {
                                    var pnx = (0/*Math.atan2(0, 0)*/ / Math.PI + 1.0) * 0.5;
                                    var pny = (1.0 + 1.0) * 0.5;

                                    normal[j*2] = (pnx * 65535)|0;
                                    normal[j*2+1] = (pny * 65535)|0;
                                } else {
                                    normal[3*j] = 0;
                                    normal[3*j+1] = 0;
                                    normal[3*j+2] = 1;
                                }
                            }

                            bg.addAttribute("normal", new THREE.BufferAttribute(normal, packNormals ? 2 : 3));
                            if (packNormals) {
                                bg.attributes.normal.bytesPerItem = 2;
                                bg.attributes.normal.normalize = true;
                            }

                            var index = new Uint16Array(tin.indices.length);
                            index.set(tin.indices);

                            bg.addAttribute("index", new THREE.BufferAttribute(index, 1));

                            bg.streamingDraw = true;
                            bg.streamingIndex = true;

                            var mat = _viewer.matman().cloneMaterial(m.material);

                            mat.packedNormals = packNormals;
                            mat.cutplanes = null;
                            mat.side = THREE.FrontSide;
                            mat.depthTest = true;
                            mat.map = null;
                            mat.bumpMap = null;
                            mat.normalMap = null;
                            mat.alphaMap = null;
                            mat.specularMap = null;
                            mat.transparent = false;
                            mat.depthWrite = true;
                            mat.hatchPattern = true;
                            mat.needsUpdate = true;

                            var angle = (m.material.id+2) * Math.PI * 0.125;
                            var tan = Math.tan(angle);
                            mat.hatchParams = new THREE.Vector2(tan, 10.0);
                            mat.hatchTintColor = Autodesk.Viewing.Extensions.Section.tintColor;
                            mat.hatchTintIntensity = Autodesk.Viewing.Extensions.Section.tintIntensity;

                            // If the material is prism, clear all the map definitions.
                            if (mat.prismType != null) {
                                mat.defines = {};
                                mat.defines[mat.prismType.toUpperCase()] = "";
                                if (mat.prismType == "PrismWood") {
                                    mat.defines["NO_UVW"] = "";
                                }
                            }

                            var capmesh = new THREE.Mesh(bg, mat);
                            capmesh.matrix.copy(fromPaneCoords);
                            capmesh.matrixAutoUpdate = false;
                            capmesh.dbId = dbId;
                            capmesh.fragId = intersects.fragId;

                            section3D.add(capmesh);
                        }

                    }

                }


            }, true); //enumNodeChildren

        }); //models.forEach

    }

    function createPlaneMesh(plane, bbox) {
        var quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), plane.normal);
        var geometry;

        if (bbox) {
            // project bbox to set plane size
            var ptMax = plane.projectPoint(bbox.max);
            var ptMin = plane.projectPoint(bbox.min);
            var invQuat = quat.clone().inverse();
            ptMax.applyQuaternion(invQuat);
            ptMin.applyQuaternion(invQuat);
            var size = new THREE.Vector3().subVectors(ptMax, ptMin);
            geometry = new THREE.PlaneBufferGeometry(size.x, size.y);
        } else {
            // project bounding sphere
            bbox = _viewer.getVisibleBounds();
            var size = 2.0 * bbox.getBoundingSphere().radius;
            geometry = new THREE.PlaneBufferGeometry(size, size);
        }

        var material = new THREE.MeshBasicMaterial({
            opacity: 0,
            color: 0xffffff,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });

        var mesh = new AVES.SectionMesh(geometry, material, plane);
        var pt = plane.projectPoint(bbox.center());       
        mesh.position.copy(pt);
        mesh.quaternion.multiply(quat);

        // add outlines with inverted background color
        var bgColor = Autodesk.Viewing.Private.LightPresets[_viewer.currentLightPreset()].bgColorGradient;
        var color = "rgb(" + (255-bgColor[0]) + "," + (255-bgColor[1]) + "," + (255-bgColor[2]) + ")";
        var lineMaterial = new THREE.LineBasicMaterial({color: color, linewidth:1, depthTest: false});
        var pos = mesh.geometry.getAttribute('position');
        for (var i = 0; i < _outlineIndices.length; i++) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize),
                                   new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize));
            var line = new THREE.Line(geometry, lineMaterial);
            mesh.add(line);
            mesh.outlines.push(line);
        }

        return mesh;
    }

    function updatePlaneMeshes(rebuild) {
    
        traverseSections(function(child) {
            if (child instanceof AVES.SectionMesh) {

                if (child.connectivity.length > 0) {
                    // section box
                    var minv = new THREE.Matrix4().getInverse(child.matrixWorld);
                    var pt = new THREE.Vector3();
                    var pos = child.geometry.getAttribute('position');
                    for (var i = 0; i < pos.length / pos.itemSize; i++) {
                        var connect = child.connectivity[i];
                        if (intersectPlanes(child.plane, connect[0], connect[1], pt) !== null) {
                            pt.applyMatrix4(minv);
                            pos.setXYZ(i, pt.x, pt.y, pt.z);
                        }
                    };
                    pos.needsUpdate = true;
                    child.geometry.computeBoundingBox();
                    child.geometry.computeBoundingSphere();

                    for (var i = 0; i < child.outlines.length; i++) {
                        var line = child.outlines[i];
                        line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
                        line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
                        line.geometry.verticesNeedUpdate = true;
                    }
                } else {
                    // section plane
                    if (rebuild) {
                        var bbox = _viewer.getVisibleBounds();
                        var size = 2.0 * bbox.getBoundingSphere().radius;
                        var pt = child.plane.projectPoint(bbox.center());
                        child.geometry = new THREE.PlaneBufferGeometry(size, size);
                        child.position.copy(pt);
                        var pos = child.geometry.getAttribute('position');
                        for (var i = 0; i < child.outlines.length; i++) {
                            var line = child.outlines[i];
                            line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
                            line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
                            line.geometry.verticesNeedUpdate = true;
                        }
                    }
                }
            }
        });
    }

    function traverseSections(callback) {
        for (var i = 0; i < _sectionGroups.length; i++) {           
            _sectionGroups[i].traverse(callback);
        }
    }

    function setSectionPlanes() {
        traverseSections(function(child) {
            if (child instanceof AVES.SectionMesh) {
                child.update();
            }
        });
        if (_sectionPlanes.length === 1) {
            updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
        }
        _viewer.setCutPlanes(_sectionPlanes);
    }

    function showPlane(set) {
        for (var i = 0; i < _sectionGroups.length; i++) {
            _sectionGroups[i].visible = set;
        }
        
        if (_isPlaneOn !== set)
            updateViewer();

        _isPlaneOn = set;
    }

    function showSection(set) {
        if (set && _sectionPlanes.length > 0) {
            if (_sectionPlanes.length === 1) {
                updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
            }
            viewer.setCutPlanes(_sectionPlanes);
        }
        showPlane(set);
    }

    function attachControl(control, mesh) {
        control.attach(mesh);
        control.setPosition(mesh.position);
        control.visible = true;
    }

    function setPlane(normal) {
        // flip normal if facing inward as eye direction
        var eyeVec = _viewer.api.navigation.getEyeVector();
        if (eyeVec.dot(normal) > 0) {
            normal.negate();
        }
        var group = new THREE.Group();
        var plane = new THREE.Plane(normal, 0);
        var mesh = createPlaneMesh(plane, null);
        group.add(mesh);
        _sectionPlanes.push(mesh.planeVec);
        _sectionGroups.push(group);
        _viewer.addOverlay(_overlayName, group);
        attachControl(_transRotControl, mesh);
        _transRotControl.showRotationGizmos(true);
        _sectionPicker = _transRotControl.getPicker();
        setSectionPlanes();
    }

    function setBox() {
        var normals = [
            new THREE.Vector3(1, 0, 0), 
            new THREE.Vector3(0, 1, 0), 
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, -1, 0),
            new THREE.Vector3(0, 0, -1)
        ];

        var connectivities = [
            [[1, 2], [1, 5], [2, 4], [4, 5]], // 0
            [[3, 5], [0, 5], [2, 3], [0, 2]], // 1
            [[1, 3], [0, 1], [3, 4], [0, 4]], // 2
            [[1, 5], [1, 2], [4, 5], [2, 4]], // 3
            [[2, 3], [0, 2], [3, 5], [0, 5]], // 4
            [[0, 1], [3, 1], [0, 4], [3, 4]]  // 5
        ];

        var group = new THREE.Group();
        var obbox = _viewer.getVisibleBounds();
        var center = obbox.center();
        var bbox = new THREE.Box3(obbox.min, center);
        var planes = [], meshes = [];
        for (var i = 0; i < normals.length; i++) {
            var plane = new THREE.Plane(normals[i], -1 * center.dot(normals[i]));
            planes.push(plane);

            // offset plane with negative normal to form an octant
            if (i > 2) {
                var ptMax = plane.orthoPoint(bbox.max);
                var ptMin = plane.orthoPoint(bbox.min);
                var size = new THREE.Vector3().subVectors(ptMax, ptMin);
                plane.constant -= size.length();                
            }

            var mesh = createPlaneMesh(plane, bbox);
            group.add(mesh);
            meshes.push(mesh);
            _sectionPlanes.push(mesh.planeVec);
        }

        // build connectivity
        for (var i = 0; i < meshes.length; i++) {
            var mesh = meshes[i];
            var connectivity = connectivities[i];
            for (var j = 0; j < connectivity.length; j++) {
                var nc = [];
                var ct = connectivity[j];
                for (var k = 0; k < ct.length; k++) {
                    nc.push(planes[ct[k]]);
                }
                mesh.connectivity.push(nc);
            }
        }
        
        _sectionGroups.push(group);
        _viewer.addOverlay(_overlayName, group);

        attachControl(_transRotControl, _sectionGroups[0].children[0]);
        attachControl(_transControl, _sectionGroups[0]);
        _transRotControl.showRotationGizmos(false);
        _sectionPicker = _transRotControl.getPicker().concat(_transControl.getPicker());

        setSectionPlanes();
    }

    var intersectPlanes = (function () {
        var m = new THREE.Matrix3();
        var n23 = new THREE.Vector3();
        var n31 = new THREE.Vector3();
        var n12 = new THREE.Vector3();
        return function(plane1, plane2, plane3, optionalTarget) {
            m.set(plane1.normal.x, plane1.normal.y, plane1.normal.z,
                  plane2.normal.x, plane2.normal.y, plane2.normal.z,
                  plane3.normal.x, plane3.normal.y, plane3.normal.z);
            
            var det = m.determinant();
            if (det === 0) return null;

            n23.crossVectors(plane2.normal, plane3.normal).multiplyScalar(-plane1.constant);
            n31.crossVectors(plane3.normal, plane1.normal).multiplyScalar(-plane2.constant);
            n12.crossVectors(plane1.normal, plane2.normal).multiplyScalar(-plane3.constant);

            var result = optionalTarget || new THREE.Vector3();
            return result.copy(n23).add(n31).add(n12).divideScalar(det);
        };
    })();

    var intersectObjects = (function () {
        var pointerVector = new THREE.Vector3();
        var pointerDir = new THREE.Vector3();
        var ray = new THREE.Raycaster();
        var camera = _viewer.camera;

        return function(pointer, objects, recursive) {
            var rect = _viewer.canvas.getBoundingClientRect();
            var x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
            var y = - ((pointer.clientY - rect.top) / rect.height) * 2 + 1;
            
            if (camera.isPerspective) {
                pointerVector.set(x, y, 0.5);
                pointerVector.unproject(camera);
                ray.set(camera.position, pointerVector.sub(camera.position).normalize());
            } else {
                pointerVector.set(x, y, -1);
                pointerVector.unproject(camera);
                pointerDir.set(0, 0, -1);
                ray.set(pointerVector, pointerDir.transformDirection(camera.matrixWorld));
            }

            var intersections = ray.intersectObjects(objects, recursive);
            return intersections[0] ? intersections[0] : null;
        };
    })();

    // public functions

    /**
     * When active, the geometry will be sectioned by the current set cut plane.
     * @returns {boolean}
     */
    this.isActive = function() {
        return _active;
    };

    /**
     * Facilitates the initialization of a cut plane
     *
     * @param {String} name - Either 'X', 'Y', 'Z' or 'BOX'
     */
    this.setSection = function(name) {
        this.clearSection();
        switch (name) {
            case 'X':
                var normal = new THREE.Vector3(1, 0, 0);
                setPlane(normal);
                break;
            case 'Y':
                var normal = new THREE.Vector3(0, 1, 0);
                setPlane(normal);
                break;
            case 'Z':
                var normal = new THREE.Vector3(0, 0, 1);
                setPlane(normal);
                break;
            case 'BOX':
                setBox();
                break;
        }
        _activeMode = name;
    };

    /**
     * Removes any (and all) currently set cut plane(s).
     */
    this.clearSection = function() {

        if (_transRotControl)
            _transRotControl.detach();

        if (_transControl)
            _transControl.detach();

        // remove all sections
        while(_sectionPlanes.length > 0) {
            _sectionPlanes.pop();
        }

        while(_sectionGroups.length > 0) {
            var group = _sectionGroups.pop();
            _viewer.removeOverlay(_overlayName, group);
        }
        
        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);

        _viewer.setCutPlanes();
    };

    this.isPlaneOn = function() {
        return _isPlaneOn;
    };

    this.showPlane = function(set) {
        showPlane(set);
    };

    /**
     * Whether translation and rotation controls are visible or not.
     * @param {Boolean} set
     */
    this.attachControl = function(set) {
        if (set) {
            attachControl(_transRotControl, _sectionGroups[0].children[0]);
            _transRotControl.highlight();
            if (_activeMode === 'BOX')
                attachControl(_transControl, _sectionGroups[0]);
        } else {
            _transRotControl.detach();
            _transControl.detach();
        }
    };

    /**
     * Invokes setSection with the last set of parameters used.
     */
    this.resetSection = function() {
        this.setSection(_activeMode);
    };

    // tool interface

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.register = function() {
    };

    this.deregister = function() {
        this.clearSection();
        deinitControl();
    };

    /**
     * [ToolInterface] Activates the tool
     * @param {String} name - unused
     */
    this.activate = function(name) {

        initControl();

        _active = true;
        _isDragging = false;
        _visibleAtFirst = true;

        // keep only one section all the time per design
        _sectionPlanes = _sectionPlanes || [];

        showSection(true);
    };

    /**
     * [ToolInterface] Deactivates the tool
     * @param {String} name - unused
     */
    this.deactivate = function(name) {
        _active = false;
        _isDragging = false;

        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);


        showSection(false);
        _viewer.setCutPlanes();
        _transRotControl.detach();
        _transControl.detach();
    };

    this.update = function(highResTimestamp) {
        return false;
    };

    this.handleSingleClick = function(event, button) {
        var pointer = event.pointers ? event.pointers[ 0 ] : event;
        var result = intersectObjects(pointer, _sectionGroups[0].children);
        if (result) {
            attachControl(_transRotControl, result.object);
            _transRotControl.highlight();
            updateViewer();
        }

        return false;
    };

    this.handleDoubleClick = function(event, button) {
        return false;
    };

    this.handleSingleTap = function(event) {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function(event) {
        return false;
    };

    this.handleKeyDown = function(event, keyCode) {
        return false;
    };

     this.handleKeyUp = function(event, keyCode) {
        return false;
    };

    this.handleWheelInput = function(delta) {
        return false;
    };

    this.handleButtonDown = function(event, button) {
        _isDragging = true;
        if (_transControl.onPointerDown(event))
            return true;
        return _transRotControl.onPointerDown(event);
    };

    this.handleButtonUp = function(event, button) {
        _isDragging = false;
        if (_transControl.onPointerUp(event)) 
            return true;
        return _transRotControl.onPointerUp(event);
    };

    this.handleMouseMove = function(event) {
        if (_isDragging) {
            if (_transControl.onPointerMove(event) ) {
                setSectionPlanes();
                _transRotControl.update();
                return true;
            }
            if (_transRotControl.onPointerMove(event)) {
                setSectionPlanes();
                updatePlaneMeshes();
                return true;
            }
        }

        if (event.pointerType !== 'touch') {
            var pointer = event.pointers ? event.pointers[ 0 ] : event;
            var result = intersectObjects(pointer, _sectionGroups[0].children);
            if (result) {
                _visibleAtFirst = false;
            }

            // show gizmo + plane when intersecting on non-touch 
            var visible = _visibleAtFirst || (result || intersectObjects(pointer, _sectionPicker, true)) ? true : false;
            _transRotControl.visible = visible;
            _transControl.visible = _transControl.object !== undefined && visible;
            showPlane(visible);
        }

        if (_transControl.onPointerHover(event))
            return true;

        return _transRotControl.onPointerHover(event);
    };

    this.handleGesture = function(event) {
        switch (event.type) {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if (_touchType === "drag") {
                    _touchType = null;
                    return this.handleButtonUp(event, 0);
                }
                return false;
        }
        return false;
    };

    this.handleBlur = function(event) {
        return false;
    };

    this.handleResize = function() {
    };

    this.handlePressHold = function(event) {
        return true;
    };
};

function init_SectionMesh() {

if (Autodesk.Viewing.Extensions.Section.SectionMesh)
    return;

Autodesk.Viewing.Extensions.Section.SectionMesh = function(geometry, material, plane)
{
    THREE.Mesh.call(this, geometry, material, false);

    this.plane = plane;
    this.planeVec = new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
    this.connectivity = [];
    this.outlines = [];
};

Autodesk.Viewing.Extensions.Section.SectionMesh.prototype = Object.create(THREE.Mesh.prototype);
Autodesk.Viewing.Extensions.Section.SectionMesh.prototype.constructor = Autodesk.Viewing.Extensions.Section.SectionMesh;

Autodesk.Viewing.Extensions.Section.SectionMesh.prototype.update = function()
{
    this.plane.normal.set(0, 0, 1);
    this.plane.normal.applyQuaternion(this.quaternion);

    var normal = this.plane.normal;
    var d = -1 * this.getWorldPosition().dot(normal);
    this.planeVec.set(normal.x, normal.y, normal.z, d);
    this.plane.constant = d;
};

}


(function(){ "use strict";

    var namespace = AutodeskNamespace('Autodesk.Viewing.Comments');
    var avp = Autodesk.Viewing.Private;

    function CommentFactory(viewer) {

        this.viewer = viewer;
        this.mappingPromise = null; // Lazy initialization upon first usage.
        this.filter = {
            seedURN: true,
            objectSet: true,
            viewport: true,
            tags: true, // Animation extension uses tags.
            renderOptions: false,
            cutplanes: true
        };
    }

    var proto = CommentFactory.prototype;

    /**
     * Invoked when extension is unloaded
     */
    proto.destroy = function() {
        this.viewer = null;
    };

    /**
     * Creates a comment object that can be posted to the comment end point.
     * @param {Object} [dataBag] - Object bag with optional values
     * @return {Object} a comment object
     */
    proto.createCommentObj = function(dataBag) {
        var commentObj = this.viewer.getState(this.filter);
        this.injectInfo(commentObj, dataBag);
        return commentObj;
    };

    /**
     * Populates comment object with data common
     * @param {Object} commentObj
     * @param {Object} [dataBag] - Object bag with optional values
     */
    proto.injectInfo = function(commentObj, dataBag) {
        commentObj["body"] = dataBag.message || "";
        commentObj["status"] = 'open';
        commentObj["jsonVersion"] = "2.0";
        commentObj["inputSource"] = "Web";
        commentObj["type"] = "geometry";

        // These lines include model's sheet info within the document.
        var geometryItem = this.viewer.model.getDocumentNode();
        if (geometryItem) {
            geometryItem = geometryItem.findParentGeom2Dor3D();
            commentObj["layoutName"] = geometryItem.data.guid;
            commentObj["layoutIndex"] = geometryItem.data.order;
        }

        if (dataBag.point3d) {
            var val = dataBag.point3d;
            if (val instanceof THREE.Vector3) { // Check if we have a THREE.Vector3 value
                val = val.toArray();
            }
            this.pushTag(commentObj, {name: "nodeOffset", value: val});
        }
    };

    /**
     * Checks if a comment belongs to the current loaded model.
     * @param {object} commentObj - The comment to check
     * @returns {boolean} True if comment belongs to the current sheet
     */
    proto.isCommentForCurrentSheet = function(commentObj) {
        var currentSheetItem = this.viewer.model.getDocumentNode();
        if (currentSheetItem) {
            currentSheetItem = currentSheetItem.findParentGeom2Dor3D();
            return currentSheetItem.data.guid === commentObj.layoutName;
        }
        return true; // Assume it is for the current sheet
    };

    /**
     * Checks if a comment belongs to the current loaded model.
     * @param {object} commentObj - The comment to check
     * @returns {object|null} manifest node where the comment belongs, or null.
     */
    proto.getManifestNode = function(commentObj) {
        var geometryItem = this.viewer.model.getDocumentNode();
        if (geometryItem) {
            var root = geometryItem.getRootNode();
            return root.findByGuid(commentObj.layoutName);
        }
        return null;
    };

    /**
     * Comments support "tags", which can be seen as a non-structured key-value pair collection.
     * @param {Object} dbComment
     * @param {Object} tagObject
     */
    proto.pushTag = function(dbComment, tagObject) {
        if (!Array.isArray(dbComment["tags"])) {
            dbComment["tags"] = [];
        }
        dbComment["tags"].push(tagObject);
    };

    /**
     * Returns an object containing the key/value pair for a specified tag key. Null if key not found.
     *
     * @param {Object} dbComment - dbComment to inspect
     * @param {String} tagKey - tag we are looking for.
     * @returns {Object|null} - Object containing the key/value pair for the specified tag-key; null if not found.
     */
    proto.getTag = function(dbComment, tagKey) {
        var tags = dbComment["tags"];
        if (tags && Array.isArray(tags)) {
            for (var i = 0, len = tags.length; i < len; ++i) {
                if (tags[i]["name"] === tagKey) {
                    return tags[i];
                }
            }
        }
        return null;
    };

    /**
     * Returns a value for a specified tag key. Null if key not found.
     *
     * @param {Object} dbComment - dbComment to inspect
     * @param {String} tagKey - tag we are looking for.
     * @param {String} [valueNotFound] - Returned back when key is not found. Defaults to null.
     * @returns {String|null} - String value associated to the tag, or valueNotFound if not found.
     */
    proto.getTagValue = function(dbComment, tagKey, valueNotFound) {
        var tag = this.getTag(dbComment, tagKey);
        if (tag) {
            return tag.value;
        }
        return valueNotFound || null;
    };

    /**
     * Applies transformations to make the commentObj compatible with other
     * offline Autodesk applications (such as Fusion 360).
     *
     * WARNING: Never call this function more than once per commentObj.
     *
     * @param {Object} commentObj
     * @return {promise}
     */
    proto.exportCommentObj = function(commentObj) {
        var self = this;
        return new Promise(function(resolve /*,reject*/){ // This method will not reject()
            self.applyGlobalOffset(commentObj);
            self.getMappingPromise().then(function(mapping){
                self.mapObjectSetLmvToExternal(commentObj, mapping, function onMapObjectSetLmvToExternal(value){
                    resolve(value);
                });
            });
        });
    };

    /**
     * Applies transformations to make the commentObj compatible with LMV.
     * May be required when comment was generated from/for offline Autodesk
     * applications (Such as Fusion 360)
     *
     * WARNING: Never call this function more than once per commentObj.
     *
     * @param commentObj
     * @return {Promise}
     */
    proto.importCommentObj = function(commentObj) {
        // We need to clone the comment object, but only the values that matter.
        // Values that matter are keys within this.filter

        // First make a shallow copy
        var copy = {};
        for (var key in this.filter) {
            if (this.filter.hasOwnProperty(key) && commentObj.hasOwnProperty(key)) {
                copy[key] = commentObj[key];
            }
        }

        // Now deep copy those elements that are used by the filter
        var deepCopy = JSON.parse(JSON.stringify(copy));

        var self = this;
        return new Promise(function(resolve){
            self.getMappingPromise().then(function(mapping){

                // Transform "external" objectSet values into "lmv" ones
                self.mapObjectSetExternalToLmv(deepCopy, mapping);

                // Finally, transform the data before returning it back for restoration.
                self.removeGlobalOffset(deepCopy);
                resolve(deepCopy);
            });
        });
    };

    /////////////////////////////
    //// AUXILIARY FUNCTIONS ////
    /////////////////////////////

    /**
     * To make the Viewer's state associated in the comment compatible with
     * external apps, make sure that LMV's global offset gets removed using
     * this method.
     *
     * WARNING: Call this method only once per created commentObj
     *
     * @param {Object} commentObj - output of createComment() function
     * @returns {boolean} - Transformation applied or not
     */
    proto.applyGlobalOffset = function(commentObj) {
        var globalOffset = this.viewer.model.getData().globalOffset;
        if (globalOffset) { // globalOffset is null for 2d models.

            // viewport
            this.applyOffsetToCamera(commentObj.viewport, globalOffset);

            // nodeOffset
            var keyValuePair = this.getTag(commentObj, "nodeOffset");
            if (keyValuePair) {
                this.applyOffset(keyValuePair["value"], globalOffset);
            }

            // DONE
            return true;
        }
        return false;
    };

    /**
     * When loading an comment object created for/from an external application,
     * this method will apply LMV's globalOffset transformation.

     * WARNING: Call this method only once per commentObj
     *
     * @param {Object} commentObj - output of createComment() function
     * @returns {boolean} - Transformation applied or not
     */
    proto.removeGlobalOffset = function(commentObj) {
        var globalOffset =  this.viewer.model.getData().globalOffset;
        if (globalOffset) {
            var invGlobalOffset = { x: -globalOffset.x, y: -globalOffset.y, z: -globalOffset.z };

            // viewport
            this.applyOffsetToCamera(commentObj.viewport, invGlobalOffset);

            // nodeOffset
            var keyValuePair = this.getTag(commentObj, "nodeOffset");
            if (keyValuePair) {
                this.applyOffset(keyValuePair["value"], invGlobalOffset);
            }

            return true;
        }
        return false;
    };

    /**
     *
     * @param {Object} viewport - viewport aspect of the ViewerState object
     * @param {Object} offset - {x:Number, y:Number, z:Number}
     * @private
     */
    proto.applyOffsetToCamera = function(viewport, offset) {

        if (!viewport || !offset) {
            return;
        }

        this.applyOffset(viewport['eye'], offset);
        this.applyOffset(viewport['target'], offset);
        this.applyOffset(viewport['pivotPoint'], offset);
    };

    /**
     * Applies an offset to a 3d point represented as an Array.<br>
     * Notice that THREE.Vector3 has method toArray().
     *
     * @param {Array} array - Array with 3 Number elements
     * @param {Object} offset - {x:Number, y:Number, z:Number}
     */
    proto.applyOffset = function(array, offset) {
        if (array) {

            // Make sure we are dealing with Numbers coming out of array[x]
            var value0 = Number(array[0]) + offset.x;
            var value1 = Number(array[1]) + offset.y;
            var value2 = Number(array[2]) + offset.z;

            array[0] = (typeof array[0] === "string") ? value0.toString() : value0;
            array[1] = (typeof array[1] === "string") ? value1.toString() : value1;
            array[2] = (typeof array[2] === "string") ? value2.toString() : value2;
        }
    };

    /**
     * Create
     * @param {Object} commentObj
     * @param {Object} mapping
     * @param {Function} resolve
     */
    proto.mapObjectSetLmvToExternal = function(commentObj, mapping, resolve) {
        if (!mapping) {
            resolve(commentObj);
        }

        // Avoid translating ids for 2d sheets (for now)
        if (this.viewer.model.is2d()) {
            resolve(commentObj);
        }

        var objectSetValues = this.getObjectSetElementWithIdType(commentObj.objectSet, 'lmv');
        var dbIds = [].concat(objectSetValues.id)
                      .concat(objectSetValues.hidden)
                      .concat(objectSetValues.isolated);
        uniq_fast(dbIds);

        this.viewer.model.getBulkProperties(dbIds, ['externalId'],
            function onSuccess(results){

                var dbToExternal = {}; // Put results in an associative array:
                results.forEach(function(elem){
                    dbToExternal[elem.dbId] = elem.externalId;
                });

                // Make a copy of the original object:
                var externalObjectSetValues = JSON.parse(JSON.stringify(objectSetValues));
                externalObjectSetValues['idType'] = 'external'; // Signals that we are using externalIds

                // Map them all!
                var mapIdToExternalId = function(dbId) {
                    return dbToExternal[dbId];
                };
                externalObjectSetValues.id = externalObjectSetValues.id.map(mapIdToExternalId);
                externalObjectSetValues.hidden = externalObjectSetValues.hidden.map(mapIdToExternalId);
                externalObjectSetValues.isolated = externalObjectSetValues.isolated.map(mapIdToExternalId);

                // Push copy to objectSet and resolve
                commentObj.objectSet.push(externalObjectSetValues);
                resolve(commentObj);
            },
            function onFailure(){
                // Something failed, ignore and continue
                resolve(commentObj);
            }
        );
    };

    // From Stack overflow
    // Removes duplicate entries.
    function uniq_fast(a) {
        var seen = {};
        var out = [];
        var len = a.length;
        var j = 0;
        for(var i = 0; i < len; i++) {
            var item = a[i];
            if(seen[item] !== 1) {
                seen[item] = 1;
                out[j++] = item;
            }
        }
        return out;
    }

    proto.mapObjectSetExternalToLmv = function(commentObj, idMapping) {
        if (!idMapping) {
            return;
        }

        var objectSetList = commentObj.objectSet;
        var objectSet = this.getObjectSetElementWithIdType(objectSetList, 'lmv');

        // Nothing to do, we already have lmv data values
        if (objectSet) {
            return;
        }

        // Else, no lmv objectSet element. Probably a comment coming from Fusion (or similar).
        // Create objectSet entry in index 0 with lmv values.
        var externalObjectSet = this.getObjectSetElementWithIdType(objectSetList, 'external');
        if (!externalObjectSet) {
            return;
        }

        var mapExternalToDbId = function(externalId) {
            return idMapping[externalId];
        };
        var lmvObjectSet = JSON.parse(JSON.stringify(externalObjectSet));

        // Map external ids back to lmv dbIds
        lmvObjectSet.id = lmvObjectSet.id.map(mapExternalToDbId);
        lmvObjectSet.isolated = lmvObjectSet.isolated.map(mapExternalToDbId);
        lmvObjectSet.hidden = lmvObjectSet.hidden.map(mapExternalToDbId);
        lmvObjectSet.idType = 'lmv';

        // Make sure we pushed it as the first element
        objectSetList.unshift(lmvObjectSet);
    };

    proto.getObjectSetElementWithIdType = function(objectSet, idType) {
        if (!objectSet || !Array.isArray(objectSet)) {
            return null;
        }
        for (var i= 0, len=objectSet.length; i<len; ++i) {
            if (objectSet[i].idType === idType) {
                return objectSet[i];
            }
        }
        return null;
    };

    /**
     * Lazy initialization of mapping and it's Promise.
     *
     * @returns {Promise}
     */
    proto.getMappingPromise = function() {
        if (!this.mappingPromise) {
            var self = this;
            this.mappingPromise = new Promise(
                function fetchMapping(resolve/*, reject*/) {
                    self.viewer.model.getExternalIdMapping(
                        function onSuccess(result){
                            avp.logger.log("[Autodesk.Comment]Successfully fetched external id mapping.");
                            resolve(result);
                        },
                        function onFailure() {
                            avp.logger.error("[Autodesk.Comment]Failed to fetch the external id mapping.");
                            resolve(null);
                        }
                    );
                }
            );
        }
        return this.mappingPromise;
    };

    namespace.CommentFactory = CommentFactory;
})();

(function(){ "use strict";

    var namespace = AutodeskNamespace('Autodesk.Viewing.Comments');
    var avp = Autodesk.Viewing.Private;

    /**
     * Helper class for CommentsExtension which deals with all async ops with endpoints
     * @constructor
     */
    function CommentService(viewer, options, cacheObj) {
        this.viewer = viewer;
        this.cache = cacheObj;
        this.PATH_STORAGE = null;
        this.fakeRequest = null;
        this.init(options);
    }

    var proto = CommentService.prototype;

    namespace.ENV_TABLE = {
        Local : {
            COMMENT       : 'https://developer-dev.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer-dev.api.autodesk.com/oss/v1/'
        },
        Development : {
            COMMENT       : 'https://developer-dev.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer-dev.api.autodesk.com/oss/v1/'
        },
        Staging : {
            COMMENT       : 'https://developer-stg.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer-stg.api.autodesk.com/oss/v1/'
        },
        Production : {
            COMMENT       : 'https://developer.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer.api.autodesk.com/oss/v1/'
        },
        AutodeskDevelopment : {
            COMMENT       : 'https://developer-dev.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer-dev.api.autodesk.com/oss/v1/'
        },
        AutodeskStaging : {
            COMMENT       : 'https://developer-stg.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer-stg.api.autodesk.com/oss/v1/'
        },
        AutodeskProduction : {
            COMMENT       : 'https://developer.api.autodesk.com/comments/v2/',
            OBJECT_STORAGE: 'https://developer.api.autodesk.com/oss/v1/'
        }
    };

    proto.init = function(options) {

        options = options || {};

        // Environment //
        this.env = Autodesk.Viewing.Private.env;
        if (options.fakeServer) {
            this.fakeRequest = new namespace.FakeRequest(options);
        }

        // Token //
        this.token = options.token3leg;

        // End Points //
        var config = namespace.ENV_TABLE[this.env];
        this.COMMENT_SERVICE_URL = config['COMMENT'];
        this.OBJECT_STORAGE_SERVICE_URL = config['OBJECT_STORAGE'];

        // Urn
        var pathStorage = options.urn;
        if (pathStorage) {
            this.setPathStorage(pathStorage);
        } else {
            var viewer = this.viewer;
            var that = this;
            var onModelAvailable = function(){
                var docNode = viewer.model.getDocumentNode();
                if (docNode) {
                    var pathStorage = docNode.urn(true);
                    that.setPathStorage(pathStorage);
                }
            };
            if (viewer.model) {
                onModelAvailable();
            } else {
                // Wait for model to finish loading
                viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, function onGeomLoaded(){
                    viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);
                    onModelAvailable();
                });
            }
        }
    };

    /**
     * Invoked when extension is unloaded
     */
    proto.destroy = function() {
        this.viewer = null;
        this.fakeRequest = null;
    };

    /**
     * Sets the REST endpoint's id which groups comments
     * @param {String} path - This of it as the folder name that contains comments
     */
    proto.setPathStorage = function(path) {
        if (path) {
            // path needs to be base64 string, padded with '=' symbols
            // so that the length is multiple of 4
            var modLen = path.length % 4;
            if (modLen > 0) {
                path = path + '='.repeat(4-modLen);
            }
            this.PATH_STORAGE = path;
        }
    };

    /**
     * Gets all comments from comments endpoint
     *
     * @returns {promise}
     */
    proto.listComments = function () {
        var self = this;
        return new Promise(function(resolve, reject){
            var url = [self.COMMENT_SERVICE_URL, 'resources/', self.PATH_STORAGE].join("");
            var callbacks = getAjaxCallback(function(result){
                var comments = JSON.parse(result);
                self.cache.comments = comments;
                resolve(comments);
            }, reject);
            var xhr = createRequest(self, 'GET', url, 'text/plain', callbacks);
            xhr.send();
        });
    };

    /**
     * Posts a new comment to the comments endpoint
     *
     * @param {Object} commentObj - Comment object to post
     * @returns {promise}
     */
    proto.postComment = function (commentObj) {
        var self = this;
        return new Promise(function(resolve, reject){
            var url = [self.COMMENT_SERVICE_URL, 'resources/', self.PATH_STORAGE].join("");
            var callbacks = getAjaxCallback(resolve, reject);
            var xhr = createRequest(self, 'POST', url, 'text/plain', callbacks);
            xhr.send(JSON.stringify(commentObj));
        });
    };

    /**
     * Posts a reply to an existing comment in the comment endpoint
     *
     * @param {Object} commentObj - Reply Comment object to post (same structure as a new comment)
     * @param {String} parentCommentId - Comment id which is being replied
     * @returns {promise}
     */
    proto.postCommentReply = function(commentObj, parentCommentId) {
        var self = this;
        return new Promise(function(resolve, reject){
            var base64 = window.encodeURIComponent(base64encode(parentCommentId));
            var url = [self.COMMENT_SERVICE_URL, 'resources/', base64].join("");
            var callbacks = getAjaxCallback(resolve, reject);
            var xhr = createRequest(self, 'POST', url, 'text/plain', callbacks);
            xhr.send(JSON.stringify(commentObj));
        });
    };

    /**
     * Deletes a comment from the comment endpoint.
     * Can be used to delete replies as well.
     *
     * @param {String} commentId - Id of the comment to delete
     * @returns {Promise}
     */
    proto.deleteComment = function (commentId) {
        var self = this;
        return new Promise(function(resolve, reject){
            var encodedId = base64encode(commentId);
            var base64 = window.encodeURIComponent(encodedId);
            var url = [self.COMMENT_SERVICE_URL, 'resources/', base64].join("");
            var callbacks = getAjaxCallback(resolve, reject);
            var xhr = createRequest(self, 'DELETE', url, 'text/plain', callbacks);
            xhr.send();
        });
    };

    proto.fetchLocationForNewOssAttachment = function(additionalHeaders, callbacks) {
        var url = [this.COMMENT_SERVICE_URL, 'resources/', this.PATH_STORAGE, '/attachment'].join("");
        var xhr = createRequest(this, 'POST', url, 'application/json', callbacks, "fetchLocationForNewOssAttachment");
        injectHeaders(xhr, additionalHeaders);
        xhr.send();
    };

    proto.getAttachment = function(urn, isBinaryData, additionalHeaders) {
        var self = this;
        return new Promise(function(resolve, reject){
            var dataParts = self.extractOssBucketAndId(urn);
            var url = [self.OBJECT_STORAGE_SERVICE_URL, 'buckets/', dataParts[0], '/objects/', dataParts[1]].join("");
            var callbacks = getAjaxCallback(resolve, reject, isBinaryData);
            var xhr = createRequest(self, 'GET', url, null, callbacks);
            injectHeaders(xhr, additionalHeaders);
            if (isBinaryData) {
                xhr.responseType = 'arraybuffer';
            }
            xhr.send();
        });
    };

    proto.postAttachment = function(objectKey, fileData, bucketId, additionalHeaders, callbacks) {
        var url = [this.OBJECT_STORAGE_SERVICE_URL, 'buckets/', bucketId, '/objects/', objectKey].join("");
        var xhr = createRequest(this, 'PUT', url, 'text/plain', callbacks);
        injectHeaders(xhr, additionalHeaders);
        xhr.send(fileData);
    };

    proto.deleteAttachment = function(objectKey, bucketId, callbacks) {
        var url = [this.OBJECT_STORAGE_SERVICE_URL, 'buckets/', bucketId, '/objects/', objectKey].join("");
        var xhr = createRequest(this, 'DELETE', url, 'text/plain', callbacks);
        xhr.send();
    };

    /**
     * Extracts the bucket id and the attachment id from an OSS URN.
     * @param {String} ossUrn
     * @returns {Array} With values: [ <bucket_id>, <attachment_id> ]
     */
    proto.extractOssBucketAndId = function(ossUrn) {
        var dataParts = ossUrn.split('/'); // Returns 2 array with 2 elements [ <stuff + bucket_id>, <attachment_id> ]
        var bucketId = dataParts[0];            // Something like 'urn:adsk.objects:os.object:comments'
        var tmpArray = bucketId.split(':');     // We need to get 'comments' at the end.
        dataParts[0] = tmpArray[tmpArray.length-1];
        return dataParts;
    };

    proto.getToken = function() {
        return this.token || Autodesk.Viewing.Private.token.accessToken;
    };

    ///////////////////////
    // Private functions //
    ///////////////////////

    /**
     * Creates a request object to communicate with the comments endpoint.
     * May create a fake request for debug purposes if specified in options.
     * Returned value is ready to initiate async operation through it's send() method
     * (it hasn't been called yet)
     *
     * @param {CommentService} instance
     * @param {String} operation - POST, GET, DELETE
     * @param {String} url - REST endpoint
     * @param {String} contentType - Content type header
     * @param {Object} callbacks - {onLoad:Function, onError:Function, onTimeout:Function}
     * @param {String} [callerFunction] - Name of the operation being performed
     * @returns {XMLHttpRequest}
     */
    function createRequest(instance, operation, url, contentType, callbacks, callerFunction) {

        if (instance.fakeRequest) {
            return instance.fakeRequest.createRequest(operation, url, callbacks, callerFunction);
        }

        var token = instance.getToken();

        var xhr = new XMLHttpRequest();
        xhr.open(operation, url, true);
        if(contentType) {
            xhr.setRequestHeader("Content-Type", contentType);
        }
        xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
        xhr.setRequestHeader("Authorization", "Bearer " + token);
        xhr.onload = callbacks.onLoad;
        xhr.onerror = callbacks.onError;
        xhr.ontimeout = callbacks.onTimeout;
        return xhr;
    }

    /**
     * Returns an object compatible with our AJAX callbacks mechanism.
     * Internal usage only.
     *
     * @param {Function} resolve
     * @param {Function} reject
     * @param {Boolean} [isBinaryData] Whether the response is to be binary or not (defaults to not-binary)
     * @returns {{onLoad: Function, onError: Function, onTimeout: Function}}
     */
    function getAjaxCallback(resolve, reject, isBinaryData) {
        return {
            onLoad: function(event) {
                if (event.currentTarget.status == 200) {
                    resolve(isBinaryData ? event.currentTarget.response
                                         : event.currentTarget.responseText);
                } else {
                    reject(event.currentTarget);
                }
            },
            onError: function(event) {
                reject(event.currentTarget);
            },
            onTimeout: function(event) {
                reject(event.currentTarget);
            }
        }
    }

    /**
     * Injects additional RequestHeaders before dispatching the async op to the comment endpoint.
     *
     * @param {XMLHttpRequest} xhr
     * @param {Array} additionalHeaders - Additional headers with items {name:String, value:String}
     */
    function injectHeaders(xhr, additionalHeaders) {
        additionalHeaders && additionalHeaders.forEach(function(headerInfo) {
            xhr.setRequestHeader(headerInfo['name'], headerInfo['value']);
        });
    }

    /**
     * Base64 encode function (btoa) with IE9 support
     * @param {String} str - May contain characters with values beyond ascii
     * @returns {String} ascii-only encoded string
     */
    function base64encode(str) {
        if (window.btoa) {
            return window.btoa(str);
        }
        // IE9 support
        return window.Base64.encode(str);
    }

    // Export //
    namespace.CommentService = CommentService;
})();

(function(){ "use strict";

    var EXTENSION_NAME = 'Autodesk.Comments';
    var namespace = AutodeskNamespace('Autodesk.Viewing.Comments');

    /**
     * Extension that encapsulates commenting functionality.
     *
     * Makes AJAX calls to a commenting endpoint for POST/GET/DELETE comment operations.
     *
     * Default [Comment Service](https://developer.autodesk.com/api/comments/internal/).
     *
     * Notice that most of the exposed functions return a
     * [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) object.
     * This component doesn't force usage of any particular Promise library;
     * developers are free to polyfill it as desired.
     *
     * Comments extension was tested with [es6-promise](https://github.com/jakearchibald/es6-promise)
     * which is included as a build artifact (/es6-promise.js and /es6-promise.min.js).
     *
     * @example
     *      // Load extension
     *      // NOTE: You'll need to apply proper values below.
     *      var loadOptions = {
     *          token3leg: "DKCmo1QIKYGpCywZCjib0wRt9YZi",
     *          urn: "dXJuOmFkc2suY29sdW1idXMuc3RhZ2luZzpmcy5maWxlOmQzNjhjMTdlLWVlMzYtMTFlNC04ZTM5LWRhMTVmYzJhMDc5YT92ZXJzaW9uPTE="
     *      };
     *      viewer.loadExtension("Autodesk.Viewing.Comments", loadOptions);
     *
     *      // Get extension
     *      var extension = viewer.getExtension("Autodesk.Viewing.Comments");
     *
     *      // Get comments from server, restore 1 comment
     *      var promiseGet = extension.getComments();
     *      promiseGet.then(function(arrayOfComments){
     *          var commentCount = arrayOfComments.length;
     *          console.log("Existing comments are: " + commentCount);
     *
     *          if (commentCount) {
     *              // Grab the first one and restore it
     *              var firstComment = arrayOfComments[0];
     *              extension.restoreComment(firstComment);
     *          }
     *      });
     *
     *      // Create comment object
     *      var postData = { message: "This is my optional text" };
     *      var promiseCreate = extension.createComment(postData);
     *      promiseCreate.then(function(lmvComment){
     *          return extension.postComment(lmvComment); // Returns another Promise
     *      }).then(function(postedComment){
     *          console.log("Posted comment is: " + postedComment);
     *      });
     *
     * @constructor
     * @memberof Autodesk.Viewing.Comments
     * @alias Autodesk.Viewing.Comments.CommentsExtension
     * @extends Autodesk.Viewing.Extension
     * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
     * @param {object} options - Dictionary with options.
     * @param {string} [options.url] - Identifier that groups comments together. Default to manifest urn passed to ViewingApplication.
     * @param {string} [options.token3leg] - 3-legged Oauth 2 token used to access comment endpoints. Defaults to token used to access Manifest.
     * @param {boolean} [options.fakeServer] - Debug only. Forces the usage of a local proxy for all async operations with endpoints.
     * @param {number} [options.fakeSeverDelay] - Debug only. Forced delay for fakeServer proxy. Useful to test high/low latency ops.
     * @category Extensions
     * @private
     */
    function CommentsExtension(viewer, options) {
        Autodesk.Viewing.Extension.call(this, viewer, options|| {});

        var _factory, _commentService;

        /**
         *
         * @returns {boolean}
         */
        this.load = function () {

            var cacheObj = this.getCache();

            _factory = new namespace.CommentFactory(this.viewer);
            _commentService = new namespace.CommentService(this.viewer, this.options, cacheObj);

            if (cacheObj.restoreComment) {
                var commentToRestore = cacheObj.restoreComment;
                delete cacheObj.restoreComment;

                var that = this;
                var onModelAvailableFn = function() {
                    var onObjectTreeFn = function(){
                        if (that.isCommentForCurrentSheet(commentToRestore)) {
                            that.restoreComment(commentToRestore);
                        }
                    };
                    that.viewer.getObjectTree(onObjectTreeFn, onObjectTreeFn);
                };

                if (this.viewer.model){
                    onModelAvailableFn();
                } else {
                    this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, function auxGeomLoadedFn(){
                        that.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, auxGeomLoadedFn);
                        onModelAvailableFn();
                    });
                }
            }

            return true;
        };


        /**
         * TODO
         * @returns {boolean}
         */
        this.unload = function() {
            if (_commentService) {
                _commentService.destroy();
                _commentService = null;
            }
            if (_factory) {
                _factory.destroy();
                _factory = null;
            }
            return true;
        };

        /**
         * Creates a comment object that can be posted to the Comment Service endpoint.
         * @example
         * commentExtension.postComment(commentExtension.createComment());
         *
         * @see {@link Autodesk.Viewing.Comments.CommentsExtension#postComment}
         * @see {@link Autodesk.Viewing.Comments.CommentsExtension#restoreComment}
         * @param {object|string} data - Object bag with additional comment values. Or only a String value for the message.
         * @param {array} data.message - Text attached to the comment. Example: "Hi there, this is a comment!".
         * @param {array} data.point3d - Specific 3d point in the geometry (in lmv coordinates). Example [20.5, -5.2, 7.15].
         * @returns {promise}
         */
        this.createComment = function(data) {
            var aux = data || {};
            // First argument can be just the "message" string
            if (typeof data === "string") {
                aux = { message: data };
            }
            var commentObj = _factory.createCommentObj(aux);
            return _factory.exportCommentObj(commentObj);
        };


        /**
         * Checks if a comment belongs to the current loaded model.
         * @param {object} commentObj - The comment to check
         * @returns {boolean} True if comment belongs to the current sheet
         */
        this.isCommentForCurrentSheet = function(commentObj) {
            return _factory.isCommentForCurrentSheet(commentObj);
        };

        /**
         * Wrapper for {@link Autodesk.Viewing.Viewer3D#restoreState}.
         * Works with objects created from {@link Autodesk.Viewing.Viewer3D#createComment}.
         *
         * @param {object} commentObj - The comment object, which is a super set of a valid Viewer State object.
         * @param {object} [filter] - Similar in structure to viewerState used to filter out values.
         * that should not be restored. Passing no filter will restore all values.
         * @param {boolean} [immediate] - Whether the state should be applied with (false)
         * or without (true) a smooth transition. Defaults to false, meaning it uses a transition.
         */
        this.restoreComment = function(commentObj, filter, immediate) {
            if (!this.isCommentForCurrentSheet(commentObj)) {
                var item = _factory.getManifestNode(commentObj);
                if (item) {
                    var cacheObj = this.getCache();
                    cacheObj.restoreComment = commentObj;
                    this.viewer.fireEvent({
                        type: Autodesk.Viewing.LOAD_GEOMETRY_EVENT,
                        data: { item: item.data }
                    });
                    return;
                }
            }

            // This sheet //
            var self = this;
            var prom = _factory.importCommentObj(commentObj);
            prom.then(function(transformed){
                self.viewer.restoreState(transformed, filter, immediate);
            });
        };

        /**
         * Sets the REST endpoint's id which groups comments.
         * There is a default value loaded from viewer's manifest,
         * so don't change it unless you have a good reason to do so.
         * @param {String} path - This of it as the folder name that contains comments
         */
        this.setPathStorage = function(path) {
            if (!path) {
                throw new Error(EXTENSION_NAME + ": Invalid path storage");
            }
            _commentService.setPathStorage(path);
        };

        /**
         * Returns comments already fetched from the Comments Service.
         * @see {@link Autodesk.Viewing.Comments.CommentsExtension#getComments}
         * @returns {array}
         */
        this.comments = function() {
            var cache = this.getCache();
            return cache.comments || [];
        };

        /**
         * Fetches all comments from the Comments Service.
         * Customize comment storage with options.url and access with options.token3leg.
         * @see {@link Autodesk.Viewing.Comments.CommentsExtension#restoreComment}
         * @returns {promise}
         */
        this.getComments = function() {
            return _commentService.listComments();
        };

        /**
         * Post a comment to the Comment Service backend.
         * @see {@link Autodesk.Viewing.Comments.CommentsExtension#createComment}
         * @param {object} comment - Object to post (gets stringified)
         * @returns {promise}
         */
        this.postComment = function(comment) {
            return _commentService.postComment(comment)
        };

        /**
         * Posts a comments reply. A reply has the same structure as the one required when posting comments.
         * @param {object} commentReply - Object to post as a reply (gets stringified).
         * @param {string} parentCommentId - ID of the comment replying to.
         * @returns {promise}
         */
        this.postCommentReply = function(commentReply, parentCommentId) {
            return _commentService.postCommentReply(commentReply, parentCommentId);
        };

        /**
         * Deletes a comment or reply from the Comment Service backend.
         * @param {string} commentId - ID of the comment to remove.
         * @returns {promise}
         */
        this.deleteComment = function(commentId) {
            return _commentService.deleteComment(commentId);
        };

        /**
         * Used to get an OSS location where to post a new attachment.
         *
         * NOTE: The method does not support Promise return value yet.
         * @param {array} additionalHeaders - Additional request headers.
         * @param {object} callbacks - `{onLoad:Function, onError:Function, onTimeout:Function}`.
         * @private
         */
        function fetchLocationForNewOssAttachment(additionalHeaders, callbacks) {
            // TODO: Promisify method //
            return _commentService.fetchLocationForNewOssAttachment(additionalHeaders, callbacks);
        }

        /**
         * Helps extracting information after calling
         * {@link Autodesk.Viewing.Comments.CommentsExtension#fetchLocationForNewOssAttachment}.
         * @param {string} ossUrn - Value returned from fetchLocationForNewOssAttachment().
         * @returns {array} 2 string elements: `[bucket_id, attachment_id]`.
         * @private
         */
        function extractOssBucketAndId(ossUrn) {
            return _commentService.extractOssBucketAndId(ossUrn);
        }

        /**
         * Posts an attachment to the attachments endpoint (OSS v1 by default).
         *
         * Relies on the return value of
         * {@link Autodesk.Viewing.Comments.CommentsExtension#fetchLocationForNewOssAttachment}.
         *
         * Use {@link Autodesk.Viewing.Comments.CommentsExtension#extractOssBucketAndId}
         * to extract data out of it.
         *
         * NOTE: Method does not support Promise return value yet.
         *
         * @param {string} objectKey - Attachment's ID.
         * @param {string|*} fileData - Attachment data to post.
         * @param {string} bucketId - ID of the OSS bucket where to post the attachment.
         * @param {array} additionalHeaders - Additional request headers.
         * @param {object} callbacks - `{onLoad:Function, onError:Function, onTimeout:Function}`.
         * @private
         */
        function postAttachment(objectKey, fileData, bucketId, additionalHeaders, callbacks) {
            // TODO: Promisify method //
            return _commentService.postAttachment(objectKey, fileData, bucketId, additionalHeaders, callbacks);
        }


        /**
         * Initiates an async op to request an attachment from the attachments endpoint (OSS by default).
         * @param {string} urn
         * @param {boolean} isBinary - Whether we are fetching binary data or not.
         * @param {array} additionalHeaders - Additional request headers.
         * @returns {promise}
         * @private
         */
        function getAttachment(urn, isBinary, additionalHeaders) {
            return _commentService.getAttachment(urn, isBinary, additionalHeaders);
        }

    } // Constructor

    CommentsExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
    CommentsExtension.prototype.constructor = CommentsExtension;
    Autodesk.Viewing.theExtensionManager.registerExtension(EXTENSION_NAME, CommentsExtension);
    namespace.CommentsExtension = CommentsExtension;
})();

(function(){ "use strict";

    var namespace = AutodeskNamespace('Autodesk.Viewing.Comments');

    /**
     * Helper class that serves as a debug-proxy for async operations.
     * Useful when in development mode and having trouble accessing endpoints.
     *
     * @param {Object} options
     * @param {Number} [options.fakeSeverDelay] - Forced delay on async callbacks (in milliseconds)
     * @param {String} [options.displayName] - User name posting a comment
     * @param {String} [options.oxygenId] - User's oxygenId when posting a comment
     * @constructor
     */
    function FakeRequest(options) {

        this.options = options || {};
        this.FAKE_SERVER_DELAY = this.options.fakeSeverDelay || 200;
        this.FAKE_NEXT_ID = 11;
    }

    var proto = FakeRequest.prototype;

    proto.createRequest = function(operation, url, callbacks, callerFunction) {

        var self = this;
        var fakeRequest = {
            notifyCallback: function(fakeServerResponse) {
                if (self.FAKE_SERVER_DELAY) {
                    // Fake server response delay
                    setTimeout(function(){
                            callbacks.onLoad( fakeServerResponse );
                        },
                        self.FAKE_SERVER_DELAY);
                }
                else {
                    // invoke callback right away
                    callbacks.onLoad( fakeServerResponse );
                }
            },
            replyPostComment: function(args) {
                var dbComment = JSON.parse(args);
                dbComment.id =  self.FAKE_NEXT_ID++;
                dbComment.index = dbComment.id;
                dbComment.layoutName = dbComment.layoutName || "Another Sheet";
                if (!dbComment.actor) {
                    dbComment.actor = {
                        name: self.options.displayName || "John Doe",
                        id: self.options.oxygenId || 'ABCDEFGHIJK'
                    };
                }
                dbComment.published = new Date().toUTCString();
                this.notifyCallback( { currentTarget: {status: 200, responseText: JSON.stringify(dbComment)} } );
            },
            replyFetchLocationForNewOssAttachment: function() {
                var responseObject = {
                    attachment:[{url:"urn:adsk.objects:os.object:comments/filename"}]
                };
                this.notifyCallback( { currentTarget: {status: 200, responseText: JSON.stringify(responseObject)} } );
            },

            send: function(args) {

                switch(operation) {
                    case 'GET': //listComments
                        this.notifyCallback( { currentTarget: {status: 200, responseText: "[]"} } );
                        break;
                    case 'POST': //postComment or postCommentReply

                        switch(callerFunction) {
                            case "fetchLocationForNewOssAttachment":
                                this.replyFetchLocationForNewOssAttachment();
                                break;
                            default:
                                this.replyPostComment(args);
                                break;
                        }
                        break;

                    case 'DELETE': //deleteComment or deleteCommentReply
                        this.notifyCallback( { currentTarget: {status: 200, responseText: "{}"} } );
                        break;
                    case 'PUT':
                        try {
                            JSON.parse(args);
                            this.notifyCallback( { currentTarget: {status: 200, responseText: args} } );
                        }
                        catch(error) {
                            // send attachmentData
                            var attachmentResponse = {
                                objects:[{id: "test", key: "test", 'content-type': "image/png", location: "http://www.autodesk.com"}]
                            };

                            this.notifyCallback( { currentTarget: {status: 200, responseText: JSON.stringify(attachmentResponse)} } );
                        }
                        break;
                }
            },
            setRequestHeader: function (){}
        };
        return fakeRequest;
    };

    namespace.FakeRequest = FakeRequest;
})();
(function(){ 'use strict';

    var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core.Utils');
    var av = Autodesk.Viewing;

    // Change these constants to alter the default sizes in pixels of strokes and fonts.
    namespace.MARKUP_DEFAULT_STROKE_WIDTH_IN_PIXELS = 5;
    namespace.MARKUP_DEFAULT_FONT_WIDTH_IN_PIXELS = 12;
    namespace.MARKUP_DEFAULT_HITAREAS_MARGIN_IN_PIXELS = 15;

    /**
     * // isTouchDevice is an LMV function. Hammer is included by LMV as well
     * @returns {boolean}
     */
    namespace.isTouchDevice = function() {
        // isTouchDevice() is an LMV function.
        // Hammer (a touch detection lib) is packaged with LMV as well
        if (av.isTouchDevice && typeof Hammer === "function") {
            return av.isTouchDevice();
        }
        return false;
    };

    //// SVG  //////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     *
     * @param type
     * @returns {Element}
     */
    namespace.createSvgElement = function(type) {

        // See https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS
        var namespace = 'http://www.w3.org/2000/svg';
        return  document.createElementNS(namespace, type);
    };

    /**
     *
     * @param {Element} svg - an SVGElement
     * @returns {Element} svg param is returned back
     */
    namespace.setSvgParentAttributes = function(svg) {

        // See: https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course
        svg.setAttribute('version', '1.1'); // Notice that this is the SVG version, not the "MARKUP DATA VERSION"!
        svg.setAttribute('baseProfile', 'full');
        return svg;
    };

    namespace.createMarkupPathSvg = function() {

        var svg = namespace.createSvgElement('g');
        svg.setAttribute('cursor', 'inherit');
        svg.setAttribute('pointer-events', 'none');

        var markup = namespace.createSvgElement('path');
        markup.setAttribute('id', 'markup');

        var hitarea = namespace.createSvgElement('path');
        hitarea.setAttribute('id', 'hitarea');
        hitarea.setAttribute('fill', 'transparent');
        hitarea.setAttribute('stroke', 'transparent');

        svg.markup = markup;
        svg.hitarea = hitarea;

        svg.appendChild(markup);
        svg.appendChild(hitarea);

        return svg;
    };

    namespace.setAttributeToMarkupSvg = function(svg, attribute, value) {

        svg.markup.setAttribute(attribute, value);
    };

    namespace.updateMarkupPathSvgHitarea = function(svg, editor) {

        var markup = svg.markup;
        var hitarea = svg.hitarea;

        var hitareaMargin = editor.sizeFromClientToMarkups(0, namespace.MARKUP_DEFAULT_HITAREAS_MARGIN_IN_PIXELS).y;
        hitareaMargin += parseFloat(markup.getAttribute('stroke-width')) + hitareaMargin;

        var markupFill = markup.getAttribute('fill');
        var markupStroke = markup.getAttribute('stroke');
        var strokeEnabled = markupStroke !== '' && markupStroke !== 'none';
        var fillEnabled = markupFill !== '' && markupFill !== 'none';

        hitarea.setAttribute('d', markup.getAttribute('d'));
        hitarea.setAttribute('stroke-width', hitareaMargin);
        hitarea.setAttribute('transform', markup.getAttribute('transform'));

        if(!editor.navigating) {
            if (strokeEnabled && fillEnabled) {
                svg.setAttribute('pointer-events', 'painted');
                return;
            }

            if (strokeEnabled) {
                svg.setAttribute('pointer-events', 'stroke');
                return;
            }

            if (!fillEnabled) {
                svg.setAttribute('pointer-events', 'fill');
                return;
            }
        }

        svg.setAttribute('pointer-events', 'none');
    };
    
    namespace.createMarkupTextSvg = function() {

        var svg = namespace.createSvgElement('g');
        svg.setAttribute('cursor', 'default');

        var clipperId = 'markup-clipper-' + namespace.getClipPathId();
        var clipperUrl = 'url(#' + clipperId + ')';

        var clipper = namespace.createSvgElement('clipPath');
        clipper.setAttribute('id', clipperId);
        clipper.removeAttribute('pointer-events');
        clipper.rect = namespace.createSvgElement('rect');
        clipper.appendChild(clipper.rect);

        var background = namespace.createSvgElement('rect');
        background.setAttribute('id', 'markup-background');

        var markup = namespace.createSvgElement('text');
        markup.setAttribute('id', 'markup');
        background.removeAttribute('pointer-events');

        var hitarea = namespace.createSvgElement('rect');
        hitarea.setAttribute('id', 'hitarea');
        hitarea.setAttribute('fill', 'transparent');
        hitarea.setAttribute('stroke', 'none');
        hitarea.setAttribute('stroke-width', '0');

        var clippedArea = namespace.createSvgElement('g');
        clippedArea.setAttribute('clip-path', clipperUrl);
        clippedArea.appendChild(clipper);
        clippedArea.appendChild(background);
        clippedArea.appendChild(markup);

        svg.appendChild(clippedArea);
        svg.appendChild(hitarea);

        svg.clipper = clipper;
        svg.background = background;
        svg.markup = markup;
        svg.hitarea = hitarea;

        return svg;
    };

    namespace.setMarkupTextSvgTransform = function(svg, transform, textTransform) {

        svg.clipper.rect.setAttribute('transform', transform);
        svg.background.setAttribute('transform', transform);
        svg.markup.setAttribute('transform', textTransform);
        svg.hitarea.setAttribute('transform', transform);
    };

    namespace.updateMarkupTextSvgHitarea = function(svg, w, h, editor) {

        var hitarea = svg.hitarea;
        var hitareaMargin = editor.sizeFromClientToMarkups(0, namespace.MARKUP_DEFAULT_HITAREAS_MARGIN_IN_PIXELS).y;

        hitarea.setAttribute('x', -hitareaMargin);
        hitarea.setAttribute('y', -hitareaMargin);
        hitarea.setAttribute('width', w + hitareaMargin * 2);
        hitarea.setAttribute('height', h + hitareaMargin * 2);
        svg.setAttribute("pointer-events", editor.navigating ? "none" : "painted");
    };

    namespace.updateMarkupTextSvgBackground = function(svg, w, h, color) {

        var background = svg.background;

        background.setAttribute('x', 0);
        background.setAttribute('y', 0);
        background.setAttribute('width', w);
        background.setAttribute('height', h);
        background.setAttribute('fill', color);
    };

    namespace.updateMarkupTextSvgClipper = function(svg, w, h) {

        var clipper = svg.clipper;

        clipper.rect.setAttribute('x', 0);
        clipper.rect.setAttribute('y', 0);
        clipper.rect.setAttribute('width', w);
        clipper.rect.setAttribute('height', h);
    };

    /**
     * Helper function that injects metadata for the whole Markup document.
     * Metadata includes: version.
     * @param {Element} svg - an SVGElement
     * @param {Object} metadata - Dictionary with attributes
     */
    namespace.addSvgMetadata = function(svg ,metadata) {

        var metadataNode = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
        var dataVersionNode = document.createElement('markup_document');

        metadataNode.appendChild(dataVersionNode);

        // NOTE: We could iterate over the properties, but we don't because these are the only ones supported
        dataVersionNode.setAttribute("data-model-version", metadata["data-model-version"]); // Version. For example: "1"

        svg.insertBefore(metadataNode, svg.firstChild);
        return metadataNode;
    };

    /**
     * Helper function that injects metadata for specific markup svg nodes.
     * @param {Element} markupNode - an SVGElement for the markup
     * @param {Object} metadata - Dictionary where all key/value pairs are added as metadata entries.
     * @returns {Element}
     */
    namespace.addMarkupMetadata = function(markupNode, metadata) {

        var metadataNode = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
        var dataVersionNode = document.createElement('markup_element');

        metadataNode.appendChild(dataVersionNode);
        for (var key in metadata) {
            if (metadata.hasOwnProperty(key)) {
                dataVersionNode.setAttribute(key, metadata[key]);
            }
        }

        markupNode.insertBefore(metadataNode, markupNode.firstChild);
        return metadataNode;
    };

    /**
     * Removes al metadata nodes from an Svg node structure.
     * Method will remove all metadata nodes from children nodes as well.
     * @param svgNode
     */
    namespace.removeAllMetadata = function(svgNode) {

        if (svgNode.getElementsByTagName) {
            var nodes = svgNode.getElementsByTagName("metadata");
            for (var i=0; i<nodes.length; ++i) {
                var metadataNode = nodes[i];
                metadataNode.parentNode && metadataNode.parentNode.removeChild(metadataNode);
            }
        }

        // Transverse children nodes
        var svgChildren = svgNode.children || svgNode.childNodes;
        if (svgChildren) {
            for (i=0; i<svgChildren.length; ++i) {
                this.removeAllMetadata(svgChildren[i]);
            }
        }
    };

    /**
     * Utility function that transfers children from an Html/Svg node into another one.
     * @param nodeFrom - The node instance from where children will be taken.
     * @param nodeInto - The node that's going to parent the transferred children.
     */
    namespace.transferChildNodes = function(nodeFrom, nodeInto) {

        var svgChildren = nodeFrom.children || nodeFrom.childNodes;
        var tmpArray = [];
        for (var i=0; i<svgChildren.length; ++i){
            tmpArray.push(svgChildren[i]); // Avoid appendChild
        }
        tmpArray.forEach(function(node){
            nodeInto.appendChild(node);
        });
    };

    /**
     * To ensure all clip paths have unique ids, we search all clip paths belonging to markups and return a grater id.
     * @returns {number}
     */
    namespace.getClipPathId = function() {

        var clippers = document.getElementsByTagName('clipPath');
        var clippersCount = clippers.length;
        var maxId = 0;

        for (var i = 0; i < clippersCount; ++i) {

            var clipperId = clippers[i].id;
            if (clipperId.indexOf('markup-clipper-') === -1 ) {
                continue;
            }
            clipperId = clipperId.replace('markup-clipper-', '');
            maxId = Math.max(maxId, clipperId);
        }
        return maxId+1;
    };

    /**
     * Serializes an SVG node into a String.
     * @param domNode
     * @returns {string}
     */
    namespace.svgNodeToString = function(domNode){

        function removeHitareas(svg, hitareas) {

            var hitarea = svg.hitarea;
            var hitareaParent = hitarea && hitarea.parentNode;

            if (hitareaParent) {

                hitareas.push({hitarea: hitarea, parent: hitareaParent});
                hitareaParent.removeChild(hitarea);
            }

            var children = svg.childNodes;
            var childrenCount = children.length;

            for(var i = 0; i < childrenCount; ++i) {
                removeHitareas(children.item(i), hitareas);
            }
        }

        function addHitareas(hitareas) {

            var hitareasCount = hitareas.length;
            for(var i = 0; i < hitareasCount; ++i) {

                var hitarea = hitareas[i];
                hitarea.parent.appendChild(hitarea.hitarea);
            }
        }

        var result;
        try {
            var hitareas = [];
            removeHitareas(domNode, hitareas);

            var xmlSerializer = new XMLSerializer();
            result = xmlSerializer.serializeToString(domNode);

            addHitareas(hitareas);

        } catch (err) {
            result = '';
            console.warn('svgNodeToString failed to generate string representation of domNode.');
        }
        return result;
    };

    namespace.stringToSvgNode = function(stringNode){

        var node = null;
        try {
            var domParser = new DOMParser();
            var doc = domParser.parseFromString(stringNode, "text/xml");
            node = doc.firstChild; // We should only be getting 1 child anyway.
        } catch (err) {
            node = null;
            console.warn('stringToSvgNode failed to generate an HTMLElement from its string representation.');
        }
        return node;
    };

    /**
     * Injects functions and members to a client object which will
     * receive the ability to dispatch events.
     * Mechanism is the same as in Autodesk.Viewing.Viewer.
     *
     * Note: All of the code here comes from Autodesk.Viewing.Viewer
     *
     * @param {Object} client - Object that will become an event dispatcher.
     */
    namespace.addTraitEventDispatcher = function(client) {

        // Inject member variable
        client.listeners = {};

        // Inject functions
        client.addEventListener = function(type, listener) {
            if (typeof this.listeners[type] == "undefined"){
                this.listeners[type] = [];
            }
            this.listeners[type].push(listener);
        };
        client.hasEventListener = function (type, listener) {
            if (this.listeners === undefined) return false;
            var listeners = this.listeners;
            if (listeners[ type ] !== undefined && listeners[ type ].indexOf(listener) !== -1) {
                return true;
            }
            return false;
        };
        client.removeEventListener = function(type, listener) {
            if (this.listeners[type] instanceof Array){
                var li = this.listeners[type];
                for (var i=0, len=li.length; i < len; i++){
                    if (li[i] === listener){
                        li.splice(i, 1);
                        break;
                    }
                }
            }
        };
        client.fireEvent = function(event) {
            if (typeof event == "string"){
                event = { type: event };
            }
            if (!event.target){
                event.target = this;
            }

            if (!event.type){
                throw new Error("event type unknown.");
            }

            if (this.listeners[event.type] instanceof Array) {
                var typeListeners = this.listeners[event.type].slice();
                for (var i=0; i < typeListeners.length; i++) {
                    typeListeners[i].call(this, event);
                }
            }
        };
    };

    /**
     * Removes the EventDispatcher trait
     *
     * @param {Object} client
     */
    namespace.removeTraitEventDispatcher = function(client) {

        try {
            delete client.listeners;
            delete client.addEventListener;
            delete client.hasEventListener;
            delete client.removeEventListener;
            delete client.fireEvent;
        } catch (e) {
            // nothing
        }
    };

    //// Math  /////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Calculates the pixel position in client space coordinates of a point in world space.
     * @param {THREE.Vector3} point Point in world space coordinates.
     * @param viewer
     * @param snap Round values to closest pixel center.
     * @returns {THREE.Vector3} Point transformed and projected into client space coordinates.
     */
    namespace.worldToClient = function(point, viewer, snap) {

        var p = namespace.worldToViewport(point, viewer);
        var result = namespace.viewportToClient(p.x, p.y, viewer);
        result.z = 0;

        // snap to the center of the
        if (snap) {
            result.x = Math.floor(result.x) + 0.5;
            result.y = Math.floor(result.y) + 0.5;
        }

        return result;
    };

    namespace.clientToWorld = function(clientX, clientY, depth, viewer) {

        var point = namespace.clientToViewport(clientX, clientY, viewer);
        point.z = depth;

        point.unproject(viewer.impl.camera);
        return point;
    };

    namespace.clientToViewport = function(clientX, clientY, viewer) {

        return viewer.impl.clientToViewport(clientX, clientY);
    };

    namespace.viewportToClient = function(viewportX, viewportY, viewer) {

        return viewer.impl.viewportToClient(viewportX, viewportY);
    };

    /**
     * Calculates the world position of a point in client space coordinates.
     * @param {Object} point - { x:Number, y:Number, z:Number }
     * @param {Object} viewer - LMV instance
     * @returns {THREE.Vector3}
     */
    namespace.worldToViewport = function(point, viewer) {

        var p = new THREE.Vector3();

        p.x = point.x;
        p.y = point.y;
        p.z = point.z;

        p.project(viewer.impl.camera);
        return p;
    };

    namespace.metersToModel = function(meters, viewer) {

        var modelToMeter = viewer.model.getUnitScale();
        var meterToModel = 1 / modelToMeter;

        return meterToModel * meters;
    };

    namespace.radiansToDegrees = function (radians) {

        return radians * (180 / Math.PI);
    };

    namespace.degreesToRadians = function(degrees) {

        return degrees * (Math.PI / 180);
    };

    /**
     *
     * @param value
     * @returns {number}
     */
    namespace.sign = function (value) {

        return (value >= 0) ? 1 : -1;
    };

    /**
     *
     * @param pointA
     * @param pointB
     * @param range
     * @param editor
     * @returns {boolean}
     */
    namespace.areMarkupsPointsInClientRange = function(pointA, pointB, range, editor){

        range = editor.sizeFromClientToMarkups(0, range).y;

        var dx = pointA.x - pointB.x;
        var dy = pointA.y - pointB.y;

        return range * range >= dx * dx + dy * dy;
    };

    //// LMV ui ////////////////////////////////////////////////////////////////////////////////////////////////////////

    namespace.hideLmvUi = function(viewer) {

        // If the viewer is no gui, then there is nothing to hide
        if(!viewer.toolbar) {
            return;
        }

        // Exit other tools and hide HudMessages.
        viewer.setActiveNavigationTool();

        namespace.dismissLmvHudMessage();
        namespace.hideLmvPanels(true, viewer);
        namespace.hideLmvToolsAndPanels(viewer);
    };

    namespace.restoreLmvUi = function(viewer) {

        // If the viewer is no gui, then there is nothing to hide
        if(!viewer.toolbar) {
            return;
        }

        namespace.dismissLmvHudMessage();
        namespace.hideLmvPanels(false, viewer);
        namespace.showLmvToolsAndPanels(viewer);
    };

    /**
     *
     * @param hide
     * @param viewer
     */
    namespace.hideLmvPanels = function(hide, viewer) {

        var dockingPanels = viewer.dockingPanels;

        // Panels may not be present when dealing with an instance of Viewer3D.js
        // (as opposed to an instance of GuiViewer3D.js)
        if (!dockingPanels) return;

        for (var i = 0; i < dockingPanels.length; ++i) {

            var panel = dockingPanels[i];
            var panelContainer = panel.container;

            if (panelContainer.classList.contains("dockingPanelVisible")) {
                panelContainer.style.display = hide ? "none" : "block";

                // Call the visibility changed notification if any additional
                // stuff needs to be done (update the date i.e. PropertyPanel, etc).
                panel.visibilityChanged();
            }
        }
    };

    /**
     * Shows panels and tools in the viewer.
     * @param viewer
     */
    namespace.showLmvToolsAndPanels = function(viewer) {

        // Restore view cube.
        if(viewer && viewer.model && !viewer.model.is2d()) {
            viewer.displayViewCube(true, false);
        }

        // TODO: Find or ask for a better way to restore this buttons.
        // Hide home and info button.
        var home = document.getElementsByClassName('homeViewWrapper');
        var info = document.getElementsByClassName('infoButton');
        var anim = document.getElementsByClassName('toolbar-animationSubtoolbar');

        if (home.length > 0) {
            home[0].style.display = '';
        }

        if (info.length > 0) {
            info[0].style.display = '';
        }

        if (anim.length > 0) {
            anim[0].style.display = '';
        }

        // toolbar is absent when dealing with an instance of Viewer3D (instead of GuiViewer3D)
        if (viewer.toolbar) {
            var viewerContainer = viewer.toolbar.container;
            var viewerContainerChildrenCount = viewerContainer.children.length;
            for(var i = 0; i < viewerContainerChildrenCount; ++i) {
                viewerContainer.children[i].style.display = "";
            }
            viewer.centerToolBar();
        }
    };

    /**
     * Hides panels and tools in the viewer.
     * @param viewer
     */
    namespace.hideLmvToolsAndPanels = function(viewer) {

        // Hide Panels and tools.
        if (viewer && viewer.model && !viewer.model.is2d()) {
            viewer.displayViewCube(false, false);
        }

        // TODO: Find or ask for a better way to hide this buttons.
        // Hide home and info button.
        var home = document.getElementsByClassName('homeViewWrapper');
        var info = document.getElementsByClassName('infoButton');
        var anim = document.getElementsByClassName('toolbar-animationSubtoolbar');

        if (home.length > 0) {
            home[0].style.display = 'none';
        }

        if (info.length > 0) {
            info[0].style.display = 'none';
        }

        if (anim.length > 0) {
            anim[0].style.display = 'none';

            var animator = viewer.impl.keyFrameAnimator;
            if (animator && !animator.isPaused) {
                animator.pauseCameraAnimations();
                animator.pause();

                var playButton = viewer.modelTools.getControl('toolbar-animationPlay');
                if (playButton) {
                    playButton.setIcon('toolbar-animationPauseIcon');
                    playButton.setToolTip('Pause');
                }
            }
        }

        // toolbar is absent when dealing with an instance of Viewer3D (instead of GuiViewer3D)
        if (viewer.toolbar) {
            var viewerContainer = viewer.toolbar.container;
            var viewerContainerChildrenCount = viewerContainer.children.length;
            for(var i = 0; i < viewerContainerChildrenCount; ++i) {
                viewerContainer.children[i].style.display = "none";
            }
        }
    };

    /**
     * Dismisses all LMV HudMessages
     */
    namespace.dismissLmvHudMessage = function() {

        // Using try/catch block since we are accessing the Private namespace of LMV.
        try {
            var keepDismissing = true;
            while (keepDismissing) {
                keepDismissing = Autodesk.Viewing.Private.HudMessage.dismiss();
            }
        } catch (ignore) {
            // Failing to show the message is an okay fallback scenario
            console.warn("[CO2]Failed to dismiss LMV HudMessage");
        }
    };

    //// Styles ////////////////////////////////////////////////////////////////////////////////////////////////////////

    namespace.createStyle = function(attributes, editor) {

        var style = {};

        for(var i = 0; i < attributes.length; ++i) {

            style[attributes[i]] = null;
        }

        var defaults = namespace.getStyleDefaultValues(style, editor);

        for(var i = 0; i < attributes.length; ++i) {

            var attribute = attributes[i];
            style[attribute] = defaults[attribute].values[defaults[attribute].default].value;
        }

        return style;
    };

    /**
     *
     * @param source
     * @param destination
     * @returns {*}
     */
    namespace.copyStyle = function(source, destination) {

        for(var attribute in destination) {
            if (source.hasOwnProperty(attribute)) {
                destination[attribute] = source[attribute];
            }
        }

        return destination;
    };

    /**
     *
     * @param source
     * @returns {{}}
     */
    namespace.cloneStyle = function(source) {

        var clone = {};

        for(var attribute in source) {
            clone[attribute] = source[attribute];
        }

        return clone;
    };

    /**
     *
     * @param style
     * @param editor
     * @returns {{}}
     */
    namespace.getStyleDefaultValues = function(style, editor) {

         function getStrokeWidth(widthInPixels, editor) {

            var size = editor.sizeFromClientToMarkups(0, widthInPixels);
            return size.y;
        }

        function getWidths(normalWidth) {

            return {
                values: [
                    {name:'Thin', value: normalWidth / 2},
                    {name:'Normal', value: normalWidth},
                    {name:'Thick', value: normalWidth * 2}],
                default: 1
            };
        }

        function getLineJoins() {

            return {
                values: [
                    {name:'Miter', value: 'miter'},
                    {name:'Round', value: 'round'},
                    {name:'Bevel', value: 'bevel'}],
                default: 0
            };
        }

        function getFontSizes(normalWidth) {

            return {
                values: [
                    {name:'Thin', value: normalWidth /  2},
                    {name:'Normal', value: normalWidth},
                    {name:'Thick', value: normalWidth *  2}],
                default: 1
            };
        }

        function getColors() {

            return {
                values: [
                    {name:'red', value: '#ff0000'},
                    {name:'green', value: '#00ff00'},
                    {name:'blue', value: '#0000ff'},
                    {name:'white', value: '#ffffff'},
                    {name:'black', value: '#000000'}],
                default: 0
            };
        }

        function getOpacities(defaultTransparent) {

            return {
                values: [
                    {name:'100%', value: 1.00},
                    {name:'75%', value:  0.75},
                    {name:'50%', value: 0.50},
                    {name:'25%', value: 0.25},
                    {name:'0%', value: 0.00}],
                default: (defaultTransparent ? 4 : 0)
            };
        }

        function getFontFamilies() {

            // TODO: Localize?
            // TODO: Validate fonts with design
            // Source: http://www.webdesigndev.com/web-development/16-gorgeous-web-safe-fonts-to-use-with-css
            return {
                values:[
                    {name:'Arial', value: 'Arial'},
                    {name:'Arial Black', value: 'Arial Black'},
                    {name:'Arial Narrow', value: 'Arial Narrow'},
                    {name:'Century Gothic', value: 'Century Gothic'},
                    {name:'Courier New', value: 'Courier New'},
                    {name:'Georgia', value: 'Georgia'},
                    {name:'Impact', value: 'Impact'},
                    {name:'Lucida Console', value: 'Lucida Console'},
                    {name:'Tahoma', value: 'Tahoma'},
                    {name:'Verdana', value: 'Verdana'}
                ],
                default: 0
            };
        }

        function getFontStyles() {
            return {
                values:[
                    {name:'Normal', value: 'normal'},
                    {name:'Italic', value: 'italic'}],
                default: 0
            };
        }

        function getFontWeights() {
            return {
                values:[
                    {name:'Normal', value: 'normal'},
                    {name:'Bold', value: 'bold'}],
                default: 0};
        }

        var values = namespace.cloneStyle(style);
        var normaStrokeWidth = getStrokeWidth(namespace.MARKUP_DEFAULT_STROKE_WIDTH_IN_PIXELS, editor);
        var normaFontWidth = getStrokeWidth(namespace.MARKUP_DEFAULT_FONT_WIDTH_IN_PIXELS, editor);

        for(var attribute in values) {

            switch(attribute) {
                case 'stroke-width':
                    values[attribute] = getWidths(normaStrokeWidth);
                    break;

                case 'stroke-linejoin':
                    values[attribute] = getLineJoins();
                    break;

                case 'font-size':
                    values[attribute] = getFontSizes(normaFontWidth);
                    break;

                case 'font-family':
                    values[attribute] = getFontFamilies();
                    break;

                case 'font-style':
                    values[attribute] = getFontStyles();
                    break;

                case 'font-weight':
                    values[attribute] = getFontWeights();
                    break;

                case 'stroke-color':
                case 'fill-color':
                    values[attribute] = getColors();
                    break;

                case 'stroke-opacity':
                    var defaultTransparent = false;
                    values[attribute] = getOpacities(defaultTransparent);
                    break;

                case 'fill-opacity':
                    var defaultTransparent = true;
                    values[attribute] = getOpacities(defaultTransparent);
                    break;

                default:
                    break;
            }
        }

        return values;
    };

    namespace.composeRGBAString = function(hexRGBString, opacity) {

        if(!hexRGBString || !opacity || opacity <= 0) {
            return 'none';
        }

        return ['rgba(' +
            parseInt('0x' + hexRGBString.substr(1,2)), ',',
            parseInt('0x' + hexRGBString.substr(3,2)), ',',
            parseInt('0x' + hexRGBString.substr(5,2)), ',', opacity, ')'].join('');
    };

    //// Id Target Collision ///////////////////////////////////////////////////////////////////////////////////////////

    /**
     *
     * @param x0
     * @param y0
     * @param x1
     * @param y1
     * @param idTarget
     */
    namespace.checkLineSegment = function(x0, y0, x1, y1, idTarget) {

        var deviceRatio = window.devicePixelRatio || 1;

        x0 *= deviceRatio;
        y0 *= deviceRatio;
        x1 *= deviceRatio;
        y1 *= deviceRatio;

        var idTargetWidth = idTarget.width;
        var idTargetHeight = idTarget.height;
        var idTargetBuffer = idTarget.buffer;

        x0 = Math.round(x0);
        x1 = Math.round(x1);
        y0 = Math.round(idTargetHeight - y0);
        y1 = Math.round(idTargetHeight - y1);

        function point(x, y) {

            x = Math.round(x);
            y = Math.round(y);

            var dx = 0;
            var dy = 0;

            for(var j = -deviceRatio; j <= deviceRatio; j+=deviceRatio*2){
                dy += check(x,y+j) ? j : 0;
            }

            for(var i = -deviceRatio; i <= deviceRatio; i+=deviceRatio*2){
                dx += check(x+i,y) ? i : 0;
            }

            return {
                x: Math.round(x / deviceRatio + dx),
                y: Math.round((idTargetHeight - y) / deviceRatio - dy)};
        }

        function check(x, y) {

            // Probably better to clip line at the beginning.
            if (x < 0 || x >= idTargetWidth ||
                y < 0 || y >= idTargetHeight) {
                return false;
            }

            var index = (y * idTargetWidth + x) *4;
            return (
                idTargetBuffer[index  ] !== 0xFF ||
                idTargetBuffer[index+1] !== 0xFF ||
                idTargetBuffer[index+2] !== 0xFF);
        }

        // DDA Line algorithm
        var dx = (x1 - x0);
        var dy = (y1 - y0);

        var m = dx !== 0 ? dy / dx : 1;
        var x = x0;
        var y = y0;

        if (dx !== 0 && Math.abs(m) <= 1) {

            if (x0 <= x1) {
                for (; x <= x1; ++x, y += m) {
                    if (check(x, Math.round(y))) {
                        return point(x, y);
                    }
                }
            } else {
                for (; x >= x1; --x, y -= m) {
                    if (check(x, Math.round(y))) {
                        return point(x, y);
                    }
                }
            }
        } else {

            m = dx !== 0 ? 1/m : 0;
            if (y0 <= y1) {
                for (; y <= y1; ++y, x += m) {
                    if (check(Math.round(x), y)) {
                        return point(x, y);
                    }
                }
            } else {
                for (; y >= y1; --y, x -= m) {
                    if (check(Math.round(x), y)) {
                        return point(x, y);
                    }
                }
            }
        }
    };

    /**
     *
     * @param polygon
     * @param idTarget
     */
    namespace.checkPolygon = function(polygon, idTarget) {

        // Return if incorrect parameters.
        if(!polygon || polygon.verxtexCount < 3 || !idTarget) {
            return null;
        }

        var deviceRatio = window.devicePixelRatio || 1;

        var idTargetWidth = idTarget.width;
        var idTargetHeight = idTarget.height;
        var idTargetBuffer = idTarget.buffer;

        var vertexCount = polygon.vertexCount;
        var xVertices = Float32Array.from(polygon.xVertices); // Clone to scale by device pixel ratio and to
        var yVertices = Float32Array.from(polygon.yVertices); // change y coordinates to OpenGL style.

        function point(x, y) {

            var dx = 0;
            var dy = 0;

            for(var j = -deviceRatio; j <= deviceRatio; j+=deviceRatio*2){
                dy += check(x,y+j) ? j : 0;
            }

            for(var i = -deviceRatio; i <= deviceRatio; i+=deviceRatio*2){
                dx += check(x+i,y) ? i : 0;
            }

            return {
                x: Math.round(x / deviceRatio) + dx,
                y: Math.round((idTargetHeight - y) / deviceRatio - dy)};
        }

        function check(x, y) {

            if (x < 0 || x >= idTargetWidth ||
                y < 0 || y >= idTargetHeight) {
                return false;
            }

            var index = (y * idTargetWidth + x) * 4;
            return (
                idTargetBuffer[index  ] !== 0xFF ||
                idTargetBuffer[index+1] !== 0xFF ||
                idTargetBuffer[index+2] !== 0xFF) && isInsidePolygon(x, y);
        }

        function isInsidePolygon(x, y) {

            var result = false;
            var vertexCount = polygon.vertexCount;
            for(var i = 0, j = vertexCount-1; i < vertexCount; j = i++) {

                if (((yVertices[i] > y) != (yVertices[j] > y)) &&
                     (x < (xVertices[j] - xVertices[i]) * (y - yVertices[i]) / (yVertices[j] - yVertices[i]) + xVertices[i]) ) {
                    result = !result;
                }
            }
            return result;
        }

        // Change coordinates to OpenGL style and calculate polygon's bounding box.
        var bbX0 = Number.POSITIVE_INFINITY;
        var bbY0 = Number.POSITIVE_INFINITY;
        var bbX1 = Number.NEGATIVE_INFINITY;
        var bbY1 = Number.NEGATIVE_INFINITY;

        for(var i = 0; i < vertexCount; ++i) {

            var bbX = xVertices[i] = xVertices[i] * deviceRatio;
            var bbY = yVertices[i] = idTargetHeight - yVertices[i] * deviceRatio;

            bbX0 = Math.min(bbX0, bbX);
            bbY0 = Math.min(bbY0, bbY);
            bbX1 = Math.max(bbX1, bbX);
            bbY1 = Math.max(bbY1, bbY);
        }

        if (bbX1 < 0 || bbX0 > idTargetWidth ||
            bbY1 < 0 || bbY0 > idTargetHeight) {
            return null;
        }

        var bbW = Math.round(bbX1 - bbX0);
        var bbH = Math.round(bbY1 - bbY0);

        var bbCenterX = Math.round((bbX0 + bbX1)*0.5);
        var bbCenterY = Math.round((bbY0 + bbY1)*0.5);

        // Check
        var x = bbCenterX;
        var y = bbCenterY;

        var w = 1;
        var h = 1;

        do {

            var endX = x + w;
            var endY = y + h;

            for(; x < endX; ++x) {
                if (check(x,y)) {
                    return point(x,y);
                }
            }

            for(; y < endY; ++y) {
                if (check(x,y)) {
                    return point(x,y);
                }
            }

            if (w < bbW) {
                endX = x - ++w; ++w;
            } else {
                endX = x - w;
            }

            if (h < bbH) {
                endY = y - ++h; ++h;
            } else {
                endY = y - h;
            }

            for(; x > endX; --x) {
                if (check(x,y)) {
                    return point(x,y);
                }
            }

            for(; y > endY; --y) {
                if (check(x,y)) {
                    return point(x,y);
                }
            }
        } while(w < bbW || h < bbH);
     };

    //// CSS ///////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     *
     * @returns {*}
     */
    namespace.createStyleSheet = function() {

        var style = document.createElement("style");

        // This is WebKit hack.
        style.appendChild(document.createTextNode(""));
        document.head.appendChild(style);

        return style.sheet;
    };

    /**
     *
     * @param styleSheet
     * @param selector
     * @param styles
     * @param index
     */
    namespace.addRuleToStyleSheet = function(styleSheet, selector, styles, index) {

        if("insertRule" in styleSheet) {
            styleSheet.insertRule(selector + "{" + styles + "}", index);
        }
        else if("addRule" in styleSheet) {
            styleSheet.addRule(selector, styles, index);
        }
    };

    //// SVG ///////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     *
     * @param lines
     * @param style
     * @param editor
     */
    namespace.measureTextLines = function(lines, style, editor) {

        // Measure div style is line style with some custom layout properties.
        var fontSize = editor.sizeFromMarkupsToClient(0, style['font-size']).y;

        var measureStyle = new namespace.DomElementStyle()
            .setAttribute('font-family', style['font-family'])
            .setAttribute('font-size', fontSize + 'px')
            .setAttribute('font-weight', style['font-weight'] ? 'bold' : '')
            .setAttribute('font-style', style['font-style'] ? 'italic' : '')

            .removeAttribute(['top', 'left', 'width', 'height', 'overflow-y'])
            .setAttribute('position','absolute')
            .setAttribute('white-space','nowrap')
            .setAttribute('float','left')
            .setAttribute('visibility','hidden')
            .getStyleString();

        // Create measure div.
        var measure = document.createElement('div');

        measure.setAttribute('style', measureStyle);
        editor.viewer.container.appendChild(measure);

        // Measure.
        var result = [];

        var linesCount = lines.length;
        for(var i = 0; i < linesCount; ++i) {

            measure.innerHTML = lines[i];
            result.push({
                line: lines[i],
                width: measure.clientWidth,
                height: measure.clientHeight
            });
        }

        // Remove measure div and return result.
        editor.viewer.container.removeChild(measure);
        return result;
    };

    namespace.createArcTo = function(x, y, xRadius, yRadius, relative, path) {

        path.push(relative ? 'a' : 'A');
        path.push(xRadius);
        path.push(yRadius);
        path.push(0);
        path.push(1);
        path.push(1);
        path.push(x);
        path.push(y);

        return path;
    };

    namespace.createEllipsePath = function (x, y, w, h, relative, path) {

        var halfW = w * 0.5;
        var halfH = h * 0.5;

        path.push(relative ? 'm' : 'M');
        path.push(x);
        path.push(y);

        namespace.createArcTo(w, 0, halfW, halfH, true, path);
        namespace.createArcTo(-w, 0, halfW, halfH, true, path);

        path.push('z');
    };

    namespace.createRectanglePath = function (x, y, w, h, relative, path) {

        path.push(relative ? 'm' : 'M');
        path.push(x);
        path.push(y);
        path.push('l');
        path.push(w);
        path.push(0);
        path.push('l');
        path.push(0);
        path.push(h);
        path.push('l');
        path.push(-w);
        path.push(0);
        path.push('z');
    };

    namespace.renderToCanvas = function(editor, ctx, path, style, transform) {

        var strokeWidth = style['stroke-width'];
        var strokeLineJoint = style['stroke-linejoin'];
        var strokeColor = style['stroke-color'];
        var strokeOpacity = style['stroke-opacity'];
        var fillColor = style['fill-color'];
        var fillOpacity = style['fill-opacity'];

        var vector3 = new THREE.Vector3(0,0,0);
        var rotation = new THREE.Matrix4().extractRotation(transform);
        var rotationZ = Math.atan2(rotation.elements[4], rotation.elements[0]) * 180 / Math.PI;

        var mappingFn = editor.positionFromMarkupsToClient.bind(editor);
        var mappingVectorFn = editor.vectorFromMarkupsToClient.bind(editor);
        var mappingSizeFn = editor.sizeFromMarkupsToClient.bind(editor);
        var pathLength = path.length;
        var pathClosed = false;

        for(var i = 0; i < pathLength;) {

            switch(path[i++]) {

                case 'M':
                case 'L':
                    vector3.x = path[i];
                    vector3.y = path[i+1];
                    vector3 = vector3.applyMatrix4(transform);
                    var position = mappingFn(vector3.x, vector3.y);
                    path[i++] = position.x;
                    path[i++] = position.y;
                    break;

                case 'm':
                case 'l':
                    vector3.x = path[i];
                    vector3.y = path[i+1];
                    vector3 = vector3.applyMatrix4(rotation);
                    var position = mappingVectorFn(vector3.x, vector3.y);
                    path[i++] = position.x;
                    path[i++] = position.y;
                    break;

                case 'c':
                    vector3.x = path[i];
                    vector3.y = path[i+1];
                    vector3 = vector3.applyMatrix4(rotation);
                    var cp1 = mappingVectorFn(vector3.x, vector3.y);
                    path[i++] = cp1.x;
                    path[i++] = cp1.y;

                    vector3.x = path[i];
                    vector3.y = path[i+1];
                    vector3 = vector3.applyMatrix4(rotation);
                    var cp2 = mappingVectorFn(vector3.x, vector3.y);
                    path[i++] = cp2.x;
                    path[i++] = cp2.y;

                    vector3.x = path[i];
                    vector3.y = path[i+1];
                    vector3 = vector3.applyMatrix4(rotation);
                    var end = mappingVectorFn(vector3.x, vector3.y);
                    path[i++] = end.x;
                    path[i++] = end.y;
                    break;

                case 'a':
                    var radius = mappingSizeFn(path[i], path[i+1]);
                    path[i++] = radius.x;
                    path[i++] = radius.y;
                    path[i++] = rotationZ;
                    i++;
                    path[i] = path[i++] == 1 ? 0 : 1;

                    vector3.x = path[i];
                    vector3.y = path[i+1];
                    vector3 = vector3.applyMatrix4(rotation);
                    var end = mappingVectorFn(vector3.x, vector3.y);
                    path[i++] = end.x;
                    path[i++] = end.y;
                    break;

                case 'Z':
                case 'z':
                    pathClosed = true;
                    break;
            }
        }

        ctx.strokeStyle = namespace.composeRGBAString(strokeColor, strokeOpacity);
        ctx.fillStyle = namespace.composeRGBAString(fillColor, fillOpacity);
        ctx.lineJoin = strokeLineJoint;
        ctx.lineWidth = editor.sizeFromMarkupsToClient(strokeWidth, 0).x;

        path = new Path2D(path.join(' '));

        if (pathClosed && fillOpacity !== 0) {
            ctx.fill(path);
        }
        ctx.stroke(path);
    };

})();

(function(){ 'use strict';

    AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core');

    /**
     * Base class for all markup edit actions.
     *
     * EditActions encapsulate {@link Autodesk.Viewing.Extensions.Markups.Core.Markup  Markup}
     * operations (such as creation, edition and deletion) that hook into the undo/redo system.
     *
     * The minimum set of methods to implement on an EditAction extension are:
     * - execute()
     * - undo()
     * - redo()
     *
     * A good set of classes to check their implementation are:
     * - [CreateCircle]{@link Autodesk.Viewing.Extensions.Markups.Core.CreateCircle}.
     * - [DeleteCircle]{@link Autodesk.Viewing.Extensions.Markups.Core.DeleteCircle}.
     * - [SetCircle]{@link Autodesk.Viewing.Extensions.Markups.Core.SetCircle}.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     *
     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor
     * @param {String} type - An identifier for the EditAction.
     * @param {number} targetId - The id of the markup being affected.
     * @category Extensions
     */
    function EditAction(editor, type, targetId) {

        this.type =  type;
        this.editor = editor;
        this.targetId = targetId;
        this.addToHistory = true;
        this.selectOnExecution = true;
    }

    Autodesk.Viewing.Extensions.Markups.Core.EditAction = EditAction;

    /**
     * Performs the action.
     */
    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.execute = function() {

        this.editor.actionManager.execute(this);
    };

    /**
     * @abstract
     */
    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.redo = function() {

    };

    /**
     * @abstract
     */
    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.undo = function() {

    };

    /**
     * Provides a mechanism to merge consecutive actions of the same type.
     * @param {Autodesk.Viewing.Extensions.Markups.Core.EditAction} action - Action to check if it can be merged with 'this'.
     * @returns {boolean} Returns true if merge has been applied. Parameter will be discarded.
     */
    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.merge = function(action) {

        return false;
    };

    /**
     * Provides a mechanism to check whether the action yields no results.
     * @returns {boolean} Returns true if no changes happen with this action.
     */
    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.isIdentity = function() {

        return false;
    };

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param historySize
     * @constructor
     */
    function EditActionManager(historySize) {

        this.historySize = historySize;

        this.undoStack = new Array(historySize);
        this.redoStack = new Array(historySize);

        namespaceUtils.addTraitEventDispatcher(this);
    }

    /*
     * Event types
     */
    namespace.EVENT_HISTORY_CHANGED = "EVENT_HISTORY_CHANGED";

    var proto = EditActionManager.prototype;

    /**
     *
     * @param action
     */
    proto.execute = function(action) {

        var redoStack = this.redoStack;
        var undoStack = this.undoStack;

        redoStack.splice(0, redoStack.length);

        action.redo();

        var group = this.getEditActionGroup();
        if (group.isOpen()) {
            group.addAction(action);
        } else {
            group.open();
            group.addAction(action);
            group.close();
        }

        if (undoStack.length > this.historySize) {
            undoStack.splice(0,1);
        }

        var targetId = action.selectOnExecution ? action.targetId : -1;
        this.fireEvent(
            {type: namespace.EVENT_HISTORY_CHANGED, data: {action: 'execute', targetId: targetId}});
    };

    proto.beginActionGroup = function() {

        var undoStack = this.undoStack;
        var undoStackCount = undoStack.length;
        var group = null;

        if (undoStackCount === 0 || undoStack[undoStackCount-1].isClosed()) {

            group = this.getEditActionGroup();
            group.open();
        } else {
            console.warn('Markups - Undo/Redo - Action edit group already open.');
        }
    };

    proto.closeActionGroup = function() {

        var undoStack = this.undoStack;
        var undoStackCount = undoStack.length;

        if (undoStackCount === 0) {

            console.warn('Markups - Undo/Redo - There is no action edit group to close.');
            return;
        }

        var group = undoStack[undoStackCount-1];
        if(!group.close()) {
            console.warn('Markups - Undo/Redo - Action edit group already closed.');
        }

        if (group.isEmpty()) {
            undoStack.pop();
        }
    };

    proto.cancelActionGroup = function() {

        var undoStack = this.undoStack;
        var undoStackCount = undoStack.length;

        if (undoStackCount === 0) {

            console.warn('Markups - Undo/Redo - There is no action edit group to close.');
            return;
        }

        var group = undoStack[undoStackCount-1];
        if(!group.close()) {
            console.warn('Markups - Undo/Redo - Action edit group already closed.');
            return;
        }

        group.undo();
        undoStack.pop();

        this.fireEvent(
            {type: namespace.EVENT_HISTORY_CHANGED, data: {action: 'cancel', targetId: -1}});
    };

    proto.undo = function() {

        var undoStack = this.undoStack;
        var redoStack = this.redoStack;

        if (undoStack.length === 0) {
            return;
        }

        var group = undoStack.pop();
        var targetId = group.undo();

        redoStack.push(group);

        this.fireEvent(
            {type: namespace.EVENT_HISTORY_CHANGED, data: {action:'undo', targetId: targetId}});
    };

    proto.redo = function() {

        var undoStack = this.undoStack;
        var redoStack = this.redoStack;

        if (redoStack.length === 0) {
            return;
        }

        var group = redoStack.pop();
        var targetId = group.redo();

        undoStack.push(group);

        this.fireEvent(
            {type: namespace.EVENT_HISTORY_CHANGED, data: {action:'redo', targetId: targetId}});
    };

    proto.clear = function() {

        this.undoStack.splice(0, this.undoStack.length);
        this.redoStack.splice(0, this.redoStack.length);

        this.fireEvent(
            {type: namespace.EVENT_HISTORY_CHANGED, data: {action:'clear', targetId: -1}});
    };

    proto.isUndoStackEmpty = function() {

        return this.undoStack.length === 0;
    };

    proto.isRedoStackEmpty = function() {

        return this.redoStack.length === 0;
    };

    /**
     *
     * @return action
     * @private
     */
    proto.getEditActionGroup = function() {

        var undoStack = this.undoStack;
        var undoStackCount = this.undoStack.length;

        var group = null;

        if (undoStackCount === 0 || undoStack[undoStackCount-1].isClosed()) {
            group = new namespace.EditActionGroup();
            undoStack.push(group);
        } else {
            group = undoStack[undoStackCount-1];
        }

        return group;
    };

    namespace.EditActionManager = EditActionManager;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * Curring object which generate a string that can be used
     * as a Dom element's 'style' value.
     *
     * @constructor
     */
    function DomElementStyle() {

        this.reset();
    }

    /*
     * Constants
     */
    var BROWSER_PREFIXES = ['-ms-', '-webkit-', '-moz-', '-o-'];

    var proto = DomElementStyle.prototype;

    proto.reset = function() {

        this.attributes = {};
        this.dirty = false;
        this.styleString = '';

        return this;
    };

    /**
     *
     * @param {String} key
     * @param {*} value
     * @param {Object} [options]
     * @param {Boolean} [options.allBrowsers] - Whether to add browser prefix to key
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomeElemStyle}
     */
    proto.setAttribute = function(key, value, options) {

        this.attributes[key] = value;

        if (options && options.allBrowsers) {
            var that = this;
            BROWSER_PREFIXES.forEach(function(prefix){
                that.attributes[(prefix+key)] = value;
            });
        }
        this.dirty = true; // Could be optimized
        return this;
    };

    /**
     * Removes one or more attributes
     * @param {String|Array} key - Key or Keys to be removed
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomElemStyle} this
     */
    proto.removeAttribute = function(key) {

        if (!Array.isArray(key)) {
            key = [key];
        }

        var self = this;
        key.forEach(function(k) {
            if (k in self.attributes) {
                delete self.attributes[k];
                self.dirty = true;
            }
        });
        return this;
    };

    /**
     * Gets the String representation of this style object
     * @returns {string}
     */
    proto.getStyleString = function() {

        if (this.dirty) {
            this.styleString = generateStyle(this.attributes);
            this.dirty = false;
        }
        return this.styleString;
    };

    /**
     * Clones the current Object
     *
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomElemStyle}
     */
    proto.clone = function() {

        var clone = new namespace.DomElementStyle();
        var attributes = this.attributes;

        for (var key in attributes) {
            clone.setAttribute(key, attributes[key]);
        }
        return clone;
    };

    /**
     * Generates the style value string. Non mutable function.
     *
     * @param {Object} attributes
     * @private
     */
    function generateStyle(attributes) {

        var elements = [];
        for (var key in attributes) {
            var val = attributes[key];
            elements.push(key);
            elements.push(':');
            elements.push(val);
            elements.push('; ');
        }
        return elements.join('');
    }

    namespace.DomElementStyle = DomElementStyle;

})();

 (function () { 'use strict';

     var namespace = Autodesk.Viewing.Extensions.Markups.Core;
     var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * A component to handle the selection of markups.
     *
     *
     *      Sample
     *
     *      var containingDiv = document.getElementById('containingDiv3d-app-wrapper');
     *      var selectionComponent = new EditFrame(containingDiv);
     *      selectionComponent.setSelection(100, 100, 300, 150, 0);
     *
     * @param {HTMLElement} containingDiv The container where the selection layer will live.
     * @param {Object} editor
     * @constructor
     */
    function EditFrame(containingDiv, editor) {

        this.containingDiv = containingDiv;
        this.editor = editor;
        this.selectionLayer = createSelectionLayer();

        this.frameMargin = 10;

        this.selection = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rotation: 0,
            element: null,
            active: false,
            dragging: false,
            resizing: false,
            //a dictionary of all the drag points
            //the key for each drag point will be its cardinal/ordinal direction
            handle: {}
        };

        createSelectorBox.bind(this)();

        if (namespaceUtils.isTouchDevice()) {
            this.hammer = new Hammer.Manager(this.selectionLayer, {
                recognizers: [
                    [Hammer.Pan, { event: 'drag', pointers: 1 } ],
                    [Hammer.Tap, { event: 'doubletap', taps: 2, interval: 300, threshold: 6, posThreshold: 30 } ],
                    [Hammer.Tap, { event: 'doubletap2', pointers: 2, taps: 2, interval: 300, threshold: 6, posThreshold: 40 } ]
                ],
                inputClass: Hammer.TouchInput
            });

            this.onHammerDragBinded = this.onHammerDrag.bind(this);
            this.onHammerDoubleTapBinded = this.onHammerDoubleTap.bind(this);

            this.hammer.on("dragstart dragmove dragend", this.onHammerDragBinded);
            this.hammer.on("doubletap", this.onHammerDoubleTapBinded);
            this.hammer.on("doubletap2", this.onHammerDoubleTapBinded);
        }

        handleSelectionBoxDragging.bind(this)();
        handleSelectionBoxResizing.bind(this)();
        handleSelectionDoubleClick.bind(this)();
        handleSelectionBoxRotating.bind(this)();

        //add the selection into the container given to us
        this.containingDiv.appendChild(this.selectionLayer);

        namespaceUtils.addTraitEventDispatcher(this);
    }

    // Constants //
    namespace.EVENT_EDITFRAME_EDITION_START = "EVENT_EDITFRAME_EDITION_START";
    namespace.EVENT_EDITFRAME_EDITION_END = "EVENT_EDITFRAME_EDITION_END";

    var BORDER_COLOR = 'rgba(30, 30, 255, 0.30)';
    var BACKGROUND = 'gainsboro';

    var proto = EditFrame.prototype;

    /**
     * Draws a selection box with the given attributes
     *
     * @param {number} x - The x coordinate to place the selection box
     * @param {number} y - The y coordinate to place the selection box
     * @param {number} width - The width of the selection box
     * @param {number} height - The height of the selection box
     * @param {number} rotation - The amount of degrees to rotate the selection box
     */
    proto.setSelection = function (x, y, width, height, rotation) {

        var margin = this.frameMargin;
        var doubleMargin = margin * 2;


        updateSelectorBoxDimensions.bind(this)(width + doubleMargin, height + doubleMargin);
        updateSelectorBoxPosition.bind(this)(x - margin, y - margin, rotation);
        updateSelectionBoxState.bind(this)(true); //activate the selection box
        this.selectionLayer.style.visibility = 'visible';
    };

    /**
     * Displays the selection box based on the position, dimension, and rotation of a given markup
     *
     * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup} markup - the markup that should appear as selected
     */
    proto.setMarkup = function (markup) {

        this.hammer && this.hammer.set({enable: markup !== null});
        this.markup = markup;

        updateSelectionBoxState.bind(this)(false);

        if (markup) {
            var size = markup.getClientSize(),
                position = markup.getClientPosition(),
                width = size.x,
                height = size.y,
                rotation = markup.getRotation();

            this.setSelection(position.x - (width / 2), position.y - (height / 2), width, height, rotation);

            this.enableResizeHandles();
            this.enableRotationHandle();
        }
    };

    proto.startDrag = function (event) {

        this.onMouseMove = this._onRepositionMouseMove.bind(this);
        this.onMouseUp = this._onRepositionMouseUp.bind(this);
        this._onRepositionMouseDown(event, this.editor.getMousePosition());
    };

     proto.isActive = function() {
        return this.isDragging() || this.isResizing() || this.isRotating();
     };

    proto.isDragging = function () {

        return this.selection.dragging;
    };

    proto.isResizing = function () {

        return this.selection.resizing;
    };

    proto.isRotating = function () {

        return this.selection.rotating;
    };

    proto.onMouseMove = function (event) {

        //dummy fn
    };

    proto.onMouseUp = function (event) {
        //dummy fn
    };

     proto.onHammerDrag = function(event) {

         function updateEditorInput(input, parent, event) {

             //TODO: Change this when refactoring input in edit frame.
             var rect = parent.getBoundingClientRect();
             input.mousePosition.x = event.pageX - rect.left;
             input.mousePosition.y = event.pageY - rect.top;
         }

        //console.log('EditFrame drag ' + event.type);
         convertEventHammerToMouse(event);
         switch (event.type) {
             case 'dragstart':
                 updateEditorInput(this.editor.input, this.editor.svg, event);
                 // Check whether to translate, rotate or resize
                 if (isRotatePoint(event.target)) {
                     // Rotate
                     this._onRotationMouseDown(event);
                 } else if (isDragPoint(event.target)) {
                     // Resize
                     this._onResizeMouseDown(event);
                 } else {
                     this.startDrag(event);
                 }
                 event.preventDefault();
                 break;
             case 'dragmove':
                 updateEditorInput(this.editor.input, this.editor.svg, event);
                 this.onMouseMove(event);
                 event.preventDefault();
                 break;
             case 'dragend':
                 updateEditorInput(this.editor.input, this.editor.svg, event);
                 this.onMouseUp(event);
                 event.preventDefault();
                 break;
         }
     };

    proto.onHammerDoubleTap = function(event) {

        function updateEditorInput(input, parent, event) {

            //TODO: Change this when refactoring input in edit frame.
            var rect = parent.getBoundingClientRect();
            input.mousePosition.x = event.pageX - rect.left;
            input.mousePosition.y = event.pageY - rect.top;
        }

        convertEventHammerToMouse(event);
        updateEditorInput(this.editor.input, this.editor.svg, event);

        this.selection.dragging = false;
        this.editor.editMode && this.editor.editMode.onMouseDoubleClick(this.markup);
    };

    proto.enableResizeHandles = function () {

        var markup = this.markup;
        var handle;

        if (markup.isHeightConstrained() || markup.isWidthConstrained()) {
            //hide all the handles
            for (var direction in this.selection.handle) {
                handle = this.selection.handle[direction];
                if(handle) handle.style.display = 'none';
            }

            //show only the resize points that are allowed
            if (markup.isHeightConstrained()) {
                this.selection.handle['w'].style.display = 'block';
                this.selection.handle['e'].style.display = 'block';
            }
            if (markup.isWidthConstrained()) {
                this.selection.handle['n'].style.display = 'block';
                this.selection.handle['s'].style.display = 'block';
            }
        } else {
            //no constraints, show all resize handles
            for (var direction in this.selection.handle) {
                handle = this.selection.handle[direction];
                if(handle) handle.style.display = 'block';
            }
        }
    };

    proto.enableRotationHandle = function () {

        var markup = this.markup;
        var handle = this.selection.rotationHandle;
        var display = markup.isRotationConstrained() ? 'none' : 'block';
        handle.style.display = display;
    };

     function convertEventHammerToMouse(event) {
         // Convert Hammer touch-event X,Y into mouse-event X,Y.
         event.pageX = event.pointers[0].clientX;
         event.pageY = event.pointers[0].clientY;
     }

    /**
     * Creates an element spanning the full height and width of its parent.
     * It serves as our surface to draw the selection box.
     *
     * @return {HTMLElement}
     */
    function createSelectionLayer() {

        var selectionLayer = document.createElement('div');
        selectionLayer.style.position = 'absolute';
        selectionLayer.style.top = 0;
        selectionLayer.style.bottom = 0;
        selectionLayer.style.left = 0;
        selectionLayer.style.right = 0;
        //don't let the selection box be visible outside the selection layer
        selectionLayer.style.overflow = 'hidden';
        selectionLayer.style.visibility = 'hidden';
        togglePointerEvents(selectionLayer, false);
        return selectionLayer;
    }

    /**
     * Creates a single drag point with the corresponding styles
     *
     * @param {number} diameter - The size of the drag point
     * @param {string} position - The cardinal(n, s, w, e) or ordinal(nw, nw, sw, se) direction of the point
     * @return {HTMLElement}
     */
    function createDragPoint(width, position) {

        var point = document.createElement('div');
        point.style.position = 'absolute';
        point.style.height = width + 'px';
        point.style.width = width + 'px';
        point.style.background = BACKGROUND;
        point.style.borderColor = BORDER_COLOR;
        point.style.borderWidth = '1px';
        point.style.borderStyle = 'solid';

        setResizeCursor(point, position);
        point.className = 'selector-drag-point autodesk-markups-extension-core-make-me-bigger sdp-handle-' + position;
        point.setAttribute('data-sdp-handle', position);

        var placementOffset = -width - 2; // - 2 -> border x2
        //set the position of the drag points based on the position
        switch (position) {
            case 'n':
                point.style.top = placementOffset + 'px';
                point.style.left = 'calc(50% - ' + (width/2) + 'px)';
                point.style.position = 'relative';
                point.style.margin = 0;
                break;
            case 's':
                point.style.top = 'calc(100% - ' + (width+2) + 'px)';
                point.style.left = 'calc(50% - ' + (width/2) + 'px)';
                point.style.position = 'relative';
                point.style.margin = 0;
                break;
            case 'w':
                point.style.left = placementOffset + 'px';
                point.style.top = '50%';
                point.style.transform = 'translate3d(0, -50%, 0)';
                break;
            case 'e':
                point.style.right = placementOffset + 'px';
                point.style.top = '50%';
                point.style.transform = 'translate3d(0, -50%, 0)';
                break;
            case 'nw':
                point.style.top = placementOffset + 'px';
                point.style.left = placementOffset + 'px';
                break;
            case 'ne':
                point.style.top = placementOffset + 'px';
                point.style.right = placementOffset + 'px';
                break;
            case 'sw':
                point.style.bottom = placementOffset + 'px';
                point.style.left = placementOffset + 'px';
                break;
            case 'se':
                point.style.bottom = placementOffset + 'px';
                point.style.right = placementOffset + 'px';
                break;
        }
        return point;
    }

    function createRotatePoint () {

        var diameter = 18;
        var pointBorderWidth = 1;
        var point = document.createElement('div');
        point.style.position = 'absolute';
        point.style.background = BACKGROUND;
        point.style.border = pointBorderWidth + 'px solid rgba(30, 30, 255, 0.25)';
        point.style.height = diameter + 'px';
        point.style.width = diameter + 'px';
        point.style.borderRadius = (diameter / 2) + pointBorderWidth + 'px';
        point.style.boxSizing = 'border-box';
        point.classList.add('selector-rotate-point');
        point.style.left = '50%';
        point.style.transform = 'translate3d(-50%, 0px, 0px)';
        point.style.top = '-70px';
        point.classList.add('autodesk-markups-extension-core-make-me-bigger');

        return point;
    }

    function setResizeCursor (element, direction) {

        var cursor;
        switch(direction) {
            case 'n':
            case 's':
                cursor = 'ns-resize';
                break;
            case 'w':
            case 'e':
                cursor = 'ew-resize';
                break;
            case 'ne':
            case 'sw':
                cursor = 'nesw-resize';
                break;
            case 'nw':
            case 'se':
                cursor = 'nwse-resize';
                break;
        }
        element.style.cursor = cursor;
    }

    /**
     * Creates the 8 drag points of the selection box.
     *
     * @this EditFrame
     */
    function createDragPoints(selector) {

        var pointWidth = 16;

        ['n', 's', 'w', 'e', 'nw', 'ne', 'sw', 'se'].forEach(function (direction) {
            //store the drag point and put it in the DOM
            this.selection.handle[direction] = createDragPoint(pointWidth, direction);
            selector.appendChild(this.selection.handle[direction]);
        }.bind(this));
    }

    /**
     * Determines if an element is a drag point
     *
     * @return {boolean}
     */
    function isDragPoint(element) {

        return matchesSelectorAux(element, '.selector-drag-point');
    }

    /**
     * Determines if an element is a rotate point
     *
     * @return {boolean}
     */
    function isRotatePoint(element) {

        return matchesSelectorAux(element, '.selector-rotate-point');
    }

    /**
     * Creates the element that will be used as the selection box. It also
     * takes care of adding the drag handles
     *
     * @return {HTMLElement} - the selection box
     * @this EditFrame
     */
    function createSelectorBox() {

        var borderWidth = 1;
        var selectorBox = document.createElement('div');
        selectorBox.style.position = 'absolute';
        selectorBox.style.border = borderWidth + 'px solid ' + BORDER_COLOR;
        selectorBox.style.zIndex = 1;
        selectorBox.style.cursor = 'move';
        selectorBox.style.boxSizing = 'border-box';
        togglePointerEvents(selectorBox, true);
        selectorBox.classList.add('selector-box');
        createDragPoints.bind(this)(selectorBox);
        this.selection.rotationHandle = createRotatePoint();
        selectorBox.appendChild(this.selection.rotationHandle);
        //store the selector box
        this.selection.element = selectorBox;

        //add the selection box to the selection layer
        this.selectionLayer.appendChild(this.selection.element);

        //we are just creating the box, start it out hidden
        updateSelectionBoxState.bind(this)(false);

        return selectorBox;
    }

    /**
     * Utility to create the CSS translate3d value from a given 2d point
     *
     * @param {number} x - coordinate
     * @param {number} y - coordinate
     * @return {string}
     */
    function toTranslate3d(x, y) {

        return 'translate3d(' + x + 'px,' + y + 'px,0)';
    }


    /**
     * Updates the display state of the selection box
     *
     * @param {boolean} active - The new state of the the selection box
     * @this EditFrame
     */
    function updateSelectionBoxState(active) {

        this.selection.active = active;
        this.selection.element.style.display = active ? 'block' : 'none';
    }

    /**
     * Updates the position and rotation of the selection box.
     *
     * @param {number} x - The x coordinate to place the selection box
     * @param {number} y - The y coordinate to place the selection box
     * @param {number} rotation - The amount of degrees to rotate the selection box
     * @this EditFrame
     */
    function updateSelectorBoxPosition(x, y, rotation) {

        this.selection.x = x;
        this.selection.y = y;
        this.selection.rotation = rotation;
        var size = this.markup.getClientSize();
        //TODO: consider DomElementStyle

        size.x += this.frameMargin * 2;
        size.y += this.frameMargin * 2;

        this.selection.element.style.msTransform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';
        this.selection.element.style.msTransformOrigin = (size.x / 2) + 'px ' + (size.y / 2) + 'px';
        this.selection.element.style.webkitTransform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';
        this.selection.element.style.webkitTransformOrigin = (size.x / 2) + 'px ' + (size.y / 2) + 'px';
        this.selection.element.style.transform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';
        this.selection.element.style.transformOrigin = (size.x / 2) + 'px ' + (size.y / 2) + 'px';
    }

    /**
     * Updates the dimensions of the selection box (width and height).
     *
     * @param {number} width - The new width of the selection box
     * @param {number} height - The new height of the selection box
     * @this EditFrame
     */
    function updateSelectorBoxDimensions(width, height) {

        this.selection.width = width;
        this.selection.height = height;
        this.selection.element.style.width = width + 'px';
        this.selection.element.style.height = height + 'px';
    }

    /**
     * Attaches all the necessary listeners to handle a drag action.
     *
     * @this EditFrame
     */
    function handleSelectionBoxDragging () {

        this.selection.element.addEventListener('mousedown', this._onRepositionMouseDown.bind(this));
    }

    var ignoreFirstMouseMove = false;
    proto._onRepositionMouseDown = function (event, cursor) {

        ignoreFirstMouseMove = true;
        //a synthetic start means that the event was triggered manually and not as a
        //result of a mousedown on the edit frame
        var syntheticStart = !(event instanceof MouseEvent);

        //during a real mousedown, ignore events originating from a resizing handle
        if (!syntheticStart && (isDragPoint(event.target) || isRotatePoint(event.target))) return;

        //get the cursor position
        cursor = syntheticStart ?  cursor : this.editor.getMousePosition();

        //store the initial cursor and axis constrains
        this.initialCursor = cursor;
        this.initialPosition = this.markup.getClientPosition();
        this.areAxisConstrained = false;
        this.axisConstrains = new THREE.Vector2(1,1);

        //update the function that will handle the mousemove and mouseup events
        this.onMouseMove = this._onRepositionMouseMove.bind(this);
        this.onMouseUp = this._onRepositionMouseUp.bind(this);

        if (this.selection.dragging)
            return;

        this.selection.dragging = true;
        this.editor.beginActionGroup();

        //if alt down I drop a clone.
        if (event && event.altKey) {
            var editor = this.editor;
            var cloneMarkup = new namespace.CloneMarkup(editor, editor.getId(), this.markup, this.markup.position);
            cloneMarkup.execute();
        }

        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_START }); // Moving around
    };

    proto._onRepositionMouseMove = function(event) {

        if (ignoreFirstMouseMove) {
            ignoreFirstMouseMove = false;
            return;
        }
        // Filter out mouse move events when clicking on mobile devices.

        //ignore mousemove events if the dragging state hasn't been activated
        if (!this.selection.dragging) return;

        //get the position of the cursor relative to selection layer
        var cursor = this.editor.getMousePosition();

        //constrain axis if shift key is down.
        var constrainAxis = this.editor.input.constrainAxis;
        if (this.areAxisConstrained !== constrainAxis) {
            this.areAxisConstrained = constrainAxis;
            this.axisConstrains = constrainAxis ? new THREE.Vector2(0, 0) : new THREE.Vector2(1,1);

            this.initialPosition.x += cursor.x - this.initialCursor.x;
            this.initialPosition.y += cursor.y - this.initialCursor.y;

            this.initialCursor.x = cursor.x;
            this.initialCursor.y = cursor.y;
        }

        //determine how many pixel we have to shift the
        //selection box to keep the cursor on the drag point
        var movement = {
            x: cursor.x - this.initialCursor.x,
            y: cursor.y - this.initialCursor.y
        };

        var deadZone = 15;
        if (this.axisConstrains.x === 0 && this.axisConstrains.y === 0) {

            if (Math.abs(movement.x) > deadZone) {
                this.axisConstrains.x = 1;
                movement.x += movement.x < 0 ?  deadZone : -deadZone;
            } else
            if (Math.abs(movement.y) > deadZone) {
                this.axisConstrains.y = 1;
                movement.y += movement.y < 0 ?  deadZone : -deadZone;
            }
        }

        var x = this.initialPosition.x + movement.x * this.axisConstrains.x;
        var y = this.initialPosition.y + movement.y * this.axisConstrains.y;

        updateSelectorBoxPosition.bind(this)(x, y, this.selection.rotation);

        //tell the markup to start transforming
        //the markup expects an (x, y) coordinate that
        //uses an origin at the center, adjust our x, y because
        //our origin starts at the top left
        var position = this.editor.positionFromClientToMarkups(x, y);
        var setPosition = new namespace.SetPosition(this.editor, this.markup, position);
        setPosition.execute();
    };

    proto._onRepositionMouseUp = function () {

        this.last = null;

        //this should never be called after the mouse up because we are no longer repositioning
        this.onMouseMove = function () {/*do nothing*/};
        this.onMouseUp = function () {/*do nothing*/};

        if(!this.selection.dragging) {
            return;
        }

        this.editor.closeActionGroup();
        this.selection.dragging = false;
        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_END }); // Moving around
    };

    proto._onResizeMouseDown = function (event) {
        var target = event.target;

        //is the target where the mousedown occurred a drag point
        if (!isDragPoint(target)) {
            return;
        }

        //keep a reference to the point where the drag started
        this.selection.handle.resizing = target;
        //figure out which direction this point should resize
        var direction = this.selection.handle.resizing.getAttribute('data-sdp-handle');
        //set the cursor position for the entire layer
        this.containingDiv.style.cursor = direction + '-resize';

        var cursor = this.editor.getMousePosition();

        var position = this.markup.getClientPosition();
        var size = this.markup.getClientSize();

        //store the center
        this.initial = {
            x: position.x,
            y: position.y,
            width: size.x,
            height: size.y,
            mouseX: cursor.x,
            mouseY: cursor.y
        };

        this.onMouseMove = this._onResizeMouseMove.bind(this);
        this.onMouseUp = this._onResizeMouseUp.bind(this);

        if (this.selection.resizing) {
            return;
        }

        this.selection.resizing = true;
        this.editor.beginActionGroup();

        //notify the markup that dragging has started
        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_START }); // Resizing
    };

    proto._onResizeMouseMove = function (event) {

        if (!this.selection.resizing) return;

        var cursor = this.editor.getMousePosition();
        var initial = this.initial;

        var movement = {
            x: cursor.x - initial.mouseX,
            y: cursor.y - initial.mouseY
        };

        var vector = new THREE.Vector3(movement.x, movement.y, 0);
        var undoRotation = new THREE.Matrix4().makeRotationZ(-this.selection.rotation);
        movement = vector.applyMatrix4(undoRotation);

        var x = initial.x,
            y = initial.y,
            width = initial.width,
            height = initial.height;

        var localSpaceDelta = new THREE.Vector3();

        //get the direction of the arrow being dragged
        var direction = this.selection.handle.resizing.getAttribute('data-sdp-handle');

        // TODO: Make a mechanism to configure and use this feature from Markups Core.
        // If shift is pressed, figure aspect ratio is maintained.
        if (this.editor.input.keepAspectRatio && ['nw', 'ne', 'sw', 'se'].indexOf(direction) !== -1) {

            var delta = new THREE.Vector3(movement.x, movement.y, 0);
            switch (direction){
                case 'nw': movement.set(-initial.width,-initial.height, 0); break;
                case 'ne': movement.set( initial.width,-initial.height, 0); break;
                case 'sw': movement.set( initial.width,-initial.height, 0); break;
                case 'se': movement.set( initial.width, initial.height, 0); break;
            }
            movement.normalize();
            movement = delta.projectOnVector(movement);
        }

        var translations = {
            n: function () {
                height -= movement.y;
                localSpaceDelta.y = movement.y;
            },
            s: function () {
                height += movement.y;
                localSpaceDelta.y = movement.y;
            },
            w: function () {
                width -= movement.x;
                localSpaceDelta.x = movement.x;
            },
            e: function () {
                width += movement.x;
                localSpaceDelta.x = movement.x;
            },
            nw: function () {
                this.n();
                this.w();
            },
            ne: function () {
                this.n();
                this.e();
            },
            sw: function () {
                this.s();
                this.w();
            },
            se: function () {
                this.s();
                this.e();
            }
        };

        translations[direction]();

        var redoRotation = new THREE.Matrix4().makeRotationZ(this.selection.rotation);
        var actualDelta = localSpaceDelta.applyMatrix4(redoRotation);

        var newPos = this.editor.positionFromClientToMarkups(
            x + (actualDelta.x * 0.5),
            y + (actualDelta.y * 0.5));

        var newSize = this.editor.sizeFromClientToMarkups(width, height);
        var setSize = new namespace.SetSize(this.editor, this.markup, newPos, newSize.x, newSize.y);
        setSize.execute();
    };

    proto._onResizeMouseUp = function (event) {
        this.selection.resizing = false;
        this.selection.handle.resizing = null;
        this.containingDiv.style.cursor = '';

        this.editor.closeActionGroup();
        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_END }); // Resizing

        //this should never be called after the mouse up because we are no longer resizing
        this.onMouseMove = function () {/*do nothing*/
        };
        this.onMouseUp = function () {/*do nothing*/
        };
    };


    /**
     * Attaches all the necessary listeners to handle a resizing action.
     *
     * @this EditFrame
     */
    function handleSelectionBoxResizing() {
        this.selectionLayer.addEventListener('mousedown', this._onResizeMouseDown.bind(this));
    }

    function handleSelectionBoxRotating () {

        this.selection.element.addEventListener('mousedown', this._onRotationMouseDown.bind(this));
    }

    var initialRotation;
    var initialHandlePosition;

    proto._onRotationMouseDown = function (event) {

        //ignore anything not coming from the rotation point
        if (!isRotatePoint(event.target)) return;

        this.editor.beginActionGroup();
        this.selection.rotating = true;

        //store the initial cursor
        initialHandlePosition = this.editor.getMousePosition();

        initialRotation = this.selection.rotation || 0;

        //update the function that will handle the mousemove and mouseup events
        this.onMouseMove = this._onRotationMouseMove.bind(this);
        this.onMouseUp = this._onRotationMouseUp.bind(this);

        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_START }); // Rotating
    };

     proto._onRotationMouseMove = function (event) {

        //ignore mousemove events if the dragging state hasn't been activated
        if (!this.selection.rotating) return;

        var cursor = this.editor.getMousePosition();
        var position = this.markup.getClientPosition();

        var r = getAngleBetweenPoints(position, cursor);
        var r2 = getAngleBetweenPoints(position, initialHandlePosition);
        var rotation = r - r2 + initialRotation;

        // TODO: Make a mechanism to configure and use this feature from Markups Core.
        if (this.editor.input.snapRotations) {
            var snap = namespaceUtils.degreesToRadians(22.5);
            rotation = Math.ceil(rotation / snap) * snap;
        }

         //pass rotation as degrees
         updateSelectorBoxPosition.bind(this)(this.selection.x, this.selection.y, rotation);

        //convert to radians
        var setRotation = new namespace.SetRotation(this.editor, this.markup, rotation);
        setRotation.execute();
    };

    proto._onRotationMouseUp = function (event) {

        this.selection.rotating = false;
        initialRotation = null;
        initialHandlePosition = null;
        this.editor.closeActionGroup();
        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_END }); // Rotating
    };

    /**
     * Attaches double click listener and pass events to markup, markups such as text use it to enter text edit
     * mode.
     *
     * @this EditFrame
     */
    function handleSelectionDoubleClick() {

        var doubleClick = function (event) {
            this.selection.dragging = false;
            var editMode = this.editor.editMode;
            editMode && editMode.onMouseDoubleClick(this.markup);
        }.bind(this);

        var selectorBoxWrapper = this.selectionLayer;
        selectorBoxWrapper.addEventListener('dblclick', doubleClick);
    }

    function togglePointerEvents(element, state) {

        element.style.pointerEvents = state ? 'auto' : 'none';
    }

    function getAngleBetweenPoints (p1, p2) {

        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    }

     function matchesSelectorAux(domElem, selector) {
         if (domElem.matches) return domElem.matches(selector); //Un-prefixed
         if (domElem.msMatchesSelector) return domElem.msMatchesSelector(selector);  //IE
         if (domElem.mozMatchesSelector) return domElem.mozMatchesSelector(selector); //Firefox (Gecko)
         if (domElem.webkitMatchesSelector) return domElem.webkitMatchesSelector(selector); // Opera, Safari, Chrome
         return false;
     }

     namespace.EditFrame = EditFrame;

 })();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * Base class for all markups.
     *
     * A Markup is a class that is capable of rendering itself as an Svg node.<br>
     * It can also render itself into a canvas-2d context.
     * Component within {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore MarkupsCore} extension.
     *
     * Any class extending Markup should contain at least the following methods:
     * - getEditMode()
     * - set()
     * - updateStyle()
     * - setParent()
     * - setRotation()
     * - setSize()
     * - setPosition()
     * - renderToCanvas()
     * - setMetadata()
     *
     * A good reference is the rectangle markup implementation available in
     * [MarkupRectangle.js]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupRectangle}.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     *
     * @param {number} id - Identifier, populated with return value of {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getId getId()}.
     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor - Markups extension
     * @param {Array} styleAttributes - Attributes for customization. Related to {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#setStyle setStyle()}.
     * @constructor
     * @category Extensions
     */
    function Markup(id, editor, styleAttributes) {

        this.id = id;
        this.type = "";
        this.editor = editor;
        this.viewer = editor.viewer;
        this.position = {x: 0, y: 0};
        this.size = {x:0, y:0};
        this.rotation = 0;
        this.style = namespaceUtils.createStyle(styleAttributes, this.editor);
        this.style = namespaceUtils.copyStyle(editor.getDefaultStyle(), this.style);
        this.highlightColor = '#FAFF3C';
        this.constraintWidth = false;
        this.constraintHeight = false;
        this.constraintRotation = false;
        this.highlighted = false;
        this.selected = false;

        namespaceUtils.addTraitEventDispatcher(this);
    }

    /*
     * Constants
     */
    namespace.MARKUP_TYPE_ARROW = "arrow";
    namespace.MARKUP_TYPE_TEXT = "label";
    namespace.MARKUP_TYPE_RECTANGLE = "rectangle";
    namespace.MARKUP_TYPE_CIRCLE = "ellipse";
    namespace.MARKUP_TYPE_CLOUD = "cloud";
    namespace.MARKUP_TYPE_FREEHAND = "freehand";
    namespace.MARKUP_TYPE_POLYLINE = "polyline";
    namespace.MARKUP_TYPE_POLYCLOUD = "polycloud";

    /*
     * Event types
     */
    namespace.EVENT_EDITMODE_CHANGED = "EVENT_EDITMODE_CHANGED";
    namespace.EVENT_EDITMODE_ENTER   = "EVENT_EDITMODE_ENTER";
    namespace.EVENT_EDITMODE_LEAVE   = "EVENT_EDITMODE_LEAVE";

    namespace.EVENT_MARKUP_SELECTED = "EVENT_MARKUP_SELECTED";
    namespace.EVENT_MARKUP_DRAGGING = "EVENT_MARKUP_DRAGGING";
    namespace.EVENT_MARKUP_ENTER_EDITION = "EVENT_MARKUP_ENTER_EDITION";
    namespace.EVENT_MARKUP_CANCEL_EDITION = "EVENT_MARKUP_CANCEL_EDITION";
    namespace.EVENT_MARKUP_DELETE_EDITION = "EVENT_MARKUP_DELETE_EDITION";

    var proto = Markup.prototype;
    namespace.Markup = Markup;

    proto.destroy = function () {

        this.unselect();
        this.setParent(null);
    };

    /**
     * Specifies the parent layer which will contain the markup.
     * @param {HTMLElement} parent
     */
    proto.setParent = function(parent) {

        var div = this.shape;
        div.parentNode && div.parentNode.removeChild(div);
        parent && parent.appendChild(div);
    };

    /**
     * Clones (deep-copy) the markup. Used internally by the copy/cut/paste mechanism in
     * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore MarkupsCore}.
     *
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup} clone of the current markup
     */
    proto.clone = function() {

        var clone = Object.create(this.__proto__);
        var overrides = this.getCloneOverrides();

        for (var name in this) {

            if(!this.hasOwnProperty(name)) {
                continue;
            }

            var member = this[name];

            // Is there an override for this member?
            if (overrides.hasOwnProperty(name)) {
                clone[name] = overrides[name];
                continue;
            }

            // Member has a clone function?
            if (member['clone'] instanceof Function) {
                clone[name] = member.clone();
                continue;
            }

            // Is it a function?
            if (member instanceof Function) {
                clone[name] = member.bind(clone);
                continue;
            }

            // Is it an html node?
            if (member.nodeType) {
                clone[name] = member.cloneNode(true);
                continue;
            }

            // Just a plain object?
            if (member instanceof Object) {
                clone[name] = JSON.parse(JSON.stringify(member));
                continue;
            }

            // Ok, it seems it's just a primitive type.
            clone[name] = member;
        }

        this.cloneShape(clone);
        return clone;
    };

    proto.cloneShape = function(clone) {

        clone.shape.markup = clone.shape.childNodes.item(0);
        clone.shape.hitarea = clone.shape.childNodes.item(1);
        clone.bindDomEvents();
    };

    /**
     * Used internally by
     * {@link Autodesk.Viewing.Extensions.Markups.Core.Markup#clone clone()},
     * provides a mechanism to avoid cloning specific attributes.<br>
     * Developers only need to override this method when creating new Markup types.
     * When overriding, first call the super() implementation and then include additional attribute/value pairs to it.
     * @returns {Object} containing attributes that need not to be cloned.
     */
    proto.getCloneOverrides = function() {

        return {
            viewer: this.viewer,
            editor: this.editor,
            hammer: null,
            listeners: {}
        }
    };

    /**
     * Used internally to select a markup.<br>
     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_SELECTED.
     */
    proto.select = function () {

        if (this.selected) {
            return;
        }

        this.selected = true;
        this.highlighted = false;
        this.updateStyle();
        this.fireEvent({type: namespace.EVENT_MARKUP_SELECTED, markup: this});
    };

    /**
     * Used internally to signal that the current markup has been unselected.<br>
     * No event is fired.
     */
    proto.unselect = function() {

        this.selected = false;
    };

    proto.highlight = function(highlight) {

        if (this.interactionsDisabled) {
            return;
        }

        this.highlighted = highlight;
        this.updateStyle();
    };

    /**
     * Returns a copy of the markup's style.
     * @returns {Object}
     */
    proto.getStyle = function() {

        return namespaceUtils.cloneStyle(this.style);
    };

    /**
     * Used internally to set the style object. Triggers a re-render of the markup (Svg)
     * @param {Object} style - Dictionary with key/value pairs
     */
    proto.setStyle = function(style) {

        namespaceUtils.copyStyle(style, this.style);
        this.updateStyle();
    };

    /**
     * Used internally and implemented by specific Markup types to render themselves as Svg.
     */
    proto.updateStyle = function () {

    };

    /**
     * Used internally to notify the markup that it is now being edited.<br>
     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_ENTER_EDITION.
     */
    proto.edit = function() {

        this.fireEvent({type: namespace.EVENT_MARKUP_ENTER_EDITION, markup: this});
    };

    /**
     * Used internally to signal that it is no longer being edited.<br>
     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_CANCEL_EDITION.
     */
    proto.cancel = function() {

        this.fireEvent({type: namespace.EVENT_MARKUP_CANCEL_EDITION, markup: this});
    };

    /**
     * Used internally to signal that the markup is being deleted.<br>
     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_DELETE_EDITION.
     */
    proto.deleteMarkup = function() {

        this.fireEvent({type: namespace.EVENT_MARKUP_DELETE_EDITION, markup: this});
    };

    /**
     * Used internally to get the {@link Autodesk.Viewing.Extensions.Markups.Core.EditMode EditMode}
     * associated with the current Markup.<br>
     * Implemented by classes extending this one.
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.EditMode}
     */
    proto.getEditMode = function() {

        console.warn('EditMode of markup type' + this.type + ' not defined.' );
        return null;
    };

    /**
     * Used internally to get the markup's position in browser pixel space.<br>
     * Notice that (0,0) is top left.<br>
     * See also
     * [getClientSize()]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup#getClientSize}.
     * @returns {*}
     */
    proto.getClientPosition = function() {

        var position = this.position;
        return this.editor.positionFromMarkupsToClient(position.x, position.y);
    };

    /**
     * Used internally to get the markup's bounding rect in browser pixel space.<br>
     * See also
     * [getClientPosition()]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup#getClientPosition}.
     * @returns {*}
     */
    proto.getClientSize = function () {

        var size = this.size;
        return this.editor.sizeFromMarkupsToClient(size.x, size.y);
    };

    /**
     * Changes the rotation of the markup to the given angle.
     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action
     *
     * @param {Number} angle
     */
    proto.setRotation = function(angle) {

        this.rotation = angle;
        this.updateStyle();
    };

    proto.getRotation = function () {

        return this.rotation;
    };

    /**
     * Used by the EditFrame to move the markup in Client Space coordinates
     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.
     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.
     */
    proto.setPosition = function(x,y) {

        this.position.x = x;
        this.position.y = y;

        this.updateStyle();
    };

    /**
     * Changes the position and size of the markup.
     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action
     * @param {{x: Number, y: Number}} position
     * @param {Number} width
     * @param {Number} height
     */
    proto.setSize = function (position, width, height) {

        this.position.x = position.x;
        this.position.y = position.y;
        this.size.x = width;
        this.size.y = height;

        this.updateStyle();
    };

    proto.isWidthConstrained = function() {

        return this.constraintWidth;
    };

    proto.isHeightConstrained = function() {

        return this.constraintHeight;
    };

    proto.isRotationConstrained = function() {

        return this.constraintRotation;
    };

    /**
     * Used to disable highlight on annotations while a new annotation is being created.
     * @param {Boolean} disable - Whether (mouse) interactions are enable.
     */
    proto.disableInteractions = function(disable) {

        this.interactionsDisabled = disable;
    };

    /**
     *
     * @param width
     */
    proto.setStrokeWidth = function(width) {

    };

    proto.constrainsToBounds = function(bounds) {

    };

    proto.onMouseDown = function(event) {

        if (this.interactionsDisabled) {
            return;
        }

        this.select();
        this.editor.editFrame.startDrag(event);
    };

    /**
     *
     * @param idTarget
     * @returns *
     */
    proto.generatePoint3d = function(idTarget) {

        var viewer = this.viewer;
        var polygon = this.generateBoundingPolygon();

        function checkLineSegment(a, b) {

            var point2d = namespaceUtils.checkLineSegment(a.x, a.y, b.x, b.y, idTarget);
            var point3d = point2d && viewer.clientToWorld(point2d.x, point2d.y);
            return point3d && point3d.point;
        }

        function checkPolygon(polygon) {

            var point2d = namespaceUtils.checkPolygon(polygon, idTarget);
            var point3d = point2d && viewer.clientToWorld(point2d.x, point2d.y);
            return point3d && point3d.point;
        }

        // Try to avoid expensive calculations by checking some lines segments first.
        // If line check cannot find a point the costly one by area is used.
        // A ----midAB---- B
        // |               |
        // |     center    |
        // |               |
        // C --------------D

        var xVertices = polygon.xVertices;
        var yVertices = polygon.yVertices;

        var midAB = new THREE.Vector2(xVertices[0] + xVertices[1], yVertices[0] + yVertices[1]).multiplyScalar(0.5);
        var midAC = new THREE.Vector2(xVertices[0] + xVertices[3], yVertices[0] + yVertices[3]).multiplyScalar(0.5);
        var midDB = new THREE.Vector2(xVertices[2] + xVertices[1], yVertices[2] + yVertices[1]).multiplyScalar(0.5);
        var midDC = new THREE.Vector2(xVertices[2] + xVertices[3], yVertices[2] + yVertices[3]).multiplyScalar(0.5);
        var center = midAC.clone().add(midDB).multiplyScalar(0.5);

        var point3d =
            checkLineSegment(center, midDB) ||
            checkLineSegment(center, midAC) ||
            checkLineSegment(center, midAB) ||
            checkLineSegment(center, midDC);

        return point3d || checkPolygon(polygon);
    };

    /**
     *
     * @returns {{min: {x: number, y: number}, max: {x: number, y: number}}}
     */
    proto.generateBoundingBox = function() {

        var boundingBox = {min: {x: 0,y: 0}, max: {x: 0, y: 0}};

        // Get bounding box from markup bounding polygon.
        var polygon = this.generateBoundingPolygon();

        var vertexCount = polygon.vertexCount;
        var xVertices = polygon.xVertices;
        var yVertices = polygon.yVertices;

        var bbX0 = Number.POSITIVE_INFINITY;
        var bbY0 = Number.POSITIVE_INFINITY;
        var bbX1 = Number.NEGATIVE_INFINITY;
        var bbY1 = Number.NEGATIVE_INFINITY;

        for(var i = 0; i < vertexCount; ++i) {

            var bbX = xVertices[i];
            var bbY = yVertices[i];

            bbX0 = Math.min(bbX0, bbX);
            bbY0 = Math.min(bbY0, bbY);
            bbX1 = Math.max(bbX1, bbX);
            bbY1 = Math.max(bbY1, bbY);
        }

        boundingBox.min.x = bbX0;
        boundingBox.min.y = bbY0;
        boundingBox.max.x = bbX1;
        boundingBox.max.y = bbY1;

        return boundingBox;
    };

    /**
     *
     * @returns {{vertexCount: number, xVertices: Float32Array, yVertices: Float32Array}}
     */
    proto.generateBoundingPolygon = function() {

        var position = this.getClientPosition();
        var halfSize = this.getClientSize();

        halfSize.x *= 0.5;
        halfSize.y *= 0.5;

        var lt = new THREE.Vector3(-halfSize.x,-halfSize.y).add(position);
        var rt = new THREE.Vector3( halfSize.x,-halfSize.y).add(position);
        var rb = new THREE.Vector3( halfSize.x, halfSize.y).add(position);
        var lb = new THREE.Vector3(-halfSize.x, halfSize.y).add(position);

        if (this.rotation !== 0) {

            var m1 = new THREE.Matrix4().makeTranslation(-position.x, -position.y, 0);
            var m2 = new THREE.Matrix4().makeRotationZ(this.rotation);
            var m3 = new THREE.Matrix4().makeTranslation(position.x, position.y, 0);
            var transform = m3.multiply(m2).multiply(m1);

            lt.applyMatrix4(transform);
            rt.applyMatrix4(transform);
            rb.applyMatrix4(transform);
            lb.applyMatrix4(transform);
        }

        return { // packed for fast access in test algorithm.
            vertexCount: 4,
            xVertices : new Float32Array([lt.x, rt.x, rb.x, lb.x]),
            yVertices : new Float32Array([lt.y, rt.y, rb.y, lb.y])
        };
    };

    /**
     * Implemented by extending classes.<br>
     * Gets called automatically when
     * [generateData()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#generateData}
     * @returns {null|Element} - Either null (default) or the metadata Svg node
     */
    proto.setMetadata = function() {

        return null; // No metadata is injected by default.
    };

    proto.bindDomEvents = function() {

        if (namespaceUtils.isTouchDevice()) {

            this.hammer = new Hammer.Manager(this.shape, {
                recognizers: [
                    [Hammer.Tap, { event: 'singletap', pointers: 1, threshold: 2 } ]
                ],
                inputClass: Hammer.TouchInput
            });

            this.onSingleTapBinded = function(event) {

                this.onMouseDown(event);
            }.bind(this);

            this.hammer.on("singletap", this.onSingleTapBinded);
        }

        this.shape.addEventListener("mousedown", this.onMouseDown.bind(this), true );
        this.shape.addEventListener("mouseout", function(){this.highlight(false);}.bind(this));
        this.shape.addEventListener("mouseover", function(){this.highlight(true);}.bind(this));
    };

    proto.renderToCanvas = function(ctx) {

        var m0 = new THREE.Matrix4().makeRotationZ(-this.rotation);
        var m1 = new THREE.Matrix4().makeTranslation(this.position.x, this.position.y, 0);
        var transform = m1.multiply(m0);

        namespaceUtils.renderToCanvas(this.editor, ctx, this.getPath(), this.style, transform);
    };

    proto.getPath = function() {

    };

    proto.getTransform = function() {

        return [
            'translate(', this.position.x, ',', this.position.y, ')',
            'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ')'
        ].join(' ');
    };

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param id
     * @param editor
     * @constructor
     */
    function MarkupArrow(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_ARROW;
        this.constraintHeight = true;

        // Create head and tail.
        this.head = new THREE.Vector3();
        this.tail = new THREE.Vector3();
        this.size.y = this.style['stroke-width'] * 3;
        this.shape = namespaceUtils.createMarkupPathSvg();

        this.bindDomEvents();
    }

    MarkupArrow.prototype = Object.create(namespace.Markup.prototype);
    MarkupArrow.prototype.constructor = MarkupArrow;

    var proto = MarkupArrow.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModeArrow(this.editor);
    };

    /**
     * Sets top-left and bottom-right values in client space coordinates (2d).
     * Notice that for the arrow, the top left is the "tail" of the arrow and
     * the bottom right is the "head" of it.
     *
     * @param {Number} xO - tail
     * @param {Number} yO - tail
     * @param {Number} xF - head
     * @param {Number} yF - head
     */
    proto.set = function(xO, yO, xF, yF) {

        var vO = new THREE.Vector2(xO, yO);
        var vF = new THREE.Vector2(xF, yF);
        var vDir = vF.clone().sub(vO).normalize();

        this.size.x = vO.distanceTo(vF); // TODO: Clamp min length
        this.rotation = Math.acos(vDir.dot(new THREE.Vector2(1,0)));
        this.rotation = yF > yO ? (Math.PI*2)-this.rotation : this.rotation;

        var head = this.head;
        var tail = this.tail;

        head.set(xF, yF, 0);
        tail.set(xO, yO, 0);

        this.position.x = tail.x + (head.x - tail.x) * 0.5;
        this.position.y = tail.y + (head.y - tail.y) * 0.5;

        this.updateStyle();
    };

    /**
     * Changes the rotation of the markup to the given angle.
     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action
     *
     * @param {Number} angle
     */
    proto.setRotation = function(angle) {

        this.rotation = angle;

        var xF = Math.cos(-angle);
        var yF = Math.sin(-angle);
        var vFDir = new THREE.Vector2(xF, yF); // already normalized
        vFDir.multiplyScalar(this.size.x*0.5);

        var vCenter = new THREE.Vector2(this.position.x, this.position.y);
        var vO = vCenter.clone().sub(vFDir);
        var vF = vCenter.clone().add(vFDir);

        this.head.set(vF.x, vF.y, 0);
        this.tail.set(vO.x, vO.y, 0);

        this.updateStyle();
    };

    /**
     * Changes the position and size of the markup.
     * This gets called by the namespace.SetSize edit action
     * @param {{x: Number, y: Number}} position - arrow's center
     * @param {Number} width - Arrow's length
     * @param {Number} height - We ignore this one because we use the arrow's stroke width instead
     */
    proto.setSize = function(position, width, height) {

        var xF = Math.cos(-this.rotation);
        var yF = Math.sin(-this.rotation);
        var vFDir = new THREE.Vector2(xF, yF); // already normalized
        vFDir.multiplyScalar(width*0.5);

        var vCenter = new THREE.Vector2(position.x, position.y);
        var vO = vCenter.clone().sub(vFDir);
        var vF = vCenter.clone().add(vFDir);

        this.head.set(vF.x, vF.y, 0);
        this.tail.set(vO.x, vO.y, 0);

        this.position.x = position.x;
        this.position.y = position.y;
        this.size.x = width;

        this.updateStyle();
    };

    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;
        var strokeWidth = style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var transform = this.getTransform();

        this.size.y = strokeWidth * 3;
        this.style['fill-color'] = style['stroke-color'];
        this.style['fill-opacity'] = style['stroke-opacity'];

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd', this.getPath().join(' '));
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    /**
     * Used by the EditFrame to move the markup in Client Space coordinates
     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.
     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.
     */
    proto.setPosition = function (x, y) {

        var head = this.head;
        var tail = this.tail;

        var dx = head.x - tail.x;
        var dy = head.y - tail.y;

        var xo = x + dx * 0.5;
        var yo = y + dy * 0.5;

        head.x = xo;
        head.y = yo;

        tail.x = xo - dx;
        tail.y = yo - dy;

        this.position.x = tail.x + (head.x - tail.x) * 0.5;
        this.position.y = tail.y + (head.y - tail.y) * 0.5;

        this.updateStyle();
    };

    proto.generatePoint3d = function(idTarget) {

        var head = this.editor.positionFromMarkupsToClient(this.head.x, this.head.y);
        var tail = this.editor.positionFromMarkupsToClient(this.tail.x, this.tail.y);

        var direction = head.clone().sub(tail).normalize();

        var point2d = namespaceUtils.checkLineSegment(head.x, head.y, head.x + direction.x * 200, head.y + direction.y * 200, idTarget);
        var point3d = point2d && this.viewer.clientToWorld(point2d.x, point2d.y);

        return point3d && point3d.point;
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.head = [this.head.x, this.head.y].join(" ");
        metadata.tail = [this.tail.x, this.tail.y].join(" ");
        metadata.rotation = String(this.rotation);

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    proto.getPath = function() {

        // To build the arrow we need 7 points in total
        // The 'default' arrow built here has the following characteristics:
        //
        // 1. It is built horizontally facing right
        // 2. It's bounding rectangle has length: this.size.x
        // 3. It's bounding rectangle has height: 2 * this.strokeWidth
        // 4. The arrow tail's thickness is: this.strokeWidth
        // 5. The arrow head's length is: 2/3 of (point 3)
        // 6. The arrow head's thickness is: (point 3)
        // 7. The arrow generated is centered in its local (0,0), meaning that
        //    two points are placed with negative x values, and all other have
        //    positive x values:
        //
        //                            (3)\
        //                              \  \
        //             (1)-------------(2)   \
        //              |         (0)        (4)
        //             (7)-------------(6)   /
        //                              /  /
        //                            (5)/
        //

        var sizeX = this.size.x;
        var sizeY = this.size.y;
        var sizeYOver3 = sizeY/3;
        var strokeWidth = this.style['stroke-width'];
        var tailW = sizeX - strokeWidth * 3;
        var headW = sizeX - tailW;
        var spikeOffset = strokeWidth * 0.3;

        return [
            'M', -sizeX * 0.5        , -sizeY * 0.5 + sizeYOver3,    // (1)
            'l',  tailW              ,  0,                           // (2)
            'l', -spikeOffset        , -sizeYOver3,                  // (3)
            'l',  headW + spikeOffset,  sizeYOver3 * 1.5,            // (4)
            'l', -headW - spikeOffset,  sizeYOver3 * 1.5,            // (5)
            'l',  spikeOffset        , -sizeYOver3,                  // (6)
            'l', -tailW              ,  0,                           // (7)
            'z'
        ];
    };

    namespace.MarkupArrow = MarkupArrow;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param id
     * @param editor
     * @constructor
     */
    function MarkupCircle(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_CIRCLE;
        this.shape = namespaceUtils.createMarkupPathSvg();

        this.bindDomEvents();
    }

    MarkupCircle.prototype = Object.create(namespace.Markup.prototype);
    MarkupCircle.prototype.constructor = MarkupCircle;

    var proto = MarkupCircle.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModeCircle(this.editor);
    };

    proto.set = function(position, size) {

        this.setSize(position, size.x, size.y);
    };

    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;
        var path = this.getPath().join(' ');

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var fillColor = namespaceUtils.composeRGBAString(style['fill-color'], style['fill-opacity']);
        var transform = this.getTransform();

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd', path);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', fillColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.rotation = String(this.rotation);

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    proto.getPath = function() {

        var size = this.size;
        if (size.x === 1 || size.y === 1) {
            return [''];
        }

        var strokeWidth = this.style['stroke-width'];

        var w = size.x;
        var h = size.y;

        var ellipseW = w - strokeWidth;
        var ellipseH = h - strokeWidth;

        var halfStrokeWidth  = strokeWidth * 0.5;

        var ellipseX = halfStrokeWidth - w * 0.5;
        var ellipseY = 0;

        var path = [];
        namespaceUtils.createEllipsePath(ellipseX, ellipseY, ellipseW, ellipseH, false, path);

        return path;
    };

    namespace.MarkupCircle = MarkupCircle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param id
     * @param editor
     * @constructor
     */
    function MarkupCloud(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-linejoin', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_CLOUD;
        this.shape = namespaceUtils.createMarkupPathSvg();

        this.bindDomEvents();
    }

    MarkupCloud.prototype = Object.create(namespace.Markup.prototype);
    MarkupCloud.prototype.constructor = MarkupCloud;

    var proto = MarkupCloud.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModeCloud(this.editor);
    };

    /**
     * Sets position and size in markup space coordinates.
     * @param {Object} position
     * @param {Object} size
     */
    proto.set = function(position, size) {

        this.setSize(position, size.x, size.y);
    };

    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;
        var path = this.getPath().join(' ');

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var fillColor = namespaceUtils.composeRGBAString(style['fill-color'], style['fill-opacity']);
        var transform = this.getTransform();

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd', path);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', fillColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.rotation = String(this.rotation);

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    /**
     * Helper function that creates intermediate points given the
     * current position and size.
     * @returns {Array}
     */
    proto.getPath = function() {

        var position = this.position;
        var size = this.size;
        var strokeWidth = this.style['stroke-width'];
        var radius = strokeWidth * 2;

        function createArcTo(x, y, xRadius, yRadius, path) {

            path.push('a');
            path.push(xRadius);
            path.push(yRadius);
            path.push(0);
            path.push(1);
            path.push(1);
            path.push(x);
            path.push(y);

            return path;
        }

        function createCorner(corner, xRadius, yRadius, strokeWidth, path) {

            switch(corner) {

                case 'LT':
                    return createArcTo( xRadius,-yRadius, xRadius, yRadius, path);
                    break;

                case 'RT':
                    return createArcTo( xRadius, yRadius, xRadius, yRadius, path);
                    break;

                case 'RB':
                    return createArcTo(-xRadius, yRadius, xRadius, yRadius, path);
                    break;

                case 'LB':
                    return createArcTo(-xRadius,-yRadius, xRadius, yRadius, path);
                    break;
            }
        }

        function getSideParameters(x1, x2, radius, strokeWidth) {

            var diameter = radius * 2;
            var length = Math.abs(x2 - x1 - strokeWidth);
            var count = Math.round(length / diameter);

            diameter += (length - diameter * count) / count;
            radius = diameter * 0.5;

            var xValueInset = diameter * 0.05;
            var yValueOffset = radius * 3.5 / 3.0;

            return {
                count: count,
                radius: radius,
                diameter: diameter,
                p1: {x: xValueInset, y: -yValueOffset },
                p2: {x: diameter - xValueInset, y: -yValueOffset},
                p3: {x: diameter, y: 0}
            };
        }

        function createTSide(hSidesParameters, path){

            var sp = hSidesParameters;
            for(var i = 0; i < sp.count; ++i) {

                path.push('c');
                path.push(sp.p1.x);
                path.push(sp.p1.y);
                path.push(sp.p2.x);
                path.push(sp.p2.y);
                path.push(sp.p3.x);
                path.push(sp.p3.y);
            }

            return path;
        }

        function createRSide(vSidesParameters, path){

            var sp = vSidesParameters;
            for(var i = 0; i < sp.count; ++i) {
                path.push('c');
                path.push(-sp.p1.y);
                path.push(sp.p1.x);
                path.push(-sp.p2.y);
                path.push(sp.p2.x);
                path.push(-sp.p3.y);
                path.push(sp.p3.x);
            }

            return path;
        }

        function createBSide(hSidesParameters, path){

            var sp = hSidesParameters;
            for(var i = 0; i < sp.count; ++i) {
                path.push('c');
                path.push(-sp.p1.x);
                path.push(-sp.p1.y);
                path.push(-sp.p2.x);
                path.push(-sp.p2.y);
                path.push(-sp.p3.x);
                path.push(-sp.p3.y);
            }

            return path;
        }

        function createLSide(vSidesParameters, path){

            var sp = vSidesParameters;
            for(var i = 0; i < sp.count; ++i) {
                path.push('c');
                path.push(sp.p1.y);
                path.push(-sp.p1.x);
                path.push(sp.p2.y);
                path.push(-sp.p2.x);
                path.push(sp.p3.y);
                path.push(-sp.p3.x);
            }

            return path;
        }

        var l = position.x;
        var t = position.y;
        var r = position.x + size.x;
        var b = position.y + size.y;

        var minSize = radius * 5;
        var path = [];

        if (size.x < minSize || size.y < minSize) {

            var w = size.x - strokeWidth;
            var h = size.y - strokeWidth;
            var x =-size.x * 0.5;
            var y = 0;

            namespaceUtils.createEllipsePath(x, y, w, h, false, path);
        } else {

            var hSidesParameters = getSideParameters(l, r, radius, strokeWidth);
            var vSidesParameters = getSideParameters(t, b, radius, strokeWidth);

            var cornerSizeX = hSidesParameters.diameter;
            var cornerSizeY = vSidesParameters.diameter;
            var cornerRadiusX = hSidesParameters.radius;
            var cornerRadiusY = vSidesParameters.radius;

            hSidesParameters = getSideParameters(l + cornerSizeX, r - cornerSizeX, radius, strokeWidth);
            vSidesParameters = getSideParameters(t + cornerSizeY, b - cornerSizeY, radius, strokeWidth);

            var halfStrokeWidth = strokeWidth * 0.5;
            var x =-size.x * 0.5 + halfStrokeWidth + cornerRadiusX;
            var y =-size.y * 0.5 + halfStrokeWidth + cornerRadiusY * 2;

            path.push('M');
            path.push(x);
            path.push(y);

            createCorner('LT', cornerRadiusX, cornerRadiusY, strokeWidth, path);
            createTSide(hSidesParameters, path);
            createCorner('RT', cornerRadiusX, cornerRadiusY, strokeWidth, path);
            createRSide(vSidesParameters, path);
            createCorner('RB', cornerRadiusX, cornerRadiusY, strokeWidth, path);
            createBSide(hSidesParameters, path);
            createCorner('LB', cornerRadiusX, cornerRadiusY, strokeWidth, path);
            createLSide(vSidesParameters, path);
        }

        path.push('z');
        return path;
    };

    namespace.MarkupCloud = MarkupCloud;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param id
     * @param editor
     * @constructor
     */
    function MarkupFreehand(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-color','stroke-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_FREEHAND;
        this.shape = namespaceUtils.createMarkupPathSvg();

        this.bindDomEvents();
    }

    MarkupFreehand.prototype = Object.create(namespace.Markup.prototype);
    MarkupFreehand.prototype.constructor = MarkupFreehand;

    var proto = MarkupFreehand.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModeFreehand(this.editor);
    };

    /**
     * Sets top-left and bottom-right values in client space coordinates (2d).
     *
     * @param position
     * @param size
     * @param locations
     */
    proto.set = function(position, size, locations) {

        this.rotation = 0; // Reset angle //
        this.locations = locations.concat();

        this.size.x = (size.x === 0) ? 1 : size.x;
        this.size.y = (size.y === 0) ? 1 : size.y;

        this.setSize(position, size.x, size.y);
        this.updateStyle();
    };

    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;
        var path = this.getPath().join(' ');

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var fillColor = 'none';
        var transform = this.getTransform();

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd', path);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', fillColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    /**
     * Changes the position and size of the markup.
     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action
     * @param {{x: Number, y: Number}} position
     * @param {Number} width
     * @param {Number} height
     */
    proto.setSize = function (position, width, height) {

        width = (width === 0 ? 1 : width);
        height = (height === 0 ? 1 : height);

        var locations = this.locations;
        var locationsCount = locations.length;

        var scaleX = width / this.size.x;
        var scaleY = height / this.size.y;

        for(var i = 0; i < locationsCount; ++i) {

            var point = locations[i];

            point.x *= scaleX;
            point.y *= scaleY;
        }

        this.position.x = position.x;
        this.position.y = position.y;

        this.size.x = width;
        this.size.y = height;

        this.updateStyle();
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.rotation = String(this.rotation);
        metadata.locations = this.locations.map(function(point){
            return [point.x, point.y].join(" ");
        }).join(" ");

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    proto.getPath = function() {

        var path = [];
        var locations = this.locations;
        var locationsCount = locations.length;

        if (locationsCount > 1) {

            path.push('M');
            path.push(locations[0].x);
            path.push(locations[0].y);

            for (var i = 1; i < locationsCount; ++i) {

                var locationA = locations[i - 1];
                var locationB = locations[i];

                path.push('l');
                path.push(locationB.x - locationA.x);
                path.push(locationB.y - locationA.y);
            }
        }

        return path;
    };

    namespace.MarkupFreehand = MarkupFreehand;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param id
     * @param editor
     * @constructor
     */
    function MarkupPolyline(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-color','stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_POLYLINE;
        this.shape = namespaceUtils.createMarkupPathSvg('path');

        this.bindDomEvents();
    }

    MarkupPolyline.prototype = Object.create(namespace.Markup.prototype);
    MarkupPolyline.prototype.constructor = MarkupPolyline;

    var proto = MarkupPolyline.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModePolyline(this.editor);
    };

    /**
     * Sets top-left and bottom-right values in client space coordinates (2d).
     *
     * @param position
     * @param size
     * @param locations
     * @param closed
     */
    proto.set = function(position, size, locations, closed) {

        this.rotation = 0; // Reset angle //
        this.locations = locations.concat();

        this.size.x = (size.x === 0) ? 1 : size.x;
        this.size.y = (size.y === 0) ? 1 : size.y;

        this.closed = closed;

        this.setSize(position, size.x, size.y);
        this.updateStyle();
    };


    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var fillColor = this.closed ? namespaceUtils.composeRGBAString(style['fill-color'], style['fill-opacity']) : 'none';
        var transform = this.getTransform();

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd',  this.getPath().join(' '));
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', fillColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    /**
     * Changes the position and size of the markup.
     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action
     * @param {{x: Number, y: Number}} position
     * @param {Number} width
     * @param {Number} height
     */
    proto.setSize = function (position, width, height) {

        width = (width === 0 ? 1 : width);
        height = (height === 0 ? 1 : height);

        var locations = this.locations;
        var locationsCount = locations.length;

        var scaleX = width / this.size.x;
        var scaleY = height / this.size.y;

        for(var i = 0; i < locationsCount; ++i) {

            var point = locations[i];

            point.x *= scaleX;
            point.y *= scaleY;
        }

        this.position.x = position.x;
        this.position.y = position.y;

        this.size.x = width;
        this.size.y = height;

        this.updateStyle();
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.rotation = String(this.rotation);
        metadata.locations = this.locations.map(function(point){
            return [point.x, point.y].join(" ");
        }).join(" ");

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    proto.getPath = function() {

        var path = [];
        var locations = this.locations;
        var locationsCount = locations.length;

        if (locationsCount === 0) {
            return ' ';
        }

        path.push('M');
        path.push(locations[0].x);
        path.push(locations[0].y);

        for (var i = 1; i < locationsCount; ++i) {

            var locationA = locations[i - 1];
            var locationB = locations[i];

            path.push('l');
            path.push(locationB.x - locationA.x);
            path.push(locationB.y - locationA.y);
        }

        this.closed && path.push('z');
        return path;
    };

    namespace.MarkupPolyline = MarkupPolyline;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param id
     * @param editor
     * @constructor
     */
    function MarkupPolycloud(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-color','stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_POLYCLOUD;
        this.locations = [];
        this.shape = namespaceUtils.createMarkupPathSvg();

        this.bindDomEvents();
    }

    MarkupPolycloud.prototype = Object.create(namespace.Markup.prototype);
    MarkupPolycloud.prototype.constructor = MarkupPolycloud;

    var proto = MarkupPolycloud.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModePolycloud(this.editor);
    };

    /**
     *
     * Sets top-left and bottom-right values in client space coordinates (2d).
     * @param position
     * @param size
     * @param locations
     * @param closed
     */
    proto.set = function(position, size, locations, closed) {

        this.rotation = 0; // Reset angle //
        this.locations = locations.concat();

        this.size.x = (size.x === 0) ? 1 : size.x;
        this.size.y = (size.y === 0) ? 1 : size.y;

        this.closed = closed;

        this.setSize(position, size.x, size.y);
        this.updateStyle();
    };

    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;
        var path = this.getPath().join(' ');

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var fillColor = this.closed ? namespaceUtils.composeRGBAString(style['fill-color'], style['fill-opacity']) : 'none';
        var transform = this.getTransform();

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd', path);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', fillColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    /**
     * Changes the position and size of the markup.
     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action
     * @param {{x: Number, y: Number}} position
     * @param {Number} width
     * @param {Number} height
     */
    proto.setSize = function (position, width, height) {

        width = (width === 0 ? 1 : width);
        height = (height === 0 ? 1 : height);

        var locations = this.locations;
        var locationsCount = locations.length;

        var scaleX = width / this.size.x;
        var scaleY = height / this.size.y;

        for(var i = 0; i < locationsCount; ++i) {

            var point = locations[i];

            point.x *= scaleX;
            point.y *= scaleY;
        }

        this.position.x = position.x;
        this.position.y = position.y;

        this.size.x = width;
        this.size.y = height;

        this.updateStyle();
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.rotation = String(this.rotation);
        metadata.locations = this.locations.map(function(point){
            return [point.x, point.y].join(" ");
        }).join(" ");

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    proto.getPath = function() {

        function getOrientation(locations) {

            switch (locations.length) {

                case 0:
                case 1:
                    return 1;
                case 2:

                    var fstPoint = locations[0];
                    var sndPoint = locations[1];

                    return fstPoint.y > sndPoint.y ? 1 : -1;
                default:

                    var pointA = locations[0];
                    var pointB = locations[1];
                    var pointC = locations[2];

                    var orientation =
                        (pointB.x - pointA.x) * (pointB.y + pointA.y) +
                        (pointC.x - pointB.x) * (pointC.y + pointB.y);

                    return orientation < 0 ? 1 : -1;
            }
        }

        function getSides(locations, closed) {

            var locationsCount = locations.length;

            var sides = [];
            var sidesCount = locationsCount - (closed ? 0 : 1);

            for(var i = 0; i < sidesCount; ++i) {

                var locationA = locations[i];
                var locationB = locations[(i+1)%locationsCount];

                var dx = locationB.x - locationA.x;
                var dy = locationB.y - locationA.y;

                var length = Math.sqrt(dx * dx + dy * dy);

                sides.push({
                    index: i,
                    pointA: new THREE.Vector3(locationA.x, locationA.y, 0),
                    pointB: new THREE.Vector3(locationB.x, locationB.y, 0),
                    vecAB:  new THREE.Vector3(dx / length, dy / length, 0),
                    vecBA:  new THREE.Vector3(-dx / length, -dy / length, 0),
                    length: length
                });
            }

            return sides;
        }

        function updateSides(sides, corners, radius) {

            var diameter = radius * 2;
            var sidesCount = sides.length;

            for(var i = 0; i < sidesCount; ++i) {

                var side = sides[i];
                var cornerA = corners[i];
                var cornerB = corners[(i+1)%sidesCount];

                side.bodyA = side.vecAB.clone().multiplyScalar(cornerA.radius).add(side.pointA);
                side.bodyB = side.vecBA.clone().multiplyScalar(cornerB.radius).add(side.pointB);

                side.body = side.bodyB.clone().sub(side.bodyA).length();
                side.bodyCount = Math.round(side.body / diameter);
                side.bodyDiameter = diameter + (side.body - diameter * side.bodyCount) / side.bodyCount;
                side.bodyRadius = side.bodyDiameter * 0.5;
            }
        }

        function getCorners(sides, radius, closed) {

            var corners = [];
            var sidesCount = sides.length;

            for(var i = 0; i < sidesCount; ++i) {

                var sideA = sides[i !== 0 ? i-1 : sidesCount-1];
                var sideB = sides[i];
                var large = sideA.vecBA.clone().cross(sideB.vecAB).z < 0;

                var sidesTooShort = sideA.length < radius || sideB.length < radius;
                if (sidesTooShort || (i === 0 && !closed)) {

                    corners.push({
                        pointA: sideB.pointA.clone(),
                        pointB: sideB.pointA.clone(),
                        radius: 0,
                        large: false
                    });
                } else {

                    corners.push({
                        pointA: sideB.pointA.clone().add(sideA.vecBA.clone().multiplyScalar(radius)),
                        pointB: sideB.pointA.clone().add(sideB.vecAB.clone().multiplyScalar(radius)),
                        radius: radius,
                        large: large
                    });
                }
            }

            return corners;
        }

        function createSidePath(side, orientation, path) {

            var radius = side.bodyRadius;
            var diameter = side.bodyDiameter;

            var xValueInset = diameter * 0.05;
            var yValueOffset = radius * 3.5 / 3.0;

            var p1 = new THREE.Vector3(xValueInset, orientation * -yValueOffset);
            var p2 = new THREE.Vector3(diameter - xValueInset, orientation * -yValueOffset);
            var p3 = new THREE.Vector3(diameter, 0);

            var angle = Math.acos(side.vecAB.x) * (side.vecAB.y < 0 ? -1 : 1);
            var rotation = new THREE.Matrix4().makeRotationZ(angle);

            p1.applyMatrix4(rotation);
            p2.applyMatrix4(rotation);
            p3.applyMatrix4(rotation);

            var count = side.bodyCount;
            for (var i = 0; i < count; ++i) {

                path.push('c');
                path.push(p1.x);
                path.push(p1.y);
                path.push(p2.x);
                path.push(p2.y);
                path.push(p3.x);
                path.push(p3.y);
            }
        }

        function createCornerPath(corner, first, orientation, path) {

            if (first) {

                path.push('M');
                path.push(corner.pointA.x);
                path.push(corner.pointA.y);
            }

            var large = orientation === 1 ? corner.large : !corner.large;

            if (corner.radius !== 0) {

                path.push('a');
                path.push(corner.radius);
                path.push(corner.radius);
                path.push(0);
                path.push(large ? 1 : 0);
                path.push(orientation === 1 ? 1 : 0);
                path.push(corner.pointB.x - corner.pointA.x);
                path.push(corner.pointB.y - corner.pointA.y);
            }
            return path;
        }


        var strokeWidth = this.style['stroke-width'];
        var radius = strokeWidth * 2;
        var orientation = getOrientation(this.locations);
        var closed = this.closed;
        var path = [];

        var sides = getSides(this.locations, closed);
        var corners = getCorners(sides, radius, closed);
        var cornersCount = corners.length;

        updateSides(sides, corners, radius);

        for(var i = 0; i < cornersCount; ++i) {

            createCornerPath(corners[i], i === 0, orientation, path);
            createSidePath(sides[i], orientation, path);
        }

        closed && path.push('z');
        return path;
    };

    namespace.MarkupPolycloud = MarkupPolycloud;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * Rectangle markup.
     *
     * Implements a Rectangle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.
     * Included in documentation as an example of how to create
     * a specific markup type. Developers are encourage to look into this class's source code and copy
     * as much code as they need. Find link to source code below.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     * @extends Autodesk.Viewing.Extensions.Markups.Core.Markup
     *
     * @param {number} id
     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor
     * @constructor
     * @category Extensions
     */
    function MarkupRectangle(id, editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_RECTANGLE;
        this.shape = namespaceUtils.createMarkupPathSvg();

        this.bindDomEvents();
    }

    MarkupRectangle.prototype = Object.create(namespace.Markup.prototype);
    MarkupRectangle.prototype.constructor = MarkupRectangle;

    var proto = MarkupRectangle.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModeRectangle(this.editor);
    };

    /**
     * Sets position and size in markup space coordinates
     * @param {Object} position
     * @param {Object} size
     */
    proto.set = function(position, size) {

        this.position.x = position.x;
        this.position.y = position.y;
        this.size.x = size.x;
        this.size.y = size.y;

        this.updateStyle();
    };

    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        var style = this.style;
        var shape = this.shape;
        var path = this.getPath().join(' ');

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
        var fillColor = namespaceUtils.composeRGBAString(style['fill-color'], style['fill-opacity']);
        var transform = this.getTransform();

        namespaceUtils.setAttributeToMarkupSvg(shape, 'd', path);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'stroke', strokeColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', fillColor);
        namespaceUtils.setAttributeToMarkupSvg(shape, 'transform', transform);
        namespaceUtils.updateMarkupPathSvgHitarea(shape, this.editor);
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.rotation = String(this.rotation);

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    proto.getPath = function() {

        var strokeWidth = this.style['stroke-width'];

        var w = this.size.x - strokeWidth;
        var h = this.size.y - strokeWidth;
        var x =-w * 0.5;
        var y =-h * 0.5;

        var path = [];
        namespaceUtils.createRectanglePath(x, y, w, h, false, path);

        return path;
    };

    namespace.MarkupRectangle = MarkupRectangle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * Arrow Markup.
     * @constructor
     */
    function MarkupText(id, editor, size) {

        var styleAttributes = [
            'font-size',
            'stroke-color',
            'stroke-opacity',
            'fill-color',
            'fill-opacity',
            'font-family',
            'font-style',
            'font-weight'
        ];

        namespace.Markup.call(this, id, editor, styleAttributes);

        this.type = namespace.MARKUP_TYPE_TEXT;
        this.shape = namespaceUtils.createMarkupTextSvg();
        this.constraintRotation = true;
        this.size.x = size.x;
        this.size.y = size.y;
        this.currentText = "";
        this.currentTextLines = [""];
        this.textDirty = true;
        this.textSize = {x: 0, y: 0};

        // Note: We could have this property be a style property.
        // However, there is no need for this property to be exposed to the user for alteration
        // This value is a percentage of the font size used to offset vertically 2 text lines
        // of the same paragraph.
        // Notice that this value is used by EditorTextInput.js
        this.lineHeight = 130;

        this.bindDomEvents();
    }

    MarkupText.prototype = Object.create(namespace.Markup.prototype);
    MarkupText.prototype.constructor = MarkupText;

    var proto = MarkupText.prototype;

    proto.getEditMode = function() {

        return new namespace.EditModeText(this.editor);
    };

    /**
     *
     * @param {String} position
     * @param {String} size
     * @param {String} textString
     * @param {Array} textLines
     */
    proto.set = function(position, size, textString, textLines) {

        this.position.x = position.x;
        this.position.y = position.y;
        this.size.x = size.x;
        this.size.y = size.y;

        this.setText(textString, textLines);
    };

    proto.setSize = function(position, width, height) {

        this.position.x = position.x;
        this.position.y = position.y;
        this.size.x = width;
        this.size.y = height;

        this.updateStyle();
    };

    proto.setStyle = function(style) {

        namespaceUtils.copyStyle(style, this.style);
        this.updateStyle();
    };

    /**
     *
     * @param {String} text
     */
    proto.setText = function(text) {

        this.currentText = text;
        this.updateStyle();
    };

    /**
     * Returns the raw string value
     * @returns {String}
     */
    proto.getText = function() {

        return this.currentText;
    };

    /**
     * Returns a shallow copy of the text lines used for rendering SVG text
     * @returns {Array.<String>}
     */
    proto.getTextLines = function() {

        return this.currentTextLines.concat();
    };

    /**
     * Applies data values into DOM element style/attribute(s)
     *
     */
    proto.updateStyle = function() {

        function applyState() {

            var style = this.style;
            var shape = this.shape;
            var fontSize = this.style['font-size'];
            var fontFamily = this.style['font-family'];
            var fontWeight = this.style['font-weight'];
            var fontStyle =  this.style['font-style'];
            var strokeColor = this.highlighted ? this.highlightColor : namespaceUtils.composeRGBAString(style['stroke-color'], style['stroke-opacity']);
            var fillColor = namespaceUtils.composeRGBAString(style['fill-color'], style['fill-opacity']);

            this.rebuildTextSvg();

            namespaceUtils.setAttributeToMarkupSvg(shape, 'font-family', fontFamily);
            namespaceUtils.setAttributeToMarkupSvg(shape, 'font-size', fontSize);
            namespaceUtils.setAttributeToMarkupSvg(shape, 'fill', strokeColor);
            namespaceUtils.setAttributeToMarkupSvg(shape, 'font-weight', fontWeight);
            namespaceUtils.setAttributeToMarkupSvg(shape, 'font-style', fontStyle);

            var editor = this.editor;
            var transform = this.getTransform();
            var textTransform = this.getTextTransform();
            var textSize = this.textSize;

            namespaceUtils.setMarkupTextSvgTransform(shape, transform, textTransform);
            namespaceUtils.updateMarkupTextSvgBackground(shape, textSize.x, textSize.y, fillColor);
            namespaceUtils.updateMarkupTextSvgClipper(shape, textSize.x, textSize.y);
            namespaceUtils.updateMarkupTextSvgHitarea(shape, textSize.x, textSize.y, editor);

            this.applyingStyle = false;
        }

        this.applyingStyle = this.applyingStyle || false;
        if(!this.applyingStyle) {
            this.applyingStyle = true;
            requestAnimationFrame(applyState.bind(this));
        }
    };

    /**
     * Re-creates SVG tags that render SVG text.
     * Each line is placed around tspan tags which are vertically offset to each other.
     */
    proto.rebuildTextSvg = function() {

        // TODO: Remove the need to get text values from an object in edit mode, should be a function.
        var editMode = this.editor.editMode;
        if (editMode && editMode.type === this.type) {
            var style = namespaceUtils.cloneStyle(editMode.textInputHelper.style);
            var text = editMode.textInputHelper.textArea.value;
            this.currentTextLines = editMode.textInputHelper.getTextValuesForMarkup(this).lines;
            if (editMode.selectedMarkup !== this) {
                editMode.textInputHelper.textArea.value = text;
                editMode.textInputHelper.setStyle(style);
            }
        }

        var markup = namespaceUtils.createSvgElement('text');
        markup.setAttribute('id', 'markup');
        markup.setAttribute('alignment-baseline', 'middle');

        this.shape.childNodes[0].removeChild(this.shape.markup);
        this.shape.childNodes[0].appendChild(markup);
        this.shape.markup = markup;

        // For each line, create a tspan, add as child and offset it vertically.
        var dx = 0;
        var dy = 0;
        var yOffset = this.getLineHeight();

        this.currentTextLines.forEach(function(line){

            var tspan = namespaceUtils.createSvgElement('tspan');

            tspan.setAttribute('x', dx);
            tspan.setAttribute('y', dy);
            tspan.textContent = line;

            markup.appendChild(tspan);
            dy += yOffset;
        }.bind(this));

        var polygon = this.generateBoundingPolygon();
        var textSize = this.editor.sizeFromClientToMarkups(
            polygon.xVertices[1] - polygon.xVertices[0],
            polygon.yVertices[2] - polygon.yVertices[0]);

        this.textSize.x = Math.min(textSize.x, this.size.x);
        this.textSize.y = Math.min(textSize.y, this.size.y);
    };

    /**
     *
     * @returns {{vertexCount: number, xVertices: Float32Array, yVertices: Float32Array}}
     */
    proto.generateBoundingPolygon = function() {

        function getTextSize(lines, style, editor) {

            var size = {w:0, h:0};

            var lines = namespaceUtils.measureTextLines(lines, style, editor);
            var linesCount = lines.length;

            for(var i = 0; i < linesCount; ++i) {

                var line = lines[i];

                size.w = Math.max(size.w, line.width);
                size.h = size.h + line.height;
            }

            if (size.h !== 0) {
                size.h += editor.sizeFromMarkupsToClient(0, style['font-size'] * 0.25).y;
            }

            return size;
        }

        var position = this.getClientPosition();
        var size = this.getClientSize();
        var textSize = getTextSize(this.currentTextLines, this.style, this.editor);

        var w = Math.min(size.x, textSize.w);
        var h = Math.min(size.y, textSize.h);

        var lt = new THREE.Vector2(-size.x * 0.5,-size.y * 0.5).add(position);
        var rt = new THREE.Vector2( lt.x + w, lt.y);
        var rb = new THREE.Vector2( rt.x, rt.y + h);
        var lb = new THREE.Vector2( lt.x, rb.y);

        return { // packed for fast access in test algorithm.
            vertexCount: 4,
            xVertices : new Float32Array([lt.x, rt.x, rb.x, lb.x]),
            yVertices : new Float32Array([lt.y, rt.y, rb.y, lb.y])
        };
    };

    proto.setMetadata = function() {

        var metadata = namespaceUtils.cloneStyle(this.style);

        metadata.type = this.type;
        metadata.position = [this.position.x, this.position.y].join(" ");
        metadata.size = [this.size.x, this.size.y].join(" ");
        metadata.text = String(this.currentText);

        return namespaceUtils.addMarkupMetadata(this.shape, metadata);
    };

    /**
     * Helper method that returns the font size in client space coords.
     * @returns {Number}
     */
    proto.getClientFontSize = function() {

        return this.editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;
    };

    proto.getLineHeight = function() {

        return this.style['font-size'];
    };

    proto.renderToCanvas = function(ctx) {

        /**
         * Renders the lines of text to the canvas.
         * This method does not attempt to figure out how to wrap text. Instead, it expects
         * a set of lines that are already adjusted to fit in the given space.
         * All this does it renders them in the correct vertical position
         *
         * @param {CanvasRenderingContext2D} ctx - the canvas context to draw on
         * @param {String[]} lines - the lines of text to render already adjusted to wrap properly
         * @param {Number} lineHeight - the height of each line
         * @param {Number} maxHeight - maximum height the text will render to
         */
        function renderLinesOfText(ctx, lines, lineHeight, maxHeight){

            var y = 0;//only the vertical position changes
            lines.forEach(function(line){
                //check if we're over the max height allowed
                //if so, just end
                if ((y + lineHeight) > maxHeight) {
                    return;
                }
                ctx.fillText(line, 0, y);
                y += lineHeight;
            });
        }

        var fontFamily = this.style['font-family'];
        var fontStyle = this.style['font-style'];
        var fontWeight = this.style['font-weight'];
        var strokeColor = this.style['stroke-color'];
        var fontOpacity = this.style['stroke-opacity'];
        var fontSize = this.getClientFontSize();

        //var rotation = this.getRotation(); TODO: Revisit rotation when it becomes available
        var center = this.editor.positionFromMarkupsToClient(this.position.x, this.position.y);
        var clientSize = this.editor.sizeFromMarkupsToClient(this.size.x, this.size.y);
        var clientTextSize = this.editor.sizeFromMarkupsToClient(this.textSize.x, this.textSize.y);
        var clientLineHeight = this.editor.sizeFromMarkupsToClient(0, this.getLineHeight()).y;

        // Background rect
        ctx.save();
        {
            var fillColor = this.style['fill-color'];
            var fillOpacity = this.style['fill-opacity'];

            ctx.fillStyle = namespaceUtils.composeRGBAString(fillColor, fillOpacity);
            ctx.translate(center.x, center.y);
            fillOpacity !== 0 && ctx.fillRect(clientSize.x * -0.5, clientSize.y * -0.5, clientTextSize.x, clientTextSize.y);
        }
        ctx.restore();

        // Text
        ctx.fillStyle = strokeColor;
        ctx.strokeStyle = strokeColor;
        ctx.textBaseline = 'Alphabetic';
        ctx.translate(center.x - (clientSize.x * 0.5) , center.y - (clientSize.y * 0.5) + clientLineHeight);
        //ctx.rotate(rotation);
        ctx.font = fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily;
        ctx.globalAlpha = fontOpacity;
        renderLinesOfText(ctx, this.currentTextLines, clientLineHeight, clientSize.y);
    };

    proto.getTransform = function() {

        var x = this.position.x - this.size.x * 0.5;
        var y = this.position.y + this.size.y * 0.5;

        return [
            'translate(', x, ',', y, ')',
            'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ')',
            'scale(1,-1)'
        ].join(' ');
    };

    proto.getTextTransform = function() {

        var lineHeight = this.getLineHeight();

        var x = this.position.x - this.size.x * 0.5;
        var y = this.position.y + this.size.y * 0.5 - lineHeight;

        return [
            'translate(', x, ',', y, ')',
            'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ')',
            'scale(1,-1)'
        ].join(' ');
    };

    proto.cloneShape = function(clone) {
        
        clone.shape = namespaceUtils.createMarkupTextSvg();
        clone.bindDomEvents();
    };

    namespace.MarkupText = MarkupText;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    function MarkupTool() {

        Autodesk.Viewing.ToolInterface.call(this);
        this.names = ["markups.core"];
        this.panTool = null;
        this.allowNav = false;

        this.coreExt = null;
        this.hotkeysEnabled = true;

        var _ctrlDown = false;
        var _shiftDown = false;

        // Non-ToolInterface methods //

        this.allowNavigation = function(allow) {
            this.allowNav = allow;
        };
        this.setCoreExtension = function(coreExt) {
            this.coreExt = coreExt;
        };
        this.setHotkeysEnabled = function(enabled) {
            this.hotkeysEnabled = enabled;
        };


        // ToolInterface methods //

        this.activate = function(name, viewerApi) {
            this.panTool = viewerApi.toolController.getTool("pan");
            if (this.panTool) {
                this.panTool.activate("pan"); // TODO: What if we want "zoom" here?
            }
        };
        this.deactivate = function(name) {
            if (this.panTool) {
                this.panTool.deactivate("pan");
            }
            this.panTool = null;
        };

        this.handleKeyDown = function(event, keyCode) {

            if (!this.hotkeysEnabled) {
                return true; // Consume event
            }

            // Don't propagate key handling down to tool //

            switch (keyCode) {
                case Autodesk.Viewing.KeyCode.CONTROL: _ctrlDown = true; break;
                case Autodesk.Viewing.KeyCode.SHIFT: _shiftDown = true; break;

                case Autodesk.Viewing.KeyCode.x: _ctrlDown && !this.allowNav && this.coreExt.cut(); break;
                case Autodesk.Viewing.KeyCode.c: _ctrlDown && !this.allowNav && this.coreExt.copy(); break;
                case Autodesk.Viewing.KeyCode.v: _ctrlDown && !this.allowNav && this.coreExt.paste(); break;
                case Autodesk.Viewing.KeyCode.d:
                    if (_ctrlDown && !this.allowNav) {
                        // Duplicate
                        this.coreExt.copy();
                        this.coreExt.paste();
                    }
                    break;
                case Autodesk.Viewing.KeyCode.z:
                    if (_ctrlDown && !_shiftDown && !this.allowNav) {
                        this.coreExt.undo();
                    }
                    else if (_ctrlDown && _shiftDown && !this.allowNav) {
                        this.coreExt.redo(); // Also support Ctrl+Y
                    }
                    break;
                case Autodesk.Viewing.KeyCode.y: _ctrlDown && !this.allowNav && this.coreExt.redo(); break; // Also support ctrl+shift+z
                case Autodesk.Viewing.KeyCode.ESCAPE: this.coreExt.onUserCancel(); break;

                case Autodesk.Viewing.KeyCode.BACKSPACE: // Fall through
                case Autodesk.Viewing.KeyCode.DELETE:
                    var selectedMarkup = this.coreExt.getSelection();
                    if (selectedMarkup) {
                        this.coreExt.deleteMarkup(selectedMarkup);
                    }
                    break;
                case Autodesk.Viewing.KeyCode.F12:
                    return false; // To allow opening developer console.
                    break;
                default: break;
            }

            return true; // Consume event
        };
        this.handleKeyUp = function(event, keyCode) {

            if (!this.hotkeysEnabled) {
                return true; // Consume event
            }

            // Don't propagate key handling down to tool

            switch (keyCode) {
                case Autodesk.Viewing.KeyCode.CONTROL: _ctrlDown = false; break;
                case Autodesk.Viewing.KeyCode.SHIFT: _shiftDown = false; break;
                default: break;
            }

            return true; // Consume event ONLY
        };

        this.update = function() {
            if (this.allowNav && this.panTool && this.panTool.update) {
                return this.panTool.update();
            }
            return false;
        };

        this.handleSingleClick = function( event, button ) {
            if (this.allowNav) {
                // If pan tool won't handle single click, then pass over the event.
                if (this.panTool && this.panTool.handleSingleClick)
                    return this.panTool.handleSingleClick(event, button);
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleDoubleClick = function( event, button ) {
            if (this.allowNav) {
                // If pan tool won't handle double click, then pass over the event
                if (this.panTool && this.panTool.handleDoubleClick) {
                    return this.panTool.handleDoubleClick(event, button);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleSingleTap = function( event ) {
            if (this.allowNav) {
                // If pan tool won't handle single tap, then pass over the event
                if (this.panTool && this.panTool.handleSingleTap) {
                    return this.panTool.handleSingleTap(event);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleDoubleTap = function( event ) {
            if (this.allowNav) {
                // If pan tool won't handle double tap, then pass over the event
                if (this.panTool && this.panTool.handleDoubleTap) {
                    return this.panTool.handleDoubleTap(event);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleWheelInput = function(delta) {
            if (this.allowNav) {
                // If pan tool won't handle wheel input, then pass over the event
                if (this.panTool && this.panTool.handleWheelInput) {
                    return this.panTool.handleWheelInput(delta);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleButtonDown = function(event, button) {
            if (this.allowNav) {
                // If pan tool won't handle button down, then pass over the event
                if (this.panTool && this.panTool.handleButtonDown) {
                    return this.panTool.handleButtonDown(event, button);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleButtonUp = function(event, button) {
            if (this.allowNav) {
                // If pan tool won't handle button up, then pass over the event
                if (this.panTool && this.panTool.handleButtonUp) {
                    return this.panTool.handleButtonUp(event, button);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleMouseMove = function(event) {
            if (this.allowNav) {
                // If pan tool won't handle button move, then pass over the event
                if (this.panTool && this.panTool.handleMouseMove) {
                    return this.panTool.handleMouseMove(event);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleGesture = function(event) {
            if (this.allowNav) {
                // If pan tool won't handle gesture, then pass over the event
                if (this.panTool && this.panTool.handleGesture) {
                    return this.panTool.handleGesture(event);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
        this.handleBlur = function(event) {
            if (this.allowNav) {
                // If pan tool won't handle blur, then pass over the event
                if (this.panTool && this.panTool.handleBlur) {
                    return this.panTool.handleBlur(event);
                }
                else
                    return false;
            }
            return true; // Consume event
        };
    }

    namespace.MarkupTool = MarkupTool;
})();

(function(){ 'use strict';

    var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core');
    var namespaceUtils = AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core.Utils');
    var PERSPECTIVE_MODE_SCALE = 1000;

    /**
     * Extension used to overlay 2d markups over 2d and 3d models.
     *
     * @tutorial feature_markup
     * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance used to operate on.
     * @param {Object} options - Same Dictionary object passed into [Viewer3D]{@link Autodesk.Viewing.Viewer3D}'s constructor.
     * [show()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#show}.
     * @param {Boolean} [options.markupDisableHotkeys] - Disables hotkeys for copy, cut, paste, duplicate, undo, redo and deselect.
     * @param {Autodesk.Viewing.ToolInterface} [options.markupToolClass] - Class override for input handling.
     * Use it to override/extend default hotkeys and/or mouse/gesture input.
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     * @constructor
     * @category Extensions
     */
    function MarkupsCore(viewer, options) {

        Autodesk.Viewing.Extension.call(this, viewer, options);

        this.options = this.options || {};
        this.markups = [];
        this.styles = {};

        this.duringViewMode = false;
        this.duringEditMode = false;

        // Add action manager.
        this.actionManager = new namespace.EditActionManager( 50 ); // history of 50 actions.
        this.actionManager.addEventListener(namespace.EVENT_HISTORY_CHANGED, this.onEditActionHistoryChanged.bind(this));

        this.nextId = 0; // Used to identify markups by id during an edit session.

        // Clipboard.
        this.clipboard = new namespace.Clipboard(this);

        // Default Input handler.
        this.input = new namespace.InputHandler();

        // Extension will dispatch events.
        namespaceUtils.addTraitEventDispatcher(this);

        // Handled events.
        this.onCameraChangeBinded = this.onCameraChange.bind(this);
        this.onViewerResizeBinded = function(event) {
            // This is ugly, but we need to do this twice
            var self = this;
            // First usage is to avoid a blinking scenario
            self.onViewerResize(event);
            requestAnimationFrame(function(){
                // Second one is to actually make it work on some resize scenarios.
                // Check the unlikely scenario that we are no longer in view mode.
                if (self.duringViewMode) {
                    self.onViewerResize(event);
                }
            });
        }.bind(this);

        this.onMarkupSelectedBinded = this.onMarkupSelected.bind(this);
        this.onMarkupEnterEditionBinded = this.onMarkupEnterEdition.bind(this);
        this.onMarkupCancelEditionBinded = this.onMarkupCancelEdition.bind(this);
        this.onMarkupDeleteEditionBinded = this.onMarkupDeleteEdition.bind(this);
        this.onToolChangeBinded = this.onToolChange.bind(this);

        // Adds some css styles that create a bigger mouse area over certain elements, used mostly in mobile.
        var sheet = namespaceUtils.createStyleSheet();
        namespaceUtils.addRuleToStyleSheet(
            sheet,
            '.autodesk-markups-extension-core-make-me-bigger:after',
            'content:""; position:absolute; top:-10px; bottom:-10px; left:-10px; right:-10px;',
            0);
    }

    MarkupsCore.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
    MarkupsCore.prototype.constructor = MarkupsCore;
    namespace.MarkupsCore = MarkupsCore;

    /*
     * Event types
     */
    namespace.EVENT_ENTER_EDIT_MODE = "EVENT_MARKUP_CORE_ENTER_EDIT_MODE";
    namespace.EVENT_LEAVE_EDIT_MODE = "EVENT_MARKUP_CORE_LEAVE_EDIT_MODE";
    namespace.EVENT_SELECTION_CHANGED = "EVENT_MARKUP_SELECTION_CHANGED";

    var proto = MarkupsCore.prototype;

    proto.load = function () {

        // Add layer where annotations will actually live
        var svg = this.svg = namespaceUtils.createSvgElement('svg');
        namespaceUtils.setSvgParentAttributes(svg);

        // NOTE: Required since LMV renders Y coordinates upwards,
        // while browser's Y coordinates goes downwards.
        var svgStyle = new namespaceUtils.DomElementStyle();
        svgStyle.setAttribute('position', 'absolute');
        svgStyle.setAttribute('left', '0');
        svgStyle.setAttribute('top', '0');
        svgStyle.setAttribute('transform', 'scale(1,-1)', { allBrowsers: true});
        svgStyle.setAttribute('transformOrigin', '0, 0', { allBrowsers: true});
        svg.setAttribute('style', svgStyle.getStyleString());

        this.bounds = {x:0, y:0, width:0, height:0};

        this.input.attachTo(this);

        //Instantiate edit frame.
        this.editFrame = new namespace.EditFrame(this.viewer.container, this);
        this.editFrame.addEventListener(namespace.EVENT_EDITFRAME_EDITION_START, function(){this.disableMarkupInteractions(true);}.bind(this));
        this.editFrame.addEventListener(namespace.EVENT_EDITFRAME_EDITION_END, function(){this.disableMarkupInteractions(false);}.bind(this));

        // Register tool
        var toolClass = this.options.markupToolClass || namespace.MarkupTool;
        this.markupTool = new toolClass();
        this.markupTool.setCoreExtension(this);
        this.markupTool.setHotkeysEnabled(!this.options.markupDisableHotkeys);
        this.viewer.toolController.registerTool(this.markupTool);

        this.snapper = new Autodesk.Viewing.Extensions.Measure.Snapper(this.viewer, true);
        this.viewer.toolController.registerTool(this.snapper);

        return true;
    };

    proto.unload = function() {

        this.hide();

        this.input.detachFrom(this);

        if (this.markupTool) {
            this.viewer.toolController.deregisterTool(this.markupTool);
            this.markupTool = null;
        }

        if (this.snapper) {
            this.viewer.toolController.deregisterTool(this.snapper);
            this.snapper = null;
        }

        var svg = this.svg;
        if (svg && this.onMouseDownBinded) {
            svg.removeEventListener("mousedown", this.onMouseDownBinded);
            this.onMouseDownBinded = null;
        }
        if (svg.parentNode) {
            svg.parentNode.removeChild(svg);
        }
        this.editModeSvgLayerNode = null;
        this.svg = null;

        return true;
    };

    proto.toggleEditMode = function() {

        if (this.duringEditMode) {
            this.leaveEditMode();
        } else {
            this.enterEditMode();
        }
    };

    /**
     * Enables click/touch interactions over Viewer canvas to create/draw markups.<br>
     * Exit editMode by calling [leaveEditMode()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#leaveEditMode}.<br>
     * See also:
     * [show()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#show}
     * @returns {boolean} Returns true if editMode is active
     */
    proto.enterEditMode = function() {

        // Return if already in edit mode.
        if (this.duringEditMode) {
            return true;
        }

        // If not currently shown, then show
        if (!this.duringViewMode) {
            if (!this.show()){
                return false; // Failed to enter view mode.
            }
        }

        if(!this.editModeSvgLayerNode) {
            this.editModeSvgLayerNode = namespaceUtils.createSvgElement('g');
            this.editModeSvgLayerNode.setAttribute('cursor', 'default');
        }
        this.svg.insertBefore(this.editModeSvgLayerNode, this.svg.firstChild);
        this.svg.setAttribute('cursor', 'crosshair');

        this.input.enterEditMode();
        this.activateTool(true);
        this.allowNavigation(false);
        this.styles = {}; // Clear EditMode styles.
        this.defaultStyle = null;
        this.duringEditMode = true;
        this.changeEditMode(new namespace.EditModeArrow(this));
        this.actionManager.clear();
        this.fireEvent({ type:namespace.EVENT_EDITMODE_ENTER });
        return true;
    };

    /**
     * Exits from editMode.<br>
     * See also [enterEditMode()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}
     * @returns {boolean} returns true if edit mode has been deactivated
     */
    proto.leaveEditMode = function() {

        var NOT_IN_EDIT_MODE = true;
        var WE_ARE_STILL_IN_EDIT_MODE = false;

        if (!this.duringEditMode || !this.duringViewMode) {
            return NOT_IN_EDIT_MODE;
        }

        var viewer = this.viewer;
        if (!viewer) {
            return WE_ARE_STILL_IN_EDIT_MODE; // something is very wrong...
        }

        this.editMode.destroy();
        this.editMode = null;
        this.duringEditMode = false;

        this.svg.removeChild(this.editModeSvgLayerNode);
        this.svg.setAttribute('cursor', 'default');

        this.input.leaveEditMode();
        this.editFrame.setMarkup(null);
        this.activateTool(true);

        this.allowNavigation(true);
        this.fireEvent({ type:namespace.EVENT_EDITMODE_LEAVE });
        return NOT_IN_EDIT_MODE;
    };

    proto.toggle = function() {

        if (this.duringViewMode) {
            this.hide();
        } else {
            this.show();
        }
    };

    /**
     * Enables loading of previously saved markups.<br>
     * Exit editMode by calling [hide()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hide}.<br>
     * See also:
     * [enterEditMode()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}
     * @returns {boolean} Whether it successfully entered view mode or not.
     */
    proto.show = function() {

        var viewer = this.viewer;
        if (!viewer || !viewer.model) {
            return false;
        }

        // Return if already showing or in edit-mode.
        // Notice that edit mode requires that we are currently show()-ing.
        if (this.duringViewMode || this.duringEditMode) {
            return true;
        }

        viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
        viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResizeBinded);

        // Add parent svg of all markups.
        viewer.container.appendChild(this.svg);

        this.input.enterViewMode();
        namespaceUtils.hideLmvUi(viewer);

        // TODO: Nasty hack, currently there is no API to disable mouse highlighting in 3d models.
        // TODO: We nuke rollover function in viewer, for now, public api will be added soon.
        this.onViewerRolloverObject = viewer.impl.rolloverObject;
        viewer.impl.rolloverObject = function(){};

        this.activateTool(true);
        var camera = viewer.impl.camera;
        this.onViewerResize({ width: camera.clientWidth, height: camera.clientHeight });
        this.clear();

        // See function loadMarkups() for when the actual SVG gets added onstage //
        this.svgLayersMap = {};
        this.duringViewMode = true;
        this.allowNavigation(true);
        return true;
    };

    /**
     * Removes any markup currently overlaid on the viewer. It will also exit EditMode if it is active.<br>
     * See also:
     * [show()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#show}
     * @returns {boolean} Whether it successfully left view mode or not.
     */
    proto.hide = function() {

        var RESULT_HIDE_OK = true;
        var RESULT_HIDE_FAIL = false;

        var viewer = this.viewer;
        if (!viewer || !this.duringViewMode) {
            return RESULT_HIDE_OK;
        }

        if (this.duringEditMode) {
            if (!this.leaveEditMode()) {
                return RESULT_HIDE_FAIL;
            }
        }

        viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
        viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResizeBinded);

        var svg = this.svg;
        svg.parentNode && svg.parentNode.removeChild(svg);

        // Remove all Markups and metadata (if any)
        this.unloadMarkupsAllLayers();
        namespaceUtils.removeAllMetadata(svg);

        this.input.leaveViewMode();
        namespaceUtils.restoreLmvUi(viewer);
        this.viewer.impl.rolloverObject = this.onViewerRolloverObject;

        this.activateTool(false);
        this.duringViewMode = false;
        return RESULT_HIDE_OK;
    };

    /**
     * Removes all markups from screen.<br>
     * Markups should have been added while in
     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.
     */
    proto.clear = function() {

        var markups = this.markups;
        while(markups.length > 0) {

            var markup = markups[0];
            this.removeMarkup(markup);
            markup.destroy();
        }

        // At this point no other markups should be available.
        var svg = this.editModeSvgLayerNode;
        if (svg && svg.childNodes.length > 0) {
            while (svg.childNodes.length) {
                svg.removeChild(svg.childNodes[0]);
            }
        }
    };

    /**
     * Returns an SVG string with the markups created so far.<br>
     * Markups should have been added while in
     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.
     * @returns {string}
     */
    proto.generateData = function() {

        if (this.editMode) {
            this.editMode.onSave();
        }

        // Sanity check, remove any lingering metadata nodes
        namespaceUtils.removeAllMetadata(this.svg);

        var tmpNode = namespaceUtils.createSvgElement("svg");
        namespaceUtils.transferChildNodes(this.svg, tmpNode); // Transfer includes this.editModeSvgLayerNode
        namespaceUtils.transferChildNodes(this.editModeSvgLayerNode, this.svg);

        // version 1: first implementation.
        // version 2: added global offset to markup positions.
        // version 3: change node structure to include hitareas, hit areas are not exported.
        // version 4: scale perspective markups space by PERSPECTIVE_MODE_SCALE because bug in firefox. LMV-1150
        var metadataObject = {
            "data-model-version": "4"
        };
        var metadataNode = namespaceUtils.addSvgMetadata(this.svg, metadataObject);
        var metadataNodes = [ metadataNode ];

        // Notify each markup to inject metadata
        this.markups.forEach(function(markup){
            var addedNode = markup.setMetadata();
            if (addedNode) {
                metadataNodes.push(addedNode);
            }
        });

        // Generate the data!
        var data = namespaceUtils.svgNodeToString(this.svg);

        // Remove metadataObject before returning
        metadataNodes.forEach(function(metadataNode){
            metadataNode.parentNode.removeChild(metadataNode);
        });

        namespaceUtils.transferChildNodes(this.svg, this.editModeSvgLayerNode);
        namespaceUtils.transferChildNodes(tmpNode, this.svg);
        tmpNode = null; // get rid of it.

        return  data;
    };

    /**
     *
     */
    proto.generatePoints3d = function() {

        var result = {markups: [], main: null};
        var markups = this.markups;
        var markupsCount = markups.length;

        if (markupsCount === 0) {
            return result;
        }

        // Gather a 3d point for markup.
        var idTarget = this.viewer.impl.renderer().readbackTargetId();
        for(var i = 0; i < markupsCount; ++i) {

            var markup = markups[i];
            var point = markup.generatePoint3d(idTarget) || null;
            result.markups.push(
                {
                    id: markup.id,
                    type: markup.type,
                    point: point || null
                });
        }


        // If there is 3d point associated with an arrow, we use that as main point.
        if (markupsCount === 1) {

            var main = result.markups[0].point;
            result.main = main && main.clone();
            return result;
        }

        for(var i = 0; i < markupsCount; ++i) {

            var collision = result.markups[i];
            if (collision.type === namespace.MARKUP_TYPE_ARROW && collision.point !== null) {

                result.main = collision.point.clone();
                return result;
            }
        }

        // If there is no arrows, we average bounding boxes and get a 3d point inside it.
        var bbX0 = Number.POSITIVE_INFINITY;
        var bbY0 = Number.POSITIVE_INFINITY;
        var bbX1 = Number.NEGATIVE_INFINITY;
        var bbY1 = Number.NEGATIVE_INFINITY;

        for(var i = 0; i < markupsCount; ++i) {

            var boundingBox = markups[i].generateBoundingBox();

            bbX0 = Math.min(bbX0, boundingBox.min.x);
            bbY0 = Math.min(bbY0, boundingBox.min.y);
            bbX1 = Math.max(bbX1, boundingBox.max.x);
            bbY1 = Math.max(bbY1, boundingBox.max.y);
        }

        var polygon = {};

        polygon.vertexCount = 4;
        polygon.xVertices = new Float32Array([bbX0, bbX1, bbX1, bbX0]);
        polygon.yVertices = new Float32Array([bbY0, bbY0, bbY1, bbY1]);

        var point2d = namespaceUtils.checkPolygon(polygon, idTarget);
        var point3d = point2d && this.viewer.clientToWorld(point2d.x, point2d.y);
        result.main = point3d && point3d.point;

        return result;
    };

    /**
     * Renders markups currently present on the canvas to be rendered into a &lt;canvas&gt; 2d context.<br>
     * Internally, it will use each EditMode's renderToCanvas() api.<br>
     * The intended use-case is to generate an image.
     * @param {CanvasRenderingContext2D} context
     */
    proto.renderToCanvas = function(context) {

        this.markups.forEach(function(markup){
            context.save();
            markup.renderToCanvas(context);
            context.restore();
        });
    };

    /**
     * Changes the active drawing tool.<br>
     * Use this method to change from, for example: the Arrow drawing tool into the Rectangle drawing tool.<br>
     * Applicable only while in [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.<br>
     * Fires EVENT_EDITMODE_CHANGED
     * @param editMode
     */
    proto.changeEditMode = function(editMode) {

        var oldEditMode = this.editMode;
        oldEditMode && oldEditMode.destroy();

        editMode.addEventListener(namespace.EVENT_EDITMODE_CREATION_BEGIN, function() {this.disableMarkupInteractions(true);}.bind(this));
        editMode.addEventListener(namespace.EVENT_EDITMODE_CREATION_END, function(){this.disableMarkupInteractions(false);}.bind(this));
        editMode.addEventListener(namespace.EVENT_MARKUP_DESELECT, function(event){this.fireEvent(event);}.bind(this));

        this.editMode = editMode;
        this.styles[editMode.type] = namespaceUtils.cloneStyle(editMode.getStyle());

        this.fireEvent({type:namespace.EVENT_EDITMODE_CHANGED, target: editMode});
    };

    /**
     * While extension is active, the user is allowed to draw markups. Thee is also support
     * for panning and zooming but only for orthographic cameras.<br>
     * This method can be used to check whether a user can perform camera navigation operation
     * on the current loaded model.
     *
     * @return {Boolean} Whether [allowNavigation()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#allowNavigation} can succeed.
     */
    proto.isNavigationAllowed = function() {

        return !this.viewer.impl.camera.isPerspective;
    };

    /**
     * While in [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode},
     * it switches the click/tap/swipe behavior to allow camera zoom and panning operations.
     *
     * @param {Boolean} allow - Whether camera navigation interactions are active or not.
     */
    proto.allowNavigation = function(allow) {

        // Navigation is not allowed while in perspective mode.
        if (allow && (this.duringEditMode || this.duringViewMode) && !this.isNavigationAllowed()) {
            return false;
        }

        var editMode = this.editMode;
        this.navigating = allow;

        if (allow){
            this.svg.setAttribute("pointer-events", "none");
            editMode && this.selectMarkup(null);
        } else {
            this.svg.setAttribute("pointer-events", "painted");
        }

        // Update pointer events for all markups.
        var markups = this.markups;
        var markupsCount = markups.length;

        for(var i = 0; i < markupsCount; ++i) {
           markups[i].updateStyle();
        }

        this.markupTool.allowNavigation(allow);
        editMode && editMode.notifyAllowNavigation(allow);
    };

    /**
     * Sets mouse/tap interactions with all Markups present while in
     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.
     * @param {Boolean} disable - Whether markups will interact with mouse/tap actions.
     */
    proto.disableMarkupInteractions = function(disable) {

        this.markups.forEach(function(markup) {markup.disableInteractions(disable);});
    };

    /**
     *
     * @param isActive
     * @private
     */
    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.activateTool = function(isActive) {
        if (isActive) {
            if (!this.cachedNavigationTool) {
                this.cachedNavigationTool = this.viewer.getActiveNavigationTool();
                this.viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChangeBinded);
            }
            this.viewer.setActiveNavigationTool(this.markupTool.getName());
        } else {

            if (this.cachedNavigationTool) {
                this.viewer.setActiveNavigationTool(this.cachedNavigationTool);
                this.cachedNavigationTool = null;
            } else {
                var defaultToolName = this.viewer.getDefaultNavigationToolName();
                this.viewer.setActiveNavigationTool(defaultToolName);
            }

            this.viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChangeBinded);
        }
    };

    /**
     *
     * @param event
     * @private
     */
    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.onToolChange = function(event) {

        if (event.toolName !== this.markupTool.getName())
            return;

        if (event.active) {
            var navAllowed = this.isNavigationAllowed();
            this.viewer.setNavigationLockSettings({
                pan      : navAllowed,
                zoom     : navAllowed,
                orbit    : false,
                roll     : false,
                fov      : false,
                walk     : false,
                gotoview : false
            });
        }
        this.viewer.setNavigationLock(event.active);
    };

    //// Input /////////////////////////////////////////////////////////////////////////////////////////////////////////

    proto.changeInputHandler = function(inputHandler) {

        this.input.detachFrom(this);
        inputHandler.attachTo(this);
        this.input = inputHandler;

        if (this.duringEditMode) {
            inputHandler.enterEditMode();
        }

        if (this.duringViewMode) {
            inputHandler.enterViewMode();
        }
    };

    //// Copy and Paste System /////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Standard copy operation. Applies to any selected Markup. It has effect only when a markup is selected.<br>
     * See also
     * [cut()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#cut} and
     * [paste()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#paste}.
     */
    proto.copy = function() {

        this.clipboard.copy();
    };

    /**
     * Standard cut operation. Applies to any selected Markup, which gets removed from screen at call time.<br>
     * See also
     * [copy()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#copy} and
     * [paste()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#paste}.
     */
    proto.cut = function() {

        this.clipboard.cut();
    };

    /**
     * Standard paste operation. Will paste add to stage any previously copied or cut markup.
     * Can be called repeatedly after after a single copy or cut operation.<br>
     * See also
     * [copy()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#copy} and
     * [cut()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#cut}.
     */
    proto.paste = function() {

        this.clipboard.paste();
    };

    //// Undo and Redo System //////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Will undo the previous operation.<br>
     * The Undo/Redo stacks will track any change done through an EditAction.<br>
     * See also
     * [redo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#redo},
     * [isUndoStackEmpty()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#isUndoStackEmpty}.
     */
    proto.undo = function() {

        this.actionManager.undo();
    };

    /**
     * Will redo and previously undo operation.<br>
     * See also
     * [undo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#undo},
     * [isRedoStackEmpty()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#isRedoStackEmpty}.
     */
    proto.redo = function() {

        this.actionManager.redo();
    };

    /**
     * Returns true when [undo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#undo}
     * will produce no changes.
     * @return {Boolean}
     */
    proto.isUndoStackEmpty = function() {

        return this.actionManager.isUndoStackEmpty();
    };

    /**
     * Returns true when [redo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#redo}
     * will produce no changes.
     * @return {Boolean}
     */
    proto.isRedoStackEmpty = function() {

        return this.actionManager.isRedoStackEmpty();
    };

    proto.beginActionGroup = function() {

        this.actionManager.beginActionGroup();
    };

    proto.closeActionGroup = function() {

        this.actionManager.closeActionGroup();
    };

    proto.cancelActionGroup = function() {

        this.actionManager.cancelActionGroup();
    };

    /**
     * Helper function for generating unique markup ids.
     * @returns {number}
     */
    proto.getId = function() {

        return ++this.nextId;
    };

    /**
     * @param event
     * @private
     */
    proto.onEditActionHistoryChanged = function(event) {

        var data = event.data;
        var editMode = this.editMode;

        var keepSelection = editMode && editMode.selectedMarkup && editMode.selectedMarkup.id === data.targetId;

        if((data.action !== 'undo' && data.targetId !== -1) ||
            data.action === 'undo' && keepSelection) {

            // Markup can be null when deleting, that's ok, we unselect in that case.
            var markup = this.getMarkup(data.targetId);
            this.selectMarkup(markup);
        }

        this.fireEvent(event);
    };

    /**
     * Returns a markup with the specified id. Returns null when not found.<br>
     * See also:
     * [getSelection()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getSelection}.
     * @param {String} id Markup identifier.
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup}
     */
    proto.getMarkup = function(id) {

        var markups = this.markups;
        var markupsCount = markups.length;

        for(var i = 0; i < markupsCount; ++i) {
            if (markups[i].id == id) {
                return markups[i];
            }
        }

        return null;
    };


    /**
     * Selects a markup.  A selected markup gets an overlayed UI that allows transformations such
     * as resizing, rotations and translation.<br>
     * Allows sending null to remove selection from the currently selected markup.
     * See also:
     * [getMarkup()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getMarkup}.
     * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup|null} markup Markup instance to select, or null.
     */
    proto.selectMarkup = function(markup) {

        if (markup) {

            if (this.editMode.type === markup.type) {
                this.editMode.setSelection(markup);
            } else {

                var editMode = markup.getEditMode();
                editMode.setSelection(null);

                this.changeEditMode(editMode);
                this.setStyle(markup.getStyle());
                this.editMode.setSelection(markup);
            }
        } else {

            this.editMode.setSelection(null);
        }
    };

    /**
     * Returns the currently selected Markup.  A selected markup has custom UI overlayed that allows for
     * resizing, rotation and translation.<br>
     * See also:
     * [selectMarkup()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#selectMarkup}.
     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup|null}
     */
    proto.getSelection = function() {

        return this.editMode.getSelection();
    };

    /**
     * Deletes a markup from the scene. Applies only while in
     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.
     * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup} markup
     * @param {Boolean} [dontAddToHistory] Whether delete action can be [undone]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#undo}.
     */
    proto.deleteMarkup = function(markup, dontAddToHistory) {

        var editMode = markup.getEditMode();
        editMode.deleteMarkup(markup, dontAddToHistory);
    };

    proto.addMarkup = function(markup) {

        markup.setParent(this.editModeSvgLayerNode);

        markup.addEventListener(namespace.EVENT_MARKUP_SELECTED, this.onMarkupSelectedBinded);
        markup.addEventListener(namespace.EVENT_MARKUP_ENTER_EDITION, this.onMarkupEnterEditionBinded);
        markup.addEventListener(namespace.EVENT_MARKUP_CANCEL_EDITION, this.onMarkupCancelEditionBinded);
        markup.addEventListener(namespace.EVENT_MARKUP_DELETE_EDITION, this.onMarkupDeleteEditionBinded);

        this.markups.push(markup);
    };

    /**
     *
     * @param markup
     * @private
     */
    proto.removeMarkup = function(markup) {

        markup.setParent(null);

        markup.removeEventListener(namespace.EVENT_MARKUP_SELECTED, this.onMarkupSelectedBinded);
        markup.removeEventListener(namespace.EVENT_MARKUP_ENTER_EDITION, this.onMarkupEnterEditionBinded);
        markup.removeEventListener(namespace.EVENT_MARKUP_CANCEL_EDITION, this.onMarkupCancelEditionBinded);
        markup.removeEventListener(namespace.EVENT_MARKUP_DELETE_EDITION, this.onMarkupDeleteEditionBinded);

        var markups = this.markups;
        var markupsIndex = markups.indexOf(markup);
        if (markupsIndex !== -1) {
            markups.splice(markupsIndex, 1);
        }

        var editMode = this.editMode;
        if (editMode) {
            var selectedMarkup = editMode.getSelection();
            if (selectedMarkup === markup) {
                this.selectMarkup(null);
            }
        }
    };

    //// Markups style /////////////////////////////////////////////////////////////////////////////////////////////////

    proto.setStyle = function(style) {

        var styles = this.styles;
        var editMode = this.editMode;

        namespaceUtils.copyStyle(style, styles[editMode.type]);
        editMode.setStyle(styles[editMode.type]);
    };

    proto.getStyle = function() {

        return namespaceUtils.cloneStyle(this.styles[this.editMode.type]);
    };

    proto.getDefaultStyle = function() {

        var defaultStyleAttributes = [
            'stroke-width',
            'font-size',
            'font-family',
            'font-style',
            'font-weight',
            'stroke-color',
            'stroke-opacity',
            'fill-color',
            'fill-opacity'];
        this.defaultStyle = this.defaultStyle || namespaceUtils.createStyle(defaultStyleAttributes, this);

        return this.defaultStyle;
    };

    //// Markups depth order ///////////////////////////////////////////////////////////////////////////////////////////

    /**
     *
     * @param markup
     */
    proto.bringToFront = function(markup) {

        this.sendMarkupTo(markup, this.markups.length-1);
    };

    /**
     *
     * @param markup
     */
    proto.sendToBack = function(markup) {

        this.sendMarkupTo(markup, 0);
    };

    /**
     *
     * @param markup
     */
    proto.bringForward = function(markup) {

        var markupIndex = this.markups.indexOf(markup);
        this.sendMarkupTo(markup, markupIndex+1);
    };

    /**
     *
     * @param markup
     */
    proto.bringBackward = function(markup) {

        var markupIndex = this.markups.indexOf(markup);
        this.sendMarkupTo(markup, markupIndex-1);
    };

    /**
     *
     * @param markup
     * @param index
     * @private
     */
    proto.sendMarkupTo = function(markup, index) {

        var markups = this.markups;
        var markupIndex = markups.indexOf(markup);

        if (markupIndex === -1 || index < 0 || index >= markups.length) {
            return;
        }

        markups.splice(markupIndex, 1);
        index = markupIndex > index ? index -1 : index;
        markups.splice(index, 0, markup);

        // TODO: Add markup in right position not always at the end.
        markup.setParent(null);
        markup.setParent(this.editModeSvgLayerNode);
    };

    //// Serialization and Restoration of Markups  /////////////////////////////////////////////////////////////////////

    /**
     * Overlays Markup data (SVG string) onto viewer's canvas. A layerId is required to group markups and reference
     * them in operations such as
     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.<br>
     *
     * See also:
     * [unloadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkups},
     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.
     *
     * @param {String} markupString - svg string with markups. See also [generateData()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#generateData}.
     * @param {String} layerId - Identifier for the layer where the markup should be loaded to. Example "Layer1".
     * @return {Boolean} Whether the markup string was able to be loaded successfully
     */
    proto.loadMarkups = function (markupString, layerId) {

        var self = this;
        var viewer = self.viewer;
        var camera = viewer.impl.camera;

        var pre2ClientToMarkups = function(x, y) {
            var point = namespaceUtils.clientToWorld(x, y, 0, viewer);
            point.add(camera.position).applyMatrix4(camera.matrixWorldInverse);
            point.z = 0;
            return point;
        };

        var pre4ClientToMarkups = function(x, y) {

            var camera = self.viewer.impl.camera;
            var point = namespaceUtils.clientToWorld(x, y, 0, self.viewer);

            // In LMV model is offset by a global offset, we correct this offset when transforming to markups space, so
            // exported markups don't have the offset.
            var globalOffset = self.viewer.model.getData().globalOffset;
            if (globalOffset) {
                point.sub(globalOffset);
            }

            point.add(camera.position);
            point.applyMatrix4(camera.matrixWorldInverse);
            point.z = 0;

            return point;
        };

        var nextId = namespaceUtils.getClipPathId();
        var fixClipPathIds = function(svg) {

            if (svg.tagName == 'markup_element' && svg.getAttribute('type') === 'label') {

                var clipper = svg.parentNode.parentNode.childNodes[1].childNodes[0];
                var clipperId = 'markup-clipper-' + nextId++;
                var clipperUrl = 'url(#' + clipperId + ')';

                clipper.setAttribute('id', clipperId);
                clipper.parentNode.setAttribute('clip-path', clipperUrl);
            } else {

                var children = svg.childNodes;
                var childrenCount = children.length;

                for (var i = 0; i < childrenCount; ++i) {
                    fixClipPathIds(children[i]);
                }
            }
        };

        if(!this.duringViewMode) {
            return false;
        }

        if (!layerId) {
            console.warn("loadMarkups failed; missing 2nd argument 'layerId'");
            return false;
        }

        // Can it be parsed into SVG?
        var parent = namespaceUtils.stringToSvgNode(markupString);
        if(!parent) {
            return false;
        }

        var metadata = parent.childNodes[0].childNodes[0];
        var version = parseFloat(metadata.getAttribute('data-model-version'));

        // Apply global offset if needed.
        var offset = {x:0, y:0};
        var globalOffset = this.viewer.model.getData().globalOffset;

        if (version < 2 && globalOffset) {
            var pre2Offset = pre4ClientToMarkups(0,0).sub(pre2ClientToMarkups(0,0));
            offset.x += pre2Offset.x;
            offset.y += pre2Offset.y;
        }

        if (version < 4 && globalOffset && !camera.isPerspective) {
            var pre4Offset = this.clientToMarkups(0,0).sub(pre4ClientToMarkups(0,0));
            offset.x += pre4Offset.x;
            offset.y += pre4Offset.y;
        }

        // Scale perspective markups space if needed.
        var scale = null;

        if (version < 4 && camera.isPerspective) {
            scale = PERSPECTIVE_MODE_SCALE;
        }

        // Fix clip path ids, clip paths ids were introduced in version 3.
        if (version >= 3) {
            fixClipPathIds(parent);
        }

        // Remove all metadata nodes
        namespaceUtils.removeAllMetadata(parent);

        // Create svg node for layer (if not present)
        var svgLayerNode = this.svgLayersMap[layerId];
        if(!svgLayerNode) {
            svgLayerNode = namespaceUtils.createSvgElement('g');
            this.svg.appendChild(svgLayerNode);
            this.svgLayersMap[layerId] = svgLayerNode;
        }

        var children = parent.childNodes;
        while(children.length) {
            var child = children[0];
            var childTransform = child.getAttribute('transform') || '';

            if (offset.x !== 0 || offset.y !== 0) {
                childTransform = 'translate(' + offset.x + ', ' + offset.y + ') ' + childTransform;
            }

            if (scale) {
                childTransform = 'scale(' + scale + ', ' + scale + ') ' + childTransform;
            }

            if (offset || scale) {
                child.setAttribute('transform', childTransform);
            }
            svgLayerNode.appendChild(child);
            child.setAttribute("pointer-events", "none");
        }
        return true;
    };

    /**
     * Removes Markups from DOM, which is good to free up some memory.<br>
     *
     * See also:
     * [loadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#loadMarkups},
     * [unloadMarkupsAllLayers()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkupsAllLayers}.
     *
     * @param {String} layerId - Id of the layer containing all markups to unload (from DOM).
     * @return {Boolean} Whether the operation succeeded or not.
     */
    proto.unloadMarkups = function(layerId) {

        if (!layerId) {
            console.warn("unloadMarkups failed; No layerId provided.");
            return false;
        }

        var svgLayerNode = this.svgLayersMap[layerId];
        if (!svgLayerNode) {
            // TODO: Do we need to log anything here?
            return false;
        }

        this.svg.removeChild(svgLayerNode);
        delete this.svgLayersMap[layerId];
        return true;
    };

    /**
     * Unload all markups loaded so far. Great for freeing up memory.
     *
     * See also:
     * [loadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#loadMarkups},
     * [unloadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkups}.
     */
    proto.unloadMarkupsAllLayers = function() {

        for (var layerId in this.svgLayersMap) {
            if (this.svgLayersMap.hasOwnProperty(layerId)) {
                this.svg.removeChild(this.svgLayersMap[layerId]);
            }
        }
        this.svgLayersMap = {};
    };

    /**
     * Hides all markups from a specified layer. Note that markups will be hidden and not unloaded,
     * thus memory will still be consumed to keep them around. However, no additional parsing is required
     * to make them visible again through method
     * [showMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#showMarkups}.
     *
     * See also:
     * [showMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#showMarkups},
     * [unloadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkups},
     * [loadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#loadMarkups}.
     *
     * @param {String} layerId - Id of the layer containing all markups to unload (from DOM).
     * @return {Boolean} Whether the operation succeeded or not.
     */
    proto.hideMarkups = function(layerId) {

        if (!layerId) {
            console.warn("hideMarkups failed; No layerId provided.");
            return false;
        }

        var svgLayerNode = this.svgLayersMap[layerId];
        if (!svgLayerNode) {
            // TODO: Do we need to log anything here?
            return false;
        }

        svgLayerNode.setAttribute("visibility", "hidden");
    };

    /**
     * Sets a layer containing markups visible again.  Markups can be set non-visible by calling
     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.
     *
     * See also:
     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.
     *
     * @param {String} layerId - Id of the layer containing all markups to unload (from DOM).
     * @return {Boolean} Whether the operation succeeded or not.
     */
    proto.showMarkups = function(layerId) {

        if (!layerId) {
            console.warn("showMarkups failed; No layerId provided.");
            return false;
        }

        var svgLayerNode = this.svgLayersMap[layerId];
        if (!svgLayerNode) {
            // TODO: Do we need to log anything here?
            return false;
        }

        svgLayerNode.setAttribute("visibility", "visible");
    };

    //// Client Space <-> Markup Space /////////////////////////////////////////////////////////////////////////////////

    proto.positionFromClientToMarkups = function(x, y) {

        return this.clientToMarkups(x, y);
    };

    proto.positionFromMarkupsToClient = function(x, y) {

        return this.markupsToClient(x, y);
    };

    proto.vectorFromClientToMarkups = function(x, y) {

        var a = this.clientToMarkups(0, 0);
        var b = this.clientToMarkups(x, y);

        return {x: b.x - a.x, y: b.y - a.y};
    };

    proto.vectorFromMarkupsToClient = function(x, y) {

        var a = this.markupsToClient(0, 0);
        var b = this.markupsToClient(x, y);

        return {x: b.x - a.x, y: b.y - a.y};
    };

    proto.sizeFromClientToMarkups = function(w, h) {

        var a = this.clientToMarkups(0, 0);
        var b = this.clientToMarkups(w, h);

        return {x: Math.abs(b.x - a.x), y: Math.abs(b.y - a.y)};
    };

    proto.sizeFromMarkupsToClient = function(w, h) {

        var a = this.markupsToClient(0, 0);
        var b = this.markupsToClient(w, h);

        return {x: Math.abs(b.x - a.x), y: Math.abs(b.y - a.y)};
    };

    proto.markupsToClient = function(x, y) {

        var camera = this.viewer.impl.camera;
        var point = new THREE.Vector3(x, y, 0);

        if (camera.isPerspective) {

            var bb = this.viewer.impl.canvas.getBoundingClientRect();

            point.x =( point.x / PERSPECTIVE_MODE_SCALE * (bb.height * 0.5) + bb.width  * 0.5);
            point.y =(-point.y / PERSPECTIVE_MODE_SCALE * (bb.height * 0.5) + bb.height * 0.5);
        } else {

            point.applyMatrix4(camera.matrixWorld);
            point.sub(camera.position);

            // In LMV model is offset by a global offset, we correct this offset when transforming to markups space, so
            // exported markups don't have the offset.
            var globalOffset = this.viewer.model.getData().globalOffset;
            if (globalOffset) {
                point.sub(globalOffset);
            }

            point = namespaceUtils.worldToClient(point, this.viewer, false);
            point.z = 0;
        }

        return point;
    };

    proto.clientToMarkups = function(x, y) {

        var camera = this.viewer.impl.camera;
        var point = new THREE.Vector3(x, y, 0);

        if (camera.isPerspective) {

            var bb = this.viewer.impl.canvas.getBoundingClientRect();

            // Multiply by PERSPECTIVE_MODE_SCALE because Firfox on Windows machines have problems to deal with very small paths.
            point.x = (point.x - bb.width  * 0.5) / (bb.height * 0.5) * PERSPECTIVE_MODE_SCALE;
            point.y =-(point.y - bb.height * 0.5) / (bb.height * 0.5) * PERSPECTIVE_MODE_SCALE;
        } else {

            point = namespaceUtils.clientToWorld(point.x, point.y, 0, this.viewer);

            // In LMV model is offset by a global offset, we correct this offset when transforming to markups space, so
            // exported markups don't have the offset.
            var globalOffset = this.viewer.model.getData().globalOffset;
            if (globalOffset) {
                point.add(globalOffset);
            }

            point.add(camera.position);
            point.applyMatrix4(camera.matrixWorldInverse);
            point.z = 0;
        }

        return point;
    };

    proto.getSvgViewBox = function(clientWidth, clientHeight) {

        // Get pan offset.
        var lt = this.clientToMarkups(0, 0);
        var rb = this.clientToMarkups(clientWidth, clientHeight);

        var l = Math.min(lt.x, rb.x);
        var t = Math.min(lt.y, rb.y);
        var r = Math.max(lt.x, rb.x);
        var b = Math.max(lt.y, rb.y);

        return [l , t, r-l, b-t].join(' ');
    };

    proto.getBounds = function () {

        return this.bounds;
    };

    proto.getMousePosition = function() {

        // When snapping, use the snap position instead of the mouse position
        // as the start point of the markup drawing.
        // For now only works for 2D.
        if (this.viewer.model.is2d() && this.snapper && this.snapper.isSnapped()) {
            return this.getSnapPosition();
        }
        return this.input.getMousePosition();
    };

    proto.getSnapPosition = function() {

        var geometryType = this.snapper.getHighlightGeometry();
        var geometry = this.snapper.getGeometry();
        var point;

        if (geometryType === SNAP_VERTEX) {
            point = geometry;
        }
        // else if (geometryType === SNAP_EDGE) {
        //     point = this.snapper.nearestPointInPointToEdge(geometry, this.snapper.getIntersectPoint());
        // }
        else { // geometryType === SNAP_CIRCULARARC
            //point = this.snapper.getCircularArcCenter();
            point = this.snapper.nearestPointInPointToEdge(geometry, this.snapper.getIntersectPoint());
        }
        var p = this.project(point);
        return {x: p.x, y: p.y};
    };

    proto.project = function(position) {
        var camera = this.viewer.navigation.getCamera();
        var containerBounds = this.viewer.navigation.getScreenViewport();

        var p = new THREE.Vector3().copy(position);
        p.project(camera);

        return new THREE.Vector3(Math.round((p.x + 1) / 2 * containerBounds.width),
            Math.round((-p.y + 1) / 2 * containerBounds.height), p.z);
    };

    //// Handled Events ////////////////////////////////////////////////////////////////////////////////////////////////

    proto.onCameraChange = function(event) {

        // Update annotations' parent transform.
        var viewBox = this.getSvgViewBox(this.bounds.width, this.bounds.height);

        // HACK, for some reason the 2nd frame returns an empty canvas.
        // The reason why this happens is that the code above calls into the viewer
        // and a division by zero occurs due to LMV canvas having zero width and height
        // When we detect this case, avoid setting the viewBox value and rely on one
        // previously set.
        if (viewBox === "NaN NaN NaN NaN") {
            return;
        }

        this.svg.setAttribute('viewBox', viewBox);

        // Edit frame has to be updated, re-setting the selected markup does the job.
        var editMode = this.editMode;
        if (editMode) {
            var selectedMarkup = editMode.getSelection();
            this.editFrame.setMarkup(selectedMarkup);
        }
    };

    proto.onViewerResize = function(event) {

        this.bounds.x = 0;
        this.bounds.y = 0;
        this.bounds.width = event.width;
        this.bounds.height = event.height;

        this.svg.setAttribute('width', this.bounds.width);
        this.svg.setAttribute('height', this.bounds.height);

        this.onCameraChange();
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @private
     */
    proto.onMouseMove = function(event) {

        if (this.navigating) {
            return;
        }

        if (this.editFrame.isActive() && event.type === 'mousemove') {
            this.editFrame.onMouseMove(event);
        }

        // Only work for 2D
        // Disable snapper in freehand mode
        if (this.viewer.model.is2d() && this.editMode.type !== "freehand") {
            var mousePosition = this.input.getMousePosition();
            this.snapper && this.snapper.onMouseMove(mousePosition);
        }

        this.editMode && this.editMode.onMouseMove(event);
    };

    /**
     * Handler to mouse down events, used to start creation markups.
     * @private
     */
    var mouseDownTimeStamp = 0;
    var mouseDownType = '';
    proto.onMouseDown = function(event) {

        // We have mousedown and singletap events fired on mobile for the same user tap.
        // This fix only let pass one of those events.
        // TODO: Remove this code when using LMV event system instead of ours.
        var timeStamp = performance.now();
        if (timeStamp - mouseDownTimeStamp < 400 && mouseDownType !== event.type) {
            return;
        }
        mouseDownTimeStamp = timeStamp;
        mouseDownType = event.type;

        namespaceUtils.dismissLmvHudMessage();

        var bounds = this.getBounds();
        var mousePosition = this.getMousePosition();

        if (mousePosition.x >= bounds.x && mousePosition.x <= bounds.x + bounds.width &&
            mousePosition.y >= bounds.y && mousePosition.y <= bounds.y + bounds.height) {
            this.editMode.onMouseDown(event);
        }

        // TODO: There is a better way to do this, implement when undo/redo group.
        if(!this.editMode.creating && event.target === this.svg) {
            this.selectMarkup(null);
        }
        this.ignoreNextMouseUp = false;
    };

    var mouseUpTimeStamp = 0;
    var mouseUpType = '';
    proto.onMouseUp = function(event) {

        // We have mousedown and singletap events fired on mobile for the same user tap.
        // This fix only let pass one of those events.
        // TODO: Remove this code when using LMV event system instead of ours.
        var timeStamp = performance.now();
        if (timeStamp - mouseUpTimeStamp < 400 && mouseUpType !== event.type) {
            return;
        }
        mouseUpTimeStamp = timeStamp;
        mouseUpType = event.type;

        if (this.navigating) {
            return;
        }

        if (this.editFrame.isActive()) {
            this.editFrame.onMouseUp(event);
            return;
        }

        if(!this.ignoreNextMouseUp) {
            this.editMode.onMouseUp(event);
        }
    };

    proto.onMouseDoubleClick = function(event) {

        if (this.navigating) {
            return;
        }

        if (this.editFrame.isActive()) {
            return;
        }

        this.editMode.onMouseDoubleClick(event);
    };

    proto.onUserCancel = function() {

        if (this.editMode.creating) {
            this.editMode.creationCancel();
        } else {
            this.editMode.unselect();
        }
    };

    /**
     *
     * @param event
     */
    proto.onMarkupSelected = function(event) {

        this.selectMarkup(event.markup);
        this.fireEvent(event);
    };

    proto.onMarkupEnterEdition = function(event) {

    };

    proto.onMarkupCancelEdition = function(event) {

        this.onUserCancel();
    };

    proto.onMarkupDeleteEdition = function(event) {

        this.removeMarkup(event.markup);
        this.editMode.deleteMarkup();
    };

    Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.MarkupsCore', MarkupsCore);
})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param id
     * @param markup
     * @param position
     * @constructor
     */
    function CloneMarkup(editor, id, markup, position) {

        namespace.EditAction.call(this, editor, 'CLONE-MARKUP', id);

        this.clone = markup.clone();
        this.clone.id = id;
        this.position = {x: position.x, y: position.y};
    }

    CloneMarkup.prototype = Object.create(namespace.EditAction.prototype);
    CloneMarkup.prototype.constructor = CloneMarkup;

    var proto = CloneMarkup.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var clone = this.clone;
        var position = this.position;

        if (editor.getMarkup(this.targetId)) {
            return;
        }

        var markup = clone.clone();
        markup.setPosition(position.x, position.y);

        editor.addMarkup(markup);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CloneMarkup = CloneMarkup;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * @constructor
     */
    function CreateArrow(editor, id, head, tail, style) {

        namespace.EditAction.call(this, editor, 'CREATE-ARROW', id);

        this.selectOnExecution = false;
        this.tail = tail;
        this.head = head;
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreateArrow.prototype = Object.create(namespace.EditAction.prototype);
    CreateArrow.prototype.constructor = CreateArrow;

    var proto = CreateArrow.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var arrow = new namespace.MarkupArrow(this.targetId, editor);

        editor.addMarkup(arrow);

        arrow.set(this.head.x, this.head.y, this.tail.x, this.tail.y);
        arrow.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreateArrow = CreateArrow;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * Markup create circle action.
     *
     * Implements an [EditAction]{@link Autodesk.Viewing.Extensions.Markups.Core.EditAction}
     * for creating a Circle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.
     * Included in documentation as an example of how to create
     * a specific EditAction that deals with Markup creation.
     * Developers are encourage to look into this class's source code and copy
     * as much code as they need. Find link to source code below.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param rotation
     * @param style
     * @category Extensions
     */
    function CreateCircle(editor, id, position, size, rotation, style) {

        namespace.EditAction.call(this, editor, 'CREATE-CIRCLE', id);

        this.selectOnExecution = false;
        this.position = {x: position.x, y: position.y};
        this.size = {x: size.x, y: size.y};
        this.rotation = rotation;
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreateCircle.prototype = Object.create(namespace.EditAction.prototype);
    CreateCircle.prototype.constructor = CreateCircle;

    var proto = CreateCircle.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var circle = new namespace.MarkupCircle(this.targetId, editor);

        editor.addMarkup(circle);

        circle.setSize(this.position, this.size.x, this.size.y);
        circle.setRotation(this.rotation);
        circle.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreateCircle = CreateCircle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param rotation
     * @param style
     * @constructor
     */
    function CreateCloud(editor, id, position, size, rotation, style) {

        namespace.EditAction.call(this, editor, 'CREATE-CLOUD', id);

        this.selectOnExecution = false;
        this.position = {x: position.x, y: position.y};
        this.size = {x: size.x, y: size.y};
        this.rotation = rotation;
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreateCloud.prototype = Object.create(namespace.EditAction.prototype);
    CreateCloud.prototype.constructor = CreateCloud;

    var proto = CreateCloud.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var cloud = new namespace.MarkupCloud(this.targetId, editor);

        editor.addMarkup(cloud);

        cloud.set(this.position, this.size);
        cloud.setRotation(this.rotation);
        cloud.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreateCloud = CreateCloud;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param rotation
     * @param locations
     * @param style
     * @constructor
     */
    function CreateFreehand(editor, id, position, size, rotation, locations, style) {

        namespace.EditAction.call(this, editor, 'CREATE-FREEHAND', id);

        this.selectOnExecution = false;
        this.position = position;
        this.size = size;
        this.rotation = rotation;
        this.movements = locations.concat();
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreateFreehand.prototype = Object.create(namespace.EditAction.prototype);
    CreateFreehand.prototype.constructor = CreateFreehand;

    var proto = CreateFreehand.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var freehand = new namespace.MarkupFreehand(this.targetId, editor);

        editor.addMarkup(freehand);

        freehand.set(this.position, this.size, this.movements);
        freehand.setRotation(this.rotation);
        freehand.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreateFreehand = CreateFreehand;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param rotation
     * @param locations
     * @param style
     * @constructor
     */
    function CreatePolycloud(editor, id, position, size, rotation, locations, style) {

        namespace.EditAction.call(this, editor, 'CREATE-POLYCLOUD', id);

        this.selectOnExecution = false;
        this.position = position;
        this.size = size;
        this.rotation = rotation;
        this.movements = locations.concat();
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreatePolycloud.prototype = Object.create(namespace.EditAction.prototype);
    CreatePolycloud.prototype.constructor = CreatePolycloud;

    var proto = CreatePolycloud.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var polyline = new namespace.MarkupPolycloud(this.targetId, editor);

        editor.addMarkup(polyline);

        polyline.set(this.position, this.size, this.movements);
        polyline.setRotation(this.rotation);
        polyline.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreatePolycloud = CreatePolycloud;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param rotation
     * @param locations
     * @param style
     * @constructor
     */
    function CreatePolyline(editor, id, position, size, rotation, locations, style) {

        namespace.EditAction.call(this, editor, 'CREATE-POLYLINE', id);

        this.selectOnExecution = false;
        this.position = position;
        this.size = size;
        this.rotation = rotation;
        this.movements = locations.concat();
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreatePolyline.prototype = Object.create(namespace.EditAction.prototype);
    CreatePolyline.prototype.constructor = CreatePolyline;

    var proto = CreatePolyline.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var polyline = new namespace.MarkupPolyline(this.targetId, editor);

        editor.addMarkup(polyline);

        polyline.set(this.position, this.size, this.movements);
        polyline.setRotation(this.rotation);
        polyline.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreatePolyline = CreatePolyline;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param rotation
     * @param style
     * @constructor
     */
    function CreateRectangle(editor, id, position, size, rotation, style) {

        namespace.EditAction.call(this, editor, 'CREATE-RECTANGLE', id);

        this.selectOnExecution = false;
        this.position = {x: position.x, y: position.y};
        this.size = {x: size.x, y: size.y};
        this.rotation = rotation;
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreateRectangle.prototype = Object.create(namespace.EditAction.prototype);
    CreateRectangle.prototype.constructor = CreateRectangle;

    var proto = CreateRectangle.prototype;

    proto.redo = function() {

        var editor = this.editor;
        var rectangle = new namespace.MarkupRectangle(this.targetId, editor);

        editor.addMarkup(rectangle);

        rectangle.set(this.position, this.size);
        rectangle.setRotation(this.rotation);
        rectangle.setStyle(this.style);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && this.editor.removeMarkup(markup);
    };

    namespace.CreateRectangle = CreateRectangle;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param id
     * @param position
     * @param size
     * @param text
     * @param style
     * @constructor
     */
    function CreateText(editor, id, position, size, text, style ) {

        namespace.EditAction.call(this, editor, 'CREATE-TEXT', id);

        this.text = text;
        this.position = {x: position.x, y: position.y};
        this.size = {x: size.x, y: size.y};
        this.style = namespaceUtils.cloneStyle(style);
    }

    CreateText.prototype = Object.create(namespace.EditAction.prototype);
    CreateText.prototype.constructor = CreateText;

    var proto = CreateText.prototype;

    proto.redo = function () {

        var editor = this.editor;
        var position = this.position;
        var size = this.size;

        var text = new namespace.MarkupText(this.targetId, editor, size);

        editor.addMarkup(text);

        text.setSize(position, size.x, size.y);
        text.setText(this.text);
        text.setStyle(this.style);
    };

    proto.undo = function () {

        var markup = this.editor.getMarkup(this.targetId);
        if (markup) {
            this.editor.removeMarkup(markup);
            markup.destroy();
        }
    };

    namespace.CreateText = CreateText;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param arrow
     * @constructor
     */
    function DeleteArrow(editor, arrow) {

        namespace.EditAction.call(this, editor, 'DELETE-ARROW', arrow.id);
        this.createArrow = new namespace.CreateArrow(
            editor,
            arrow.id,
            arrow.head,
            arrow.tail,
            arrow.getStyle());
    }

    DeleteArrow.prototype = Object.create(namespace.EditAction.prototype);
    DeleteArrow.prototype.constructor = DeleteArrow;

    var proto = DeleteArrow.prototype;

    proto.redo = function() {

        this.createArrow.undo();
    };

    proto.undo = function() {

        this.createArrow.redo();
    };

    namespace.DeleteArrow = DeleteArrow;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     * Markup delete circle action.
     * 
     * Implements an [EditAction]{@link Autodesk.Viewing.Extensions.Markups.Core.EditAction}
     * for deleting a Circle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.
     * Included in documentation as an example of how to create
     * a specific EditAction that deals with Markup deletion.
     * Developers are encourage to look into this class's source code and copy
     * as much code as they need. Find link to source code below.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction
     *
     * @param editor
     * @param circle
     * @category Extensions
     */
    function DeleteCircle(editor, circle) {

        namespace.EditAction.call(this, editor, 'DELETE-CIRCLE', circle.id);
        this.createCircle = new namespace.CreateCircle(
            editor,
            circle.id,
            circle.position,
            circle.size,
            circle.rotation,
            circle.getStyle());
    }

    DeleteCircle.prototype = Object.create(namespace.EditAction.prototype);
    DeleteCircle.prototype.constructor = DeleteCircle;

    var proto = DeleteCircle.prototype;

    proto.redo = function() {

        this.createCircle.undo();
    };

    proto.undo = function() {

        this.createCircle.redo();
    };

    namespace.DeleteCircle = DeleteCircle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param cloud
     * @constructor
     */
    function DeleteCloud(editor, cloud) {

        namespace.EditAction.call(this, editor, 'DELETE-CLOUD', cloud.id);
        this.createCloud = new namespace.CreateCloud(
            editor,
            cloud.id,
            cloud.position,
            cloud.size,
            cloud.rotation,
            cloud.getStyle());
    }

    DeleteCloud.prototype = Object.create(namespace.EditAction.prototype);
    DeleteCloud.prototype.constructor = DeleteCloud;

    var proto = DeleteCloud.prototype;

    proto.redo = function() {

        this.createCloud.undo();
    };

    proto.undo = function() {

        this.createCloud.redo();
    };

    namespace.DeleteCloud = DeleteCloud;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param freehand
     * @constructor
     */
    function DeleteFreehand(editor, freehand) {

        namespace.EditAction.call(this, editor, 'DELETE-FREEHAND', freehand.id);
        this.createFreehand = new namespace.CreateFreehand(
            editor,
            freehand.id,
            freehand.position,
            freehand.size,
            freehand.rotation,
            freehand.locations,
            freehand.getStyle());
    }

    DeleteFreehand.prototype = Object.create(namespace.EditAction.prototype);
    DeleteFreehand.prototype.constructor = DeleteFreehand;

    var proto =  DeleteFreehand.prototype;

    proto.redo = function() {

        this.createFreehand.undo();
    };

    proto.undo = function() {

        this.createFreehand.redo();
    };

    namespace.DeleteFreehand = DeleteFreehand;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param polycloud
     * @constructor
     */
    function DeletePolycloud(editor, polycloud) {

        namespace.EditAction.call(this, editor, 'DELETE-POLYCLOUD', polycloud.id);
        this.createPolycloud = new namespace.CreatePolyline(
            editor,
            polycloud.id,
            polycloud.position,
            polycloud.size,
            polycloud.rotation,
            polycloud.locations,
            polycloud.getStyle());
    }

    DeletePolycloud.prototype = Object.create(namespace.EditAction.prototype);
    DeletePolycloud.prototype.constructor = DeletePolycloud;

    var proto =  DeletePolycloud.prototype;

    proto.redo = function() {

        this.createPolycloud.undo();
    };

    proto.undo = function() {

        this.createPolycloud.redo();
    };

    namespace.DeletePolycloud = DeletePolycloud;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param polyline
     * @constructor
     */
    function DeletePolyline(editor, polyline) {

        namespace.EditAction.call(this, editor, 'DELETE-POLYLINE', polyline.id);
        this.createPolyline = new namespace.CreatePolyline(
            editor,
            polyline.id,
            polyline.position,
            polyline.size,
            polyline.rotation,
            polyline.locations,
            polyline.getStyle());
    }

    DeletePolyline.prototype = Object.create(namespace.EditAction.prototype);
    DeletePolyline.prototype.constructor = DeletePolyline;

    var proto =  DeletePolyline.prototype;

    proto.redo = function() {

        this.createPolyline.undo();
    };

    proto.undo = function() {

        this.createPolyline.redo();
    };

    namespace.DeletePolyline = DeletePolyline;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param rectangle
     * @constructor
     */
    var DeleteRectangle = function(editor, rectangle) {

        namespace.EditAction.call(this, editor, 'DELETE-RECTANGLE', rectangle.id);
        this.createRectangle = new namespace.CreateRectangle(
            editor,
            rectangle.id,
            rectangle.position,
            rectangle.size,
            rectangle.rotation,
            rectangle.getStyle());
    };

    DeleteRectangle.prototype = Object.create(namespace.EditAction.prototype);
    DeleteRectangle.prototype.constructor = DeleteRectangle;

    var proto = DeleteRectangle.prototype;

    proto.redo = function() {

        this.createRectangle.undo();
    };

    proto.undo = function() {

        this.createRectangle.redo();
    };

    namespace.DeleteRectangle = DeleteRectangle;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param text
     * @constructor
     */
    function DeleteText(editor, text) {

        namespace.EditAction.call(this, editor, 'DELETE-TEXT', text.id);

        var position = {x: text.position.x, y: text.position.y};
        var size = {x: text.size.x, y: text.size.y};

        this.createText = new namespace.CreateText(
            editor,
            text.id,
            position,
            size,
            text.getText(),
            text.getStyle());
    }

    DeleteText.prototype = Object.create(namespace.EditAction.prototype);
    DeleteText.prototype.constructor = DeleteText;

    var proto = DeleteText.prototype;

    proto.redo = function() {

        this.createText.undo();
    };

    proto.undo = function() {

        this.createText.redo();
    };

    namespace.DeleteText = DeleteText;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     * This class will group actions edit actions that should be executed as a whole.
     * When a group is open actions can be added to it, similar actions will be merged into one during this process.
     * This class is not intended to be used by users, it's a helper class of EditActionManager.
     * @constructor
     */
    function EditActionGroup() {

        this.actions = [];
        this.closed = true;
    }

    var proto = EditActionGroup.prototype;

    /**
     *
     * @returns {boolean}
     */
    proto.open = function() {

        if(!this.closed) {
            return false;
        }

        this.closed = false;
        return true;
    };

    /**
     *
     * @returns {boolean}
     */
    proto.close = function() {

        if (this.closed) {
            return false;
        }

        this.closed = true;
        return true;
    };

    /**
     *
     * @returns {number} targetId
     */
    proto.undo = function() {

        var actions = this.actions;
        var actionsMaxIndex = actions.length - 1;

        var targetId = -1;
        for(var i = actionsMaxIndex; i >= 0; --i) {

            var action =  actions[i];
            action.undo();

            if (action.targetId !== -1) {
                targetId = action.targetId;
            }
        }

        return targetId;
    };

    /**
     *
     * @returns {number} targetId
     */
    proto.redo = function() {

        var actions = this.actions;
        var actionsCount = actions.length;

        var targetId = -1;
        for(var i = 0; i < actionsCount; ++i) {

            var action =  actions[i];
            action.redo();

            if (action.targetId !== -1) {
                targetId = action.targetId;
            }
        }

        return targetId;
    };

    /**
     *
     * @returns {boolean}
     */
    proto.isOpen = function() {

        return !this.closed;
    };

    /**
     *
     * @returns {boolean}
     */
    proto.isClosed = function() {

        return this.closed;
    };

    /**
     *
     * @returns {boolean}
     */
    proto.isEmpty = function() {

        return this.actions.length === 0;
    };

    /**
     *
     * @param {EditAction} action
     */
    proto.addAction = function(action) {

        if (this.closed) {
            return false;
        }

        this.actions.push(action);
        this.compact();

        return true;
    };

    /**
     * @private
     */
    proto.compact = function() {

        var actions = this.actions;
        var actionsCount = actions.length;

        for(var i = 0; i < actionsCount; ++i) {

            // If an action does nothing, remove it.
            var actionA = actions[i];
            if (actionA.isIdentity()) {
                actions.splice(i, 1);
                --actionsCount;
                --i;
                continue;
            }

            // If an action can be merged, merge it.
            for (var j = i + 1; j < actionsCount; ++j) {

                var actionB = actions[j];
                if (actionA.type === actionB.type &&
                    actionA.merge(actionB)) {
                    actions.splice(j, 1);
                    --actionsCount;
                    --i;
                    break;
                }
            }
        }
    };

    namespace.EditActionGroup = EditActionGroup;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param arrow
     * @param head
     * @param tail
     * @constructor
     */
    function SetArrow(editor, arrow, head, tail) {

        namespace.EditAction.call(this, editor, 'SET-ARROW', arrow.id);

        this.newHead = {x: head.x, y: head.y};
        this.newTail = {x: tail.x, y: tail.y};
        this.oldHead = {x: arrow.head.x, y: arrow.head.y};
        this.oldTail = {x: arrow.tail.x, y: arrow.tail.y};
    }

    SetArrow.prototype = Object.create(namespace.EditAction.prototype);
    SetArrow.prototype.constructor = SetArrow;

    var proto = SetArrow.prototype;

    proto.redo = function() {

        this.applyState(this.targetId, this.newHead, this.newTail);
    };

    proto.undo = function() {

        this.applyState(this.targetId, this.oldHead, this.oldTail);
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newHead = action.newHead;
            this.newTail = action.newTail;
            return true;
        }
        return false;
    };

    /**
     *
     * @private
     */
    proto.applyState = function(targetId, head, tail) {

        var arrow = this.editor.getMarkup(targetId);
        if(!arrow) {
            return;
        }

        // Different stroke widths make positions differ at sub-pixel level.
        var epsilon = 0.0001;

        if (Math.abs(arrow.head.x - head.x) >= epsilon || Math.abs(arrow.head.y - head.y) >= epsilon ||
            Math.abs(arrow.tail.x - tail.x) >= epsilon || Math.abs(arrow.tail.y - tail.y) >= epsilon) {

            arrow.set(head.x, head.y, tail.x, tail.y);
        }
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return (
            this.newHead.x === this.oldHead.x &&
            this.newHead.y === this.oldHead.y &&
            this.newTail.x === this.oldTail.x &&
            this.newTail.y === this.oldTail.y);
    };

    namespace.SetArrow = SetArrow;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     * Markup set circle action.
     *
     * Implements an [EditAction]{@link Autodesk.Viewing.Extensions.Markups.Core.EditAction}
     * for editing properties of a Circle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.
     * Included in documentation as an example of how to create
     * a specific EditAction that deals with Markup edition.
     * Developers are encourage to look into this class's source code and copy
     * as much code as they need. Find link to source code below.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction
     *
     * @param editor
     * @param circle
     * @param position
     * @param size
     * @category Extensions
     */
    function SetCircle(editor, circle, position, size) {

        namespace.EditAction.call(this, editor, 'SET-CIRCLE', circle.id);

        this.newPosition = {x: position.x, y: position.y};
        this.newSize = {x: size.x, y: size.y};
        this.oldPosition = {x: circle.position.x, y: circle.position.y};
        this.oldSize = {x: circle.size.x, y: circle.size.y};
    }

    SetCircle.prototype = Object.create(namespace.EditAction.prototype);
    SetCircle.prototype.constructor = SetCircle;

    var proto = SetCircle.prototype;

    proto.redo = function() {

        this.applyState(this.targetId, this.newPosition, this.newSize);
    };

    proto.undo = function() {

        this.applyState(this.targetId, this.oldPosition, this.oldSize);
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newPosition = action.newPosition;
            this.newSize = action.newSize;
            return true;
        }
        return false;
    };

    /**
     *
     * @private
     */
    proto.applyState = function(targetId, position, size) {

        var circle = this.editor.getMarkup(targetId);
        if(!circle) {
            return;
        }

        // Different stroke widths make positions differ at sub-pixel level.
        var epsilon = 0.0001;

        if (Math.abs(circle.position.x - position.x) > epsilon || Math.abs(circle.size.y - size.y) > epsilon ||
            Math.abs(circle.position.y - position.y) > epsilon || Math.abs(circle.size.y - size.y) > epsilon) {

            circle.set(position, size);
        }
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return (
            this.newPosition.x === this.oldPosition.x &&
            this.newPosition.y === this.oldPosition.y &&
            this.newSize.x === this.oldSize.x &&
            this.newSize.y === this.oldSize.y);
    };

    namespace.SetCircle = SetCircle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param cloud
     * @param position
     * @param size
     * @constructor
     */
    function SetCloud(editor, cloud, position, size) {

        namespace.EditAction.call(this, editor, 'SET-CLOUD', cloud.id);

        this.newPosition = {x: position.x, y: position.y};
        this.newSize = {x: size.x, y: size.y};
        this.oldPosition = {x: cloud.position.x, y: cloud.position.y};
        this.oldSize = {x: cloud.size.x, y: cloud.size.y};
    }

    SetCloud.prototype = Object.create(namespace.EditAction.prototype);
    SetCloud.prototype.constructor = SetCloud;

    var proto = SetCloud.prototype;

    proto.redo = function() {

        this.applyState(this.targetId, this.newPosition, this.newSize, this.newStrokeWidth, this.newColor);
    };

    proto.undo = function() {

        this.applyState(this.targetId, this.oldPosition, this.oldSize, this.oldStrokeWidth, this.oldColor);
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newPosition = action.newPosition;
            this.newSize = action.newSize;
            return true;
        }
        return false;
    };

    /**
     *
     * @private
     */
    proto.applyState = function(targetId, position, size) {

        var cloud = this.editor.getMarkup(targetId);
        if(!cloud) {
            return;
        }

        // Different stroke widths make positions differ at sub-pixel level.
        var epsilon = 0.0001;

        if (Math.abs(cloud.position.x - position.x) > epsilon || Math.abs(cloud.size.y - size.y) > epsilon ||
            Math.abs(cloud.position.y - position.y) > epsilon || Math.abs(cloud.size.y - size.y) > epsilon) {

            cloud.set(position, size);
        }
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return (
            this.newPosition.x === this.oldPosition.x &&
            this.newPosition.y === this.oldPosition.y &&
            this.newSize.x === this.oldSize.x &&
            this.newSize.y === this.oldSize.y);
    };

    namespace.SetCloud = SetCloud;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param freehand
     * @param position
     * @param size
     * @param locations
     * @constructor
     */
    function SetFreehand(editor, freehand, position, size, locations) {

        namespace.EditAction.call(this, editor, 'SET-FREEHAND', freehand.id);

        this.position = position;
        this.size = size;
        this.locations = locations.concat();

        // No need to save old data
    }

    SetFreehand.prototype = Object.create(namespace.EditAction.prototype);
    SetFreehand.prototype.constructor = SetFreehand;

    var proto = SetFreehand.prototype;

    proto.redo = function() {

        var freehand = this.editor.getMarkup(this.targetId);
        if(!freehand) {
            return;
        }

        freehand.set(this.position, this.size, this.locations);
    };

    proto.undo = function() {
        // No need for undo.
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.locations = action.locations.concat();
            this.position = action.position;
            this.size = action.size;
            return true;
        }
        return false;
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return false; // No need to optimize, always false.
    };

    namespace.SetFreehand = SetFreehand;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param polycloud
     * @param position
     * @param size
     * @param locations
     * @param closed
     * @constructor
     */
    function SetPolycloud(editor, polycloud, position, size, locations, closed) {

        namespace.EditAction.call(this, editor, 'SET-POLYCLOUD', polycloud.id);

        this.position = position;
        this.size = size;
        this.locations = locations.concat();
        this.closed = closed;

        // No need to save old data
    }

    SetPolycloud.prototype = Object.create(namespace.EditAction.prototype);
    SetPolycloud.prototype.constructor = SetPolycloud;

    var proto = SetPolycloud.prototype;

    proto.redo = function() {

        var polycloud = this.editor.getMarkup(this.targetId);
        if(!polycloud) {
            return;
        }

        polycloud.set(this.position, this.size, this.locations, this.closed);
    };

    proto.undo = function() {
        // No need for undo.
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.locations = action.locations.concat();
            this.position = action.position;
            this.size = action.size;
            this.closed = action.closed;
            return true;
        }
        return false;
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return false; // No need to optimize, always false.
    };

    namespace.SetPolycloud = SetPolycloud;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param polyline
     * @param position
     * @param size
     * @param locations
     * @param closed
     * @constructor
     */
    function SetPolyline(editor, polyline, position, size, locations, closed) {

        namespace.EditAction.call(this, editor, 'SET-POLYLINE', polyline.id);

        this.position = position;
        this.size = size;
        this.locations = locations.concat();
        this.closed = closed;

        // No need to save old data
    }

    SetPolyline.prototype = Object.create(namespace.EditAction.prototype);
    SetPolyline.prototype.constructor = SetPolyline;

    var proto = SetPolyline.prototype;

    proto.redo = function() {

        var polyline = this.editor.getMarkup(this.targetId);
        if(!polyline) {
            return;
        }

        polyline.set(this.position, this.size, this.locations, this.closed);
    };

    proto.undo = function() {
        // No need for undo.
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.locations = action.locations.concat();
            this.position = action.position;
            this.size = action.size;
            this.closed = action.closed;
            return true;
        }
        return false;
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return false; // No need to optimize, always false.
    };

    namespace.SetPolyline = SetPolyline;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    function SetPosition(editor, markup, position) {

        namespace.EditAction.call(this, editor, 'SET-POSITION', markup.id);

        this.newPosition = {x: position.x, y: position.y};
        this.oldPosition = {x: markup.position.x, y: markup.position.y};
    }

    SetPosition.prototype = Object.create(namespace.EditAction.prototype);
    SetPosition.prototype.constructor = SetPosition;

    var proto = SetPosition.prototype;

    proto.redo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setPosition(this.newPosition.x, this.newPosition.y);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setPosition(this.oldPosition.x, this.oldPosition.y);
    };

    /**
     *
     * @param action
     * @returns {boolean}
     */
    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newPosition = action.newPosition;
            return true;
        }
        return false;
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        var newPosition = this.newPosition;
        var oldPosition = this.oldPosition;

        return newPosition.x === oldPosition.x && newPosition.y === oldPosition.y;
    };

    namespace.SetPosition = SetPosition;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param rectangle
     * @param position
     * @param size
     * @constructor
     */
    function SetRectangle(editor, rectangle, position, size) {

        namespace.EditAction.call(this, editor, 'SET-RECTANGLE', rectangle.id);

        this.newPosition = {x: position.x, y: position.y};
        this.newSize = {x: size.x, y: size.y};
        this.oldPosition = {x: rectangle.position.x, y: rectangle.position.y};
        this.oldSize = {x: rectangle.size.x, y: rectangle.size.y};
    }

    SetRectangle.prototype = Object.create(namespace.EditAction.prototype);
    SetRectangle.prototype.constructor = SetRectangle;

    var proto = SetRectangle.prototype;

    proto.redo = function() {

        this.applyState(this.targetId, this.newPosition, this.newSize);
    };

    proto.undo = function() {

        this.applyState(this.targetId, this.oldPosition, this.oldSize);
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newPosition = action.newPosition;
            this.newSize = action.newSize;
            return true;
        }
        return false;
    };

    /**
     *
     * @private
     */
    proto.applyState = function(targetId, position, size) {

        var rectangle = this.editor.getMarkup(targetId);
        if(!rectangle) {
            return;
        }

        // Different stroke widths make positions differ at sub-pixel level.
        var epsilon = 0.0001;

        if (Math.abs(rectangle.position.x - position.x) > epsilon || Math.abs(rectangle.size.y - size.y) > epsilon ||
            Math.abs(rectangle.position.y - position.y) > epsilon || Math.abs(rectangle.size.y - size.y) > epsilon) {

            rectangle.set(position, size);
        }
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return(
            this.newPosition.x === this.oldPosition.x &&
            this.newPosition.y === this.oldPosition.y &&
            this.newSize.x === this.oldSize.x &&
            this.newSize.y === this.oldSize.y);
    };

    namespace.SetRectangle = SetRectangle;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param markup
     * @param angle
     * @constructor
     */
    function SetRotation(editor, markup, angle) {

        namespace.EditAction.call(this, editor, 'SET-ROTATION', markup.id);

        var curAngle = markup.getRotation();

        this.newRotation = {angle: angle};
        this.oldRotation = {angle: curAngle};
    }

    SetRotation.prototype = Object.create(namespace.EditAction.prototype);
    SetRotation.prototype.constructor = SetRotation;

    var proto = SetRotation.prototype;

    proto.redo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setRotation(this.newRotation.angle);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setRotation(this.oldRotation.angle);
    };

    /**
     *
     * @param action
     * @returns {boolean}
     */
    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newRotation = action.newRotation;
            return true;
        }
        return false;
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        return this.newRotation.angle === this.oldRotation.angle;
    };

    namespace.SetRotation = SetRotation;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param markup
     * @param position
     * @param width
     * @param height
     * @constructor
     */
    function SetSize(editor, markup, position, width, height) {

        namespace.EditAction.call(this, editor, 'SET-SIZE', markup.id);

        this.newPosition = {x: position.x, y: position.y};
        this.oldPosition = {x: markup.position.x, y: markup.position.y};
        this.newWidth = width;
        this.oldWidth = markup.size.x;
        this.newHeight = height;
        this.oldHeight = markup.size.y;
    }

    SetSize.prototype = Object.create(namespace.EditAction.prototype);
    SetSize.prototype.constructor = SetSize;

    var proto = SetSize.prototype;

    proto.redo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setSize(this.newPosition, this.newWidth, this.newHeight);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setSize(this.oldPosition, this.oldWidth, this.oldHeight);
    };

    proto.merge = function(action) {

        if (this.targetId === action.targetId &&
            this.type === action.type) {

            this.newPosition = action.newPosition;
            this.newWidth = action.newWidth;
            this.newHeight = action.newHeight;
            return true;
        }
        return false;
    };

    /**
     * @returns {boolean}
     */
    proto.isIdentity = function() {

        var identity =
            this.newPosition.x === this.oldPosition.x &&
            this.newPosition.y === this.oldPosition.y &&
            this.newWidth === this.oldWidth &&
            this.newHeight === this.oldHeight;

        return identity;
    };

    namespace.SetSize = SetSize;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @param markup
     * @param style
     * @constructor
     */
    function SetStyle(editor, markup, style) {

        namespace.EditAction.call(this, editor, 'SET-STYLE', markup.id);

        this.newStyle = namespaceUtils.cloneStyle(style);
        this.oldStyle = markup.getStyle();
    }

    SetStyle.prototype = Object.create(namespace.EditAction.prototype);
    SetStyle.prototype.constructor = SetStyle;

    var proto = SetStyle.prototype;

    proto.redo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setStyle(this.newStyle);
    };

    proto.undo = function() {

        var markup = this.editor.getMarkup(this.targetId);
        markup && markup.setStyle(this.oldStyle);
    };

    namespace.SetStyle = SetStyle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @param markup
     * @param position
     * @param size
     * @param text
     * @constructor
     */
    function SetText(editor, markup, position, size, text) {

        namespace.EditAction.call(this, editor, 'SET-TEXT', markup.id);

        this.newPosition = {x: position.x, y: position.y};
        this.oldPosition = {x: markup.position.x, y: markup.position.y};
        this.newSize = {x: size.x, y: size.y};
        this.oldSize = {x: markup.size.x, y: markup.size.y};
        this.newText = text;
        this.oldText = markup.getText();
    }

    SetText.prototype = Object.create(namespace.EditAction.prototype);
    SetText.prototype.constructor = SetText;

    var proto = SetText.prototype;

    proto.redo = function() {

        var text = this.editor.getMarkup(this.targetId);
        text && text.set(this.newPosition, this.newSize, this.newText);
    };

    proto.undo = function() {

        var text = this.editor.getMarkup(this.targetId);
        text && text.set(this.oldPosition, this.oldSize, this.oldText);
    };

    namespace.SetText = SetText;

})();

(function() { 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     *
     * @param editor
     * @constructor
     */
    function Clipboard(editor) {

        this.editor = editor;
        this.content = null;
        this.pastePosition = {x:0, y: 0};

        namespaceUtils.addTraitEventDispatcher(this);
    }

    var proto = Clipboard.prototype;

    proto.copy = function() {

        var selectedMarkup = this.editor.getSelection();
        if(!selectedMarkup) {
            return;
        }

        this.content = selectedMarkup.clone();
        this.pastePosition.x = selectedMarkup.position.x;
        this.pastePosition.y = selectedMarkup.position.y;
    };

    proto.cut = function() {

        var selectedMarkup = this.editor.getSelection();
        if(!selectedMarkup) {
            return;
        }

        this.copy();
        this.editor.deleteMarkup(selectedMarkup);
    };

    proto.paste = function() {

        var content = this.content;
        if(!content) {
            return;
        }

        var editor = this.editor;
        var position = this.pastePosition;
        var delta = editor.sizeFromClientToMarkups(20, 20);

        position.x += delta.x;
        position.y -= delta.y;

        var cloneMarkup = new namespace.CloneMarkup(editor, editor.getId(), content, position);
        cloneMarkup.execute();
    };

    namespace.Clipboard = Clipboard;
})();

(function() { 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    function InputHandler() {

        this.editor = null;
        this.mousePosition = {x:0, y:0};
        this.makeSameXY = false; // TODO: FIND a better way to name and communicate these.
        this.snapRotations = false;
        this.keepAspectRatio = false;
        this.constrainAxis = false;

        this.onWheelBinded = this.onWheel.bind(this);
        this.onTouchDragBinded = this.onTouchDrag.bind(this);
        this.onSingleTapBinded = this.onSingleTap.bind(this);
        this.onDoubleTapBinded = this.onDoubleTap.bind(this);
        this.onMouseMoveBinded = this.onMouseMove.bind(this);
        this.onMouseUpBinded = this.onMouseUp.bind(this);
        this.onMouseDownBinded = this.onMouseDown.bind(this);
        this.onMouseDoubleClickBinded = this.onMouseDoubleClick.bind(this);

        this.isMouseDown = false;
    }

    var proto = InputHandler.prototype;

    proto.attachTo = function(editor) {

        this.editor && this.detachFrom(this.editor);
        this.editor = editor;

        if (namespaceUtils.isTouchDevice()) {

            this.hammer = new Hammer.Manager(editor.svg, {
                recognizers: [
                    // RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]
                    [Hammer.Pan, { event: 'drag', pointers: 1 } ],
                    [Hammer.Tap, { event: 'doubletap', taps: 2, interval: 300, threshold: 6, posThreshold: 30 } ],
                    [Hammer.Tap, { event: 'doubletap2', pointers: 2, taps: 2, interval: 300, threshold: 6, posThreshold: 40 } ],
                    [Hammer.Tap, { event: 'singletap2', pointers: 2, threshold: 3 } ],
                    [Hammer.Tap, { event: 'singletap', threshold: 2 } ],
                    [Hammer.Press, { event: 'press', time: 500 } ]
                ],
                inputClass: Hammer.TouchInput
            });

            this.hammer.get('doubletap2').recognizeWith('doubletap');
            this.hammer.get('singletap2').recognizeWith('singletap');
            this.hammer.get('singletap').requireFailure('doubletap');
        }
    };

    proto.detachFrom = function(editor) {

        this.hammer && this.hammer.destroy();

        document.removeEventListener('mousemove', this.onMouseMoveBinded, true);
        document.removeEventListener('mouseup', this.onMouseUpBinded, true);

        if (this.editor) {
            this.editor.svg.removeEventListener("mousedown", this.onMouseDownBinded);
            this.editor.svg.removeEventListener("dblclick", this.onMouseDoubleClickBinded);
        }

        this.editor = editor;
    };

    proto.enterEditMode = function() {

        if (this.hammer) {
            this.hammer.on("dragstart dragmove dragend", this.onTouchDragBinded);
            this.hammer.on("singletap", this.onSingleTapBinded);
            this.hammer.on("singletap2", this.onSingleTapBinded);
            this.hammer.on("doubletap", this.onDoubleTapBinded);
            this.hammer.on("doubletap2", this.onDoubleTapBinded);
        }

        document.addEventListener('mousemove', this.onMouseMoveBinded, true);
        document.addEventListener('mouseup', this.onMouseUpBinded, true);
        this.editor.svg.addEventListener("mousedown", this.onMouseDownBinded);
        this.editor.svg.addEventListener("dblclick", this.onMouseDoubleClickBinded);
        this.editor.svg.removeEventListener("wheel", this.onWheelBinded);
    };

    proto.leaveEditMode = function() {

        if (this.hammer) {
            this.hammer.off("dragstart dragmove dragend", this.onTouchDragBinded);
            this.hammer.off("singletap", this.onSingleTapBinded);
            this.hammer.off("singletap2", this.onSingleTapBinded);
            this.hammer.off("doubletap", this.onDoubleTapBinded);
            this.hammer.off("doubletap2", this.onDoubleTapBinded);
        }

        document.removeEventListener("mousemove", this.onMouseMoveBinded, true);
        document.removeEventListener("mouseup", this.onMouseUpBinded, true);
        this.editor.svg.removeEventListener("mousedown", this.onMouseDownBinded);
        this.editor.svg.removeEventListener("dblclick", this.onMouseDoubleClickBinded);
        this.editor.svg.removeEventListener("wheel", this.onWheelBinded);
    };

    proto.enterViewMode = function() {

    };

    proto.leaveViewMode = function() {

    };

    proto.getMousePosition = function() {

        return {x: this.mousePosition.x, y: this.mousePosition.y};
    };

    proto.onWheel = function(event) {

        event.preventDefault();
    };

    proto.onMouseMove = function(event) {

        processMouseEvent(this, event);
        this.editor.onMouseMove(event);
        event.preventDefault();
    };

    proto.onMouseDown = function(event) {

        processMouseEvent(this, event);

        this.isMouseDown = true;
        this.editor.onMouseDown(event);
        event.preventDefault();
    };

    proto.onMouseUp = function(event) {

        processMouseEvent(this, event);

        this.isMouseDown = false;
        this.editor.onMouseUp(event);
        event.preventDefault();
    };

    proto.onMouseDoubleClick = function(event) {

        processMouseEvent(this, event);
        this.editor.onMouseDoubleClick(event);
        event.preventDefault();
    };

    proto.onTouchDrag = function(event) {

        convertEventHammerToMouse(event);
        switch (event.type) {
          case 'dragstart':
              this.onMouseDown(event);
              break;
            case 'dragmove':
                this.onMouseMove(event);
                break;
           case 'dragend':
              this.onMouseUp(event);
              break;
        }
        event.preventDefault();
    };

    proto.onSingleTap = function(event) {

        convertEventHammerToMouse(event);

        this.onMouseDown(event);
        this.onMouseUp(event);
        event.preventDefault();
    };

    proto.onDoubleTap = function(event) {

        convertEventHammerToMouse(event);
        this.onMouseDoubleClick(event);
        event.preventDefault();
    };

    function processMouseEvent(input, event) {

        var rect = input.editor.svg.getBoundingClientRect();

        input.makeSameXY = event.shiftKey;
        input.snapRotations = event.shiftKey;
        input.keepAspectRatio = event.shiftKey;
        input.constrainAxis = event.shiftKey;

        input.mousePosition.x = event.clientX - rect.left;
        input.mousePosition.y = event.clientY - rect.top;
    }

    function convertEventHammerToMouse(event) {

        // Convert Hammer touch-event X,Y into mouse-event X,Y.
        event.shiftKey = false;
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
    }

    namespace.InputHandler = InputHandler;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;

    /**
     * Base class for all markup edit modes.
     *
     * An EditMode is responsible for handling user input to create and edit a
     * [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.
     *
     * Any class extending Markup should contain at least the following methods:
     * - deleteMarkup()
     * - onMouseDown()
     * - onMouseMove()
     *
     * A good reference is the Circle EditMode implementation available in
     * [EditModeCircle.js]{@link Autodesk.Viewing.Extensions.Markups.Core.EditModeCircle}.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     *
     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor - Markups extension.
     * @param {String} type - An identifier for the EditMode type. Not to be confused by the Markup's id.
     * @param {Array} styleAttributes - Attributes for customization.
     * @constructor
     * @category Extensions
     */
    function EditMode(editor, type, styleAttributes) {

        this.editor = editor;
        this.viewer = editor.viewer;
        this.type = type;
        this.selectedMarkup = null;
        this.dragging = false;
        this.draggingAnnotationIniPosition = null;
        this.draggingMouseIniPosition = new THREE.Vector2();
        this.initialX = 0;
        this.initialY = 0;
        this.minSize = 9; // In pixels
        this.creating = false;
        this.size = {x: 0, y: 0};
        this.style = namespaceUtils.createStyle(styleAttributes, this.editor);
        this.style = namespaceUtils.copyStyle(editor.getDefaultStyle(), this.style);

        this.CREATION_METHOD_DRAG = 'CREATION_METHOD_DRAG';
        this.CREATION_METHOD_CLICK = 'CREATION_METHOD_CLICK';
        this.CREATION_METHOD_CLICKS = 'CREATION_METHOD_CLICKS';
        this.creationMethod = this.CREATION_METHOD_DRAG;

        namespaceUtils.addTraitEventDispatcher(this);
    }

    // Event types //
    namespace.EVENT_EDITMODE_CREATION_BEGIN = "EVENT_EDITMODE_CREATION_BEGIN";
    namespace.EVENT_EDITMODE_CREATION_END = "EVENT_EDITMODE_CREATION_END";
    namespace.EVENT_MARKUP_DESELECT = "EVENT_MARKUP_DESELECT";

    var proto = EditMode.prototype;

    proto.destroy = function() {

        this.unselect();
        namespaceUtils.removeTraitEventDispatcher(this);
    };

    proto.unselect = function() {

        var fireEv = false;
        var selectedMarkup = this.selectedMarkup;
        if (selectedMarkup) {
            selectedMarkup.unselect();
            this.selectedMarkup = null;
            fireEv = true;
        }

        this.editor.editFrame.setMarkup(null);

        if (fireEv) {
            this.fireEvent({ type: namespace.EVENT_MARKUP_DESELECT });
        }
    };

    proto.creationBegin = function() {

        if (this.creating) {
            return;
        }

        this.creating = true;
        this.fireEvent({ type: namespace.EVENT_EDITMODE_CREATION_BEGIN });
    };

    proto.creationEnd = function() {

        if(!this.creating) {
            return;
        }

        if (this.creationMethod !== this.CREATION_METHOD_CLICK) {

            if (this.selectedMarkup && !this.isMinSizeValid()) {

                this.creationCancel();
            } else {

                if (this.creationMethod === this.CREATION_METHOD_DRAG) {
                    this.finishDragging();
                }

                if (this.selectedMarkup) {

                    // Opened on mouse down.
                    this.editor.closeActionGroup();
                    this.unselect();
                }
            }
        }

        this.creating = false;
        this.fireEvent({ type: namespace.EVENT_EDITMODE_CREATION_END });
    };

    proto.creationCancel = function() {

        this.editor.cancelActionGroup();
        this.creationEnd();
        this.selectedMarkup = null; // No need to call unselect
    };

    /**
     *
     * @param style
     */
    proto.setStyle = function(style) {

        this.style = style;

        var selectedMarkup = this.selectedMarkup;
        if(!selectedMarkup) {
            return;
        }

        var setStyle = new namespace.SetStyle(this.editor, selectedMarkup, style);
        setStyle.execute();
    };

    proto.getStyle = function() {

        return this.style;
    };

    proto.setSelection = function(markup) {

        if (this.selectedMarkup !== markup) {
            this.unselect();
            markup && markup.select();
        }

        this.selectedMarkup = markup;

        var editor = this.editor;
        markup && editor.bringToFront(markup);

        if(!this.creating) {
            editor.editFrame.setMarkup(markup);
        }
    };

    proto.getSelection = function() {

        return this.selectedMarkup;
    };

    /**
     *
     * @param [markup] If provided deletes markup (has to have same type that the edit mode), otherwise deletes selected one.
     * @param [cantUndo] If true to not add deletion to undo history.
     * @returns {boolean}
     */
    proto.deleteMarkup = function (markup, cantUndo) {

        return false;
    };

    /**
     * Used by classes extending EditMode to validate the minimum size (in screen coordinates) of the markup.
     * See minSize attribute
     * @return {Boolean} Whether current size is valid for creating the markup
     * @private
     */
    proto.isMinSizeValid = function() {

        if (this.minSize !== 0) {

            var tmp = this.editor.sizeFromMarkupsToClient(this.size.x, this.size.y);
            return (tmp.x*tmp.x + tmp.y*tmp.y) >= (this.minSize * this.minSize);

        }
        return true;
    };

    /**
     * @private
     */
    proto.startDragging = function() {

        var selectedMarkup = this.selectedMarkup;
        var mousePosition = this.editor.getMousePosition();

        if (selectedMarkup) {

            this.dragging = true;
            this.draggingAnnotationIniPosition = selectedMarkup.getClientPosition();
            this.draggingMouseIniPosition.set(mousePosition.x, mousePosition.y);
        }
    };

    /**
     * @private
     */
    proto.finishDragging = function() {

        var dragging = this.dragging;
        var selectedMarkup = this.selectedMarkup;

        this.dragging = false;

        if (selectedMarkup && dragging) {

            selectedMarkup.finishDragging();
        }
    };

    /**
     *
     * @returns {{x: number, y: number}}
     */
    proto.getFinalMouseDraggingPosition = function() {

        var editor = this.editor;
        var bounds = editor.getBounds();
        var mousePosition = editor.getMousePosition();

        var initialX = this.initialX;
        var initialY = this.initialY;

        var finalX = Math.min(Math.max(bounds.x, mousePosition.x), bounds.x + bounds.width);
        var finalY = Math.min(Math.max(bounds.y, mousePosition.y), bounds.y + bounds.height);

        if (finalX == initialX &&
            finalY == initialY) {
            finalX++;
            finalY++;
        }

        // Make equal x/y when shift is down
        if (editor.input.makeSameXY) {
            var dx = Math.abs(finalX - initialX);
            var dy = Math.abs(finalY - initialY);

            var maxDelta = Math.max(dx, dy);

            // These calculations have the opportunity to go beyond 'bounds'.
            finalX = initialX + maxDelta * namespaceUtils.sign(finalX - initialX);
            finalY = initialY + maxDelta * namespaceUtils.sign(finalY - initialY);
        }

        return { x:finalX, y:finalY };
    };

    proto.notifyAllowNavigation = function(allows) {

    };

    proto.onMouseMove = function (event) {

    };

    proto.onMouseDown = function () {

    };

    /**
     * Handler to mouse up events, used to start annotations creation.
     * It will cancel the creation of a markup if its minSize conditions are not met.
     *
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseUp = function(event) {

        if (this.creationMethod !== this.CREATION_METHOD_DRAG) {
            return;
        }

        this.creationEnd();
    };

    proto.onMouseDoubleClick = function(event) {

        if (this.creationMethod !== this.CREATION_METHOD_CLICKS) {
            return;
        }

        this.creationEnd();
    };

    /**
     * Notify the markup that the displayed markups are being saved so edit mode can finish current editions.
     */
    proto.onSave = function() {

        if (this.creating) {
            this.creationCancel();
        }
    };

    /**
     *
     * @returns {{x: *, y: *}}
     */
    proto.getDraggingPosition = function () {

        var mousePosition = this.editor.getMousePosition();

        var dx = mousePosition.x - this.draggingMouseIniPosition.x;
        var dy = mousePosition.y - this.draggingMouseIniPosition.y;

        return {
            x: this.draggingAnnotationIniPosition.x + dx,
            y: this.draggingAnnotationIniPosition.y + dy
        };
    };

    /**
     *
     * @param x
     * @param y
     * @param bounds
     * @returns {boolean}
     * @orivate
     */
    proto.isInsideBounds = function (x, y, bounds) {

        return x >= bounds.x && x <= bounds.x + bounds.width &&
               y >= bounds.y && y <= bounds.y + bounds.height;
    };

    namespace.EditMode = EditMode;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModeArrow(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_ARROW, styleAttributes);
    }

    EditModeArrow.prototype = Object.create(namespace.EditMode.prototype);
    EditModeArrow.prototype.constructor = EditModeArrow;


    var proto = EditModeArrow.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deleteArrow = new namespace.DeleteArrow(this.editor, markup);
            deleteArrow.addToHistory = !cantUndo;
            deleteArrow.execute();
            return true;
        }
        return false;
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function() {

        namespace.EditMode.prototype.onMouseDown.call(this);

        if (this.selectedMarkup) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        this.initialX = mousePosition.x;
        this.initialY = mousePosition.y;

        this.size.x = 0;
        this.size.y = 0;

        // Snap to parallel/perpendicular of underlying vectors
        this.lineSnapped = null;
        if (editor.snapper) {
            var geomType = editor.snapper.getHighlightGeometry();
            if (geomType === SNAP_VERTEX || geomType === SNAP_EDGE) {
                this.lineSnapped = editor.snapper.getEdge();
            }
        }

        // Calculate head and tail.
        var arrowMinSize = this.style['stroke-width'] * 3.5;
        var arrowMinSizeClient = editor.sizeFromMarkupsToClient(arrowMinSize,0).x;

        var head = {x: this.initialX, y: this.initialY};
        var tail = {
            x: Math.round(head.x + Math.cos( Math.PI * 0.25) * arrowMinSizeClient),
            y: Math.round(head.y + Math.sin(-Math.PI * 0.25) * arrowMinSizeClient)
        };
        // Constrain head and tail inside working area.
        var constrain = function(head, tail, size, bounds) {

            if (this.isInsideBounds(tail.x, tail.y, bounds)) {
                return;
            }

            tail.y = Math.round(head.y + Math.sin( Math.PI * 0.25) * size);
            if (this.isInsideBounds( tail.x, tail.y, bounds)) {
                return;
            }

            tail.x = Math.round(head.x + Math.cos(-Math.PI * 0.25) * size);
            if (this.isInsideBounds( tail.x, tail.y, bounds)) {
                return;
            }

            tail.y = Math.round(head.y + Math.sin(-Math.PI * 0.25) * size);

        }.bind(this);

        constrain( head, tail, arrowMinSizeClient, editor.getBounds());

        // Create arrow.
        editor.beginActionGroup();

        head = editor.positionFromClientToMarkups(head.x, head.y);
        tail = editor.positionFromClientToMarkups(tail.x, tail.y);

        var arrowVector = new THREE.Vector2(tail.x - head.x, tail.y - head.y);
        if (arrowVector.lengthSq() < arrowMinSize * arrowMinSize) {

            arrowVector = arrowVector.normalize().multiplyScalar(arrowMinSize);
            tail.x = head.x + arrowVector.x;
            tail.y = head.y + arrowVector.y;
        }

        var arrowId = editor.getId();
        var create = new namespace.CreateArrow(editor, arrowId, head, tail, this.style);
        create.execute();

        this.selectedMarkup = editor.getMarkup(arrowId);
        this.creationBegin();
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call( this, event );

        var selectedMarkup = this.selectedMarkup;
        if(!selectedMarkup || !this.creating) {
            return;
        }

        var editor = this.editor;
        var final = this.getFinalMouseDraggingPosition();
        var initialX = this.initialX;
        var initialY = this.initialY;

        // Snap to parallel/perpendicular of underlying vectors
        if (editor.snapper && !editor.snapper.isSnapped() && this.lineSnapped) {
            var start = editor.project(this.lineSnapped.vertices[0]);
            var end = editor.project(this.lineSnapped.vertices[1]);
            var p = new THREE.Vector3(final.x, final.y, start.z);

            var parallel = editor.snapper.nearestPointInPointToLine(p, start, end);

            // select an arbitrary point on the perpendicular line
            var k = -(start.x - end.x) / (start.y - end.y);
            var b = initialY - k * initialX;
            var x = initialX + 1;
            var y = k * x + b;
            var pEnd = new THREE.Vector3(x, y, start.z);

            var pStart = new THREE.Vector3(initialX, initialY, start.z);
            var perpendicular = editor.snapper.nearestPointInPointToLine(p, pStart, pEnd);

            // Snap to parallel of underlying vectors
            if (parallel.distanceTo(p) <= 20) {
                final.x = parallel.x;
                final.y = parallel.y;
            }
            // Snap to perpendicular of underlying vectors
            else if (perpendicular.distanceTo(p) <= 20) {
                final.x = perpendicular.x;
                final.y = perpendicular.y;
            }
        }

        var head = editor.positionFromClientToMarkups(initialX, initialY);
        var tail = editor.positionFromClientToMarkups(final.x, final.y);

        var arrowVector = new THREE.Vector2(tail.x - head.x, tail.y - head.y);
        var arrowMinSize = selectedMarkup.style['stroke-width'] * 3.5;

        if (arrowVector.lengthSq() < arrowMinSize * arrowMinSize) {

            arrowVector = arrowVector.normalize().multiplyScalar(arrowMinSize);
            tail.x = head.x + arrowVector.x;
            tail.y = head.y + arrowVector.y;
        }

        this.size = editor.sizeFromClientToMarkups((final.x - initialX), (final.y - initialY));

        var setArrow = new namespace.SetArrow(editor, selectedMarkup, head, tail);
        setArrow.execute();
    };

    namespace.EditModeArrow = EditModeArrow;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     * Markup circle edit mode.
     *
     * Implements a Circle [EditMode]{@link Autodesk.Viewing.Extensions.Markups.Core.EditMode}.
     * Included in documentation as an example of how to create
     * an EditMode for a specific markup type. Developers are encourage to look into this class's source code and copy
     * as much code as they need. Find link to source code below.
     *
     * @tutorial feature_markup
     * @constructor
     * @memberof Autodesk.Viewing.Extensions.Markups.Core
     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditMode
     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor
     * @category Extensions
     */
    function EditModeCircle(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_CIRCLE, styleAttributes);
    }

    EditModeCircle.prototype = Object.create(namespace.EditMode.prototype);
    EditModeCircle.prototype.constructor = EditModeCircle;

    var proto = EditModeCircle.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deleteCircle = new namespace.DeleteCircle(this.editor, markup);
            deleteCircle.addToHistory = !cantUndo;
            deleteCircle.execute();
            return true;
        }
        return false;
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call( this, event );

        var selectedMarkup = this.selectedMarkup;
        if(!selectedMarkup || !this.creating) {
            return;
        }

        var editor = this.editor;
        var initialX = this.initialX;
        var initialY = this.initialY;
        var final = this.getFinalMouseDraggingPosition();

        var sizeX = Math.abs(initialX - final.x);
        var sizeY = Math.abs(initialY - final.y);

        var position = editor.clientToMarkups((initialX + final.x) * 0.5, (initialY + final.y) * 0.5);
        var size = this.size = editor.sizeFromClientToMarkups(sizeX, sizeY);

        var setCircle = new namespace.SetCircle(
            editor,
            selectedMarkup,
            position,
            size);

        setCircle.execute();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function() {

        namespace.EditMode.prototype.onMouseDown.call(this);

        if (this.selectedMarkup) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        this.initialX = mousePosition.x;
        this.initialY = mousePosition.y;

        // Calculate center and size.
        var position = editor.clientToMarkups(this.initialX, this.initialY);
        var size = this.size = editor.sizeFromClientToMarkups(1, 1);

        // Create circle.
        editor.beginActionGroup();

        var markupId = editor.getId();
        var create = new namespace.CreateCircle(
            editor,
            markupId,
            position,
            size,
            0,
            this.style);
        create.execute();

        this.selectedMarkup = editor.getMarkup(markupId);
        this.creationBegin();
    };

    namespace.EditModeCircle = EditModeCircle;

})();

(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModeCloud(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_CLOUD, styleAttributes);
    }

    EditModeCloud.prototype = Object.create(namespace.EditMode.prototype);
    EditModeCloud.prototype.constructor = EditModeCloud;

    var proto = EditModeCloud.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deleteCloud = new namespace.DeleteCloud(this.editor, markup);
            deleteCloud.addToHistory = !cantUndo;
            deleteCloud.execute();
            return true;
        }
        return false;
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call( this, event );

        var selectedMarkup = this.selectedMarkup;
        if(!selectedMarkup || !this.creating) {
            return;
        }

        var editor = this.editor;
        var initialX = this.initialX;
        var initialY = this.initialY;

        var final = this.getFinalMouseDraggingPosition();
        var position = editor.clientToMarkups((initialX + final.x)/2, (initialY + final.y)/2);
        var size = this.size = editor.sizeFromClientToMarkups((final.x - initialX), (final.y - initialY));

        var setCloud = new namespace.SetCloud(
            editor,
            selectedMarkup,
            position,
            size);

        setCloud.execute();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function() {

        namespace.EditMode.prototype.onMouseDown.call(this);

        if (this.selectedMarkup) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        this.initialX = mousePosition.x;
        this.initialY = mousePosition.y;

        // Calculate center and size.
        var position = editor.clientToMarkups(this.initialX, this.initialY);
        var size = this.size = editor.sizeFromClientToMarkups(1, 1);

        // Create Cloud.
        editor.beginActionGroup();

        var markupId = editor.getId();
        var create = new namespace.CreateCloud(
            editor,
            markupId,
            position,
            size,
            0,
            this.style);

        create.execute();

        this.selectedMarkup = editor.getMarkup(markupId);
        this.creationBegin();
    };

    namespace.EditModeCloud = EditModeCloud;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModeFreehand(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_FREEHAND, styleAttributes);
        this.style['stroke-opacity'] = 0.75;
    }

    EditModeFreehand.prototype = Object.create(namespace.EditMode.prototype);
    EditModeFreehand.prototype.constructor = EditModeFreehand;

    var proto = EditModeFreehand.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deleteFreehand = new namespace.DeleteFreehand(this.editor, markup);
            deleteFreehand.addToHistory = !cantUndo;
            deleteFreehand.execute();
            return true;
        }
        return false;
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call( this, event );

        var selectedMarkup = this.selectedMarkup;
        if(!selectedMarkup || !this.creating) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();
        var movements = this.movements;

        var location = editor.clientToMarkups(mousePosition.x, mousePosition.y);
        movements.push(location);

        // determine the position of the top-left and bottom-right points
        var minFn = function(collection, key){
            var targets = collection.map(function(item){
                return item[key];
            });
            return Math.min.apply(null, targets);
        };

        var maxFn = function(collection, key){
            var targets = collection.map(function(item){
                return item[key];
            });
            return Math.max.apply(null, targets);
        };
        
        var l = minFn(movements, 'x');
        var t = minFn(movements, 'y');
        var r = maxFn(movements, 'x');
        var b = maxFn(movements, 'y');

        var width = r - l;  // Already in markup coords space
        var height = b - t; // Already in markup coords space

        var position = {
            x: l + width * 0.5,
            y: t + height * 0.5
        };
        var size = this.size = {x: width, y: height};

        // Adjust points to relate from the shape's center
        var locations = movements.map(function(point){
            return {
                x: point.x - position.x,
                y: point.y - position.y
            };
        });

        var setFreehand = new namespace.SetFreehand(
            editor,
            selectedMarkup,
            position,
            size,
            locations);

        setFreehand.execute();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function() {

        namespace.EditMode.prototype.onMouseDown.call(this);

        if (this.selectedMarkup) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        this.initialX = mousePosition.x;
        this.initialY = mousePosition.y;

        //set the starting point
        var position = editor.clientToMarkups(this.initialX, this.initialY);
        this.movements = [position];

        var size = this.size = editor.sizeFromClientToMarkups(1, 1);

        // Create arrow.
        editor.beginActionGroup();

        var markupId = editor.getId();
        var create = new namespace.CreateFreehand(
            editor,
            markupId,
            position,
            size,
            0,
            [{x: 0, y: 0 }],
            this.style);

        create.execute();

        this.selectedMarkup = editor.getMarkup(markupId);
        this.creationBegin();
    };

    namespace.EditModeFreehand = EditModeFreehand;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;
    var SNAP_RANGE = 25;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModePolycloud(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color','stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_POLYCLOUD, styleAttributes);

        this.creationMethod = this.CREATION_METHOD_CLICKS;
        this.movements = [];
    }

    EditModePolycloud.prototype = Object.create(namespace.EditMode.prototype);
    EditModePolycloud.prototype.constructor = EditModePolycloud;

    var proto = EditModePolycloud.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deletePolycloud = new namespace.DeletePolycloud(this.editor, markup);
            deletePolycloud.addToHistory = !cantUndo;
            deletePolycloud.execute();
            return true;
        }
        return false;
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call(this, event);

        var editor = this.editor;
        var selectedMarkup = this.selectedMarkup;

        if(!selectedMarkup || !this.creating) {
            return;
        }

        this.dragging = true;

        var movements = this.movements;
        movements.splice(movements.length-1, 1);

        var mousePosition = editor.getMousePosition();
        mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);

        // Close polycloud if user clicks close to initial point.
        if (movements.length >= 2 &&
            namespaceUtils.areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {
            mousePosition = movements[0]; // Snap!
        }

        movements.push(mousePosition);

        var locations = setPositionAndSize(movements, this);
        var setPolycloud = new namespace.SetPolycloud(
            editor,
            selectedMarkup,
            this.position,
            this.size,
            locations);

        setPolycloud.execute();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function() {

        namespace.EditMode.prototype.onMouseDown.call(this);

        // User selected an already created markup.
        if (this.selectedMarkup && !this.creating) {
            return;
        }

        if (this.creating) {
            return;
        }

        // Creation process.
        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);

        var size = this.size = editor.sizeFromClientToMarkups(1, 1);
        this.movements = [mousePosition, mousePosition];

        editor.beginActionGroup();

        var markupId = editor.getId();
        var create = new namespace.CreatePolycloud(
            editor,
            markupId,
            mousePosition,
            size,
            0,
            [{x: 0, y: 0 }],
            this.style);

        create.execute();

        this.selectedMarkup = editor.getMarkup(markupId);
        this.creationBegin();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseUp = function(event) {

        namespace.EditMode.prototype.onMouseUp.call(this);

        if(!this.creating) {
            return;
        }

        this.dragging = false;

        // Creation process.
        var editor = this.editor;
        var mousePosition = editor.getMousePosition();
        var movements = this.movements;
        var closed = false;

        mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);

        if (movements.length > 1 &&
            namespaceUtils.areMarkupsPointsInClientRange(movements[movements.length-2], mousePosition, SNAP_RANGE, this.editor)) {
            return;
        }

        // Close polycloud if user clicks close to initial point.
        if (movements.length > 2 &&
            namespaceUtils.areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {
            mousePosition = movements[0]; // Snap!
            closed = true;
        }

        movements.splice(movements.length-1, 1);

        if (!closed) {
            movements.push(mousePosition);
            movements.push(mousePosition);
        }

        var polycloud = this.selectedMarkup;
        var locations = setPositionAndSize(movements, polycloud);
        var setPolycloud = new namespace.SetPolycloud(
            editor,
            polycloud,
            polycloud.position,
            polycloud.size,
            locations,
            closed);

        setPolycloud.execute();

        if (closed) {
            this.creationEnd();
        }
    };

    proto.onMouseDoubleClick = function(event) {

        if(!this.creating) {
            return;
        }

        var movements = this.movements;
        movements.splice(Math.max(0, movements.length-1));

        if (movements.length < 2 ) {

            this.creationCancel();
        } else {

            var polycloud = this.selectedMarkup;
            var locations = setPositionAndSize(movements, polycloud);
            var setPolycloud = new namespace.SetPolycloud(
                this.editor,
                polycloud,
                polycloud.position,
                polycloud.size,
                locations,
                true);

            setPolycloud.execute();
            this.creationEnd();
        }
    };

    proto.creationEnd = function() {

        // To pass isMinSizeValid,
        // probably that test should be done with the markup size (not the recorded by the edit mode).
        if (this.selectedMarkup) {
            this.size.x = this.selectedMarkup.size.x;
            this.size.y = this.selectedMarkup.size.y;
        }
        
        namespace.EditMode.prototype.creationEnd.call(this);

        this.closed = false;
        this.movements = [];
        this.dragging = false;
        this.creating = false;
    };

    proto.creationCancel = function() {

        namespace.EditMode.prototype.creationCancel.call(this);

        this.closed = false;
        this.movements = [];
        this.dragging = false;
        this.creating = false;
    };

    function setPositionAndSize(locations, markup) {

        // determine the position of the top-left and bottom-right points
        var minFn = function(collection, key){
            var targets = collection.map(function(item){
                return item[key];
            });
            return Math.min.apply(null, targets);
        };

        var maxFn = function(collection, key){
            var targets = collection.map(function(item){
                return item[key];
            });
            return Math.max.apply(null, targets);
        };

        var strokeWidth = markup.style['stroke-width'];
        var radius = strokeWidth * 2 + strokeWidth * 0.5;

        var l = minFn(locations, 'x') - radius;
        var t = minFn(locations, 'y') - radius;
        var r = maxFn(locations, 'x') + radius;
        var b = maxFn(locations, 'y') + radius;
        var w = r - l;
        var h = b - t;

        markup.size = {x: w, y: h};
        markup.position = {x: l + w * 0.5, y: t + h * 0.5};

        // Adjust points to relate from the shape's center
        var position = markup.position;
        return locations.map(function(point){
            return {
                x: point.x - position.x,
                y: point.y - position.y
            };
        });
    }

    namespace.EditModePolycloud = EditModePolycloud;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;
    var SNAP_RANGE = 25;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModePolyline(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color','stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_POLYLINE, styleAttributes);

        this.creationMethod = this.CREATION_METHOD_CLICKS;
        this.movements = [];
    }

    EditModePolyline.prototype = Object.create(namespace.EditMode.prototype);
    EditModePolyline.prototype.constructor = EditModePolyline;

    var proto = EditModePolyline.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deletePolyline = new namespace.DeletePolyline(this.editor, markup);
            deletePolyline.addToHistory = !cantUndo;
            deletePolyline.execute();
            return true;
        }
        return false;
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call(this, event);

        var editor = this.editor;
        var selectedMarkup = this.selectedMarkup;

        if(!selectedMarkup || !this.creating) {
            return;
        }

        this.dragging = true;

        var movements = this.movements;
        movements.splice(movements.length-1, 1);

        var mousePosition = editor.getMousePosition();
        mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);

        // Close polyline if user clicks close to initial point.
        if (movements.length >= 2 &&
            namespaceUtils.areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {
            mousePosition = movements[0]; // Snap!
        }

        movements.push(mousePosition);

        var locations = setPositionAndSize(movements, this);
        var setPolyline = new namespace.SetPolyline(
            editor,
            selectedMarkup,
            this.position,
            this.size,
            locations);

        setPolyline.execute();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function(event) {

        namespace.EditMode.prototype.onMouseDown.call(this);

        // User selected an already created markup.
        if (this.selectedMarkup && !this.creating) {
            return;
        }

        if (this.creating) {
            return;
        }

        // Creation process.
        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);

        var size = this.size = editor.sizeFromClientToMarkups(1, 1);
        this.movements = [mousePosition, mousePosition];

        editor.beginActionGroup();

        var markupId = editor.getId();
        var create = new namespace.CreatePolyline(
            editor,
            markupId,
            mousePosition,
            size,
            0,
            [{x:0, y:0}],
            this.style);

        create.execute();

        this.selectedMarkup = editor.getMarkup(markupId);
        this.creationBegin();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseUp = function() {

        namespace.EditMode.prototype.onMouseUp.call(this);

        if(!this.creating) {
            return;
        }

        this.dragging = false;

        // Creation process.
        var editor = this.editor;
        var mousePosition = editor.getMousePosition();
        var movements = this.movements;
        var closed = false;

        mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);

        if (movements.length > 1 &&
            namespaceUtils.areMarkupsPointsInClientRange(movements[movements.length-2], mousePosition, SNAP_RANGE, this.editor)) {
            return;
        }

        // Close polyline if user clicks close to initial point.
        if (movements.length > 2 &&
            namespaceUtils.areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {
            mousePosition = movements[0]; // Snap!
            closed = true;
        }

        movements.splice(movements.length-1, 1);

        if (!closed) {
            movements.push(mousePosition);
            movements.push(mousePosition);
        }

        var polyline = this.selectedMarkup;
        var locations = setPositionAndSize(movements, polyline);
        var setPolyline = new namespace.SetPolyline(
            editor,
            polyline,
            polyline.position,
            polyline.size,
            locations,
            closed);

        setPolyline.execute();

        if (closed) {
            this.creationEnd();
        }
    };

    proto.creationEnd = function() {

        // To pass isMinSizeValid,
        // probably that test should be done with the markup size (not the recorded by the edit mode).
        if (this.selectedMarkup) {
            this.size.x = this.selectedMarkup.size.x;
            this.size.y = this.selectedMarkup.size.y;
        }

        namespace.EditMode.prototype.creationEnd.call(this);

        this.closed = false;
        this.movements = [];
        this.dragging = false;
        this.creating = false;
    };

    proto.creationCancel = function() {

        namespace.EditMode.prototype.creationCancel.call(this);

        this.closed = false;
        this.movements = [];
        this.dragging = false;
        this.creating = false;
    };


    proto.onMouseDoubleClick = function(event) {

        if(!this.creating) {
           return;
        }

        var movements = this.movements;
        movements.splice(Math.max(0, movements.length-1));

        if (movements.length < 2 ) {

            this.creationCancel();
        } else {

            var polyline = this.selectedMarkup;
            var locations = setPositionAndSize(movements, polyline);
            var setPolyline = new namespace.SetPolyline(
                this.editor,
                polyline,
                polyline.position,
                polyline.size,
                locations,
                this.closed);

            setPolyline.execute();
            this.creationEnd();
        }
    };

    function setPositionAndSize(locations, markup) {

        // determine the position of the top-left and bottom-right points
        var minFn = function(collection, key){
            var targets = collection.map(function(item){
                return item[key];
            });
            return Math.min.apply(null, targets);
        };

        var maxFn = function(collection, key){
            var targets = collection.map(function(item){
                return item[key];
            });
            return Math.max.apply(null, targets);
        };

        var l = minFn(locations, 'x');
        var t = minFn(locations, 'y');
        var r = maxFn(locations, 'x');
        var b = maxFn(locations, 'y');
        var w = r - l;
        var h = b - t;

        markup.size = {x: w, y: h};
        markup.position = {x: l + w * 0.5, y: t + h * 0.5};

        // Adjust points to relate from the shape's center
        var position = markup.position;
        return locations.map(function(point){
            return {
                x: point.x - position.x,
                y: point.y - position.y
            };
        });
    }

    namespace.EditModePolyline = EditModePolyline;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModeRectangle(editor) {

        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_RECTANGLE, styleAttributes);
    }

    EditModeRectangle.prototype = Object.create(namespace.EditMode.prototype);
    EditModeRectangle.prototype.constructor = EditModeRectangle;

    var proto = EditModeRectangle.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deleteRectangle = new namespace.DeleteRectangle(this.editor, markup);
            deleteRectangle.addToHistory = !cantUndo;
            deleteRectangle.execute();
            return true;
        }
        return false;
    };

    /**
     * Sets multiple text properties at once
     * @param {Object} style
     */
    proto.setStyle = function (style) {

        namespace.EditMode.prototype.setStyle.call(this, style);

        var rectangle = this.selectedMarkup;
        if(!rectangle) {
            return;
        }

        // TODO: Change to use SetStyle //
        var setRectangle = new namespace.SetRectangle(
            this.editor,
            rectangle,
            rectangle.position,
            rectangle.size);

        setRectangle.execute();
    };

    /**
     * Handler to mouse move events, used to create markups.
     * @param {MouseEvent} event Mouse event.
     * @private
     */
    proto.onMouseMove = function(event) {

        namespace.EditMode.prototype.onMouseMove.call( this, event );

        var selectedMarkup = this.selectedMarkup;
        if(!selectedMarkup || !this.creating) {
            return;
        }

        var editor = this.editor;
        var initialX = this.initialX;
        var initialY = this.initialY;

        var final = this.getFinalMouseDraggingPosition();
        var position = editor.clientToMarkups((initialX + final.x)/2, (initialY + final.y)/2);

        var width, height;
        // Snap to parallel/perpendicular of underlying vectors
        if (editor.snapper && this.lineSnapped) {
            var start = editor.project(this.lineSnapped.vertices[0]);
            var end = editor.project(this.lineSnapped.vertices[1]);
            var p = new THREE.Vector3(final.x, final.y, start.z);

            var parallel = editor.snapper.nearestPointInPointToLine(p, start, end);
            height = p.distanceTo(parallel);

            // select an arbitrary point on the perpendicular line
            var k = -(start.x - end.x) / (start.y - end.y);
            var b = initialY - k * initialX;
            var x = initialX + 1;
            var y = k * x + b;
            var pEnd = new THREE.Vector3(x, y, start.z);

            var pStart = new THREE.Vector3(initialX, initialY, start.z);
            var perpendicular = editor.snapper.nearestPointInPointToLine(p, pStart, pEnd);
            width = p.distanceTo(perpendicular);
        }
        else {
            width = final.x - initialX;
            height = final.y - initialY;
        }

        var size = this.size = editor.sizeFromClientToMarkups(width, height);

        var setRectangle = new namespace.SetRectangle(
            editor,
            selectedMarkup,
            position,
            size);

        setRectangle.execute();
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     * @private
     */
    proto.onMouseDown = function() {

        namespace.EditMode.prototype.onMouseDown.call(this);

        if (this.selectedMarkup) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();

        this.initialX = mousePosition.x;
        this.initialY = mousePosition.y;

        // Calculate center and size.
        var position = editor.clientToMarkups(this.initialX, this.initialY);
        var size = this.size = editor.sizeFromClientToMarkups(1, 1);

        // Calculate rotation
        var rotation = 0;
        this.lineSnapped = null;
        if (editor.snapper) {
            // Snap to parallel/perpendicular of underlying vectors
            var geomType = editor.snapper.getHighlightGeometry();
            if (geomType === SNAP_VERTEX || geomType === SNAP_EDGE) {
                this.lineSnapped = editor.snapper.getEdge();
                var start = editor.project(this.lineSnapped.vertices[0]);
                var end = editor.project(this.lineSnapped.vertices[1]);
                var k = (end.y - start.y) / (end.x - start.x);
                rotation = this.rotation = Math.atan(k);
            }
        }

        // Create rectangle.
        editor.beginActionGroup();

        var markupId = editor.getId();
        var create = new namespace.CreateRectangle(
            editor,
            markupId,
            position,
            size,
            rotation,
            this.style);

        create.execute();

        this.selectedMarkup = editor.getMarkup(markupId);
        this.creationBegin();
    };

    namespace.EditModeRectangle = EditModeRectangle;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;

    /**
     *
     * @param editor
     * @constructor
     */
    function EditModeText(editor) {

        var styleAttributes = [
            'font-size',
            'stroke-color',
            'stroke-opacity',
            'fill-color',
            'fill-opacity',
            'font-family',
            'font-style',
            'font-weight'
        ];
        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_TEXT, styleAttributes);

        var helper = new namespace.EditorTextInput(this.viewer.container, this.editor);
        helper.addEventListener(helper.EVENT_TEXT_CHANGE, this.onHelperTextChange.bind(this), false);
        this.textInputHelper = helper;
        this.onHistoryChangeBinded = this.onHistoryChange.bind(this);
        this.minSize = 0; // No need to size it initially
        this.creationMethod = this.CREATION_METHOD_CLICK;
    }

    EditModeText.prototype = Object.create(namespace.EditMode.prototype);
    EditModeText.prototype.constructor = EditModeText;

    var proto = EditModeText.prototype;

    proto.deleteMarkup = function(markup, cantUndo) {

        markup = markup || this.selectedMarkup;
        if (markup && markup.type == this.type) {
            var deleteText = new namespace.DeleteText(this.editor, markup);
            deleteText.addToHistory = !cantUndo;
            deleteText.execute();
            return true;
        }
        return false;
    };

    /**
     *
     * @param style
     */
    proto.setStyle = function(style) {

        if (this.textInputHelper.isActive()) {

            this.textInputHelper.setStyle(style);
        } else {
            namespace.EditMode.prototype.setStyle.call(this, style);
        }
    };

    proto.notifyAllowNavigation = function(allows) {

        if (allows && this.textInputHelper.isActive()) {
            this.textInputHelper.acceptAndExit();
        }
    };

    proto.destroy = function() {

        if (this.textInputHelper) {
            if (this.textInputHelper.isActive()) {
                this.textInputHelper.acceptAndExit();
            }
            this.textInputHelper.destroy();
            this.textInputHelper = null;
        }
        namespace.EditMode.prototype.destroy.call(this);
    };

    /**
     * Handler to mouse down events, used to start markups creation.
     */
    proto.onMouseDown = function() {

        if (this.textInputHelper.isActive()) {
            this.textInputHelper.acceptAndExit();
            return;
        }

        if (this.selectedMarkup) {
            return;
        }

        var editor = this.editor;
        var mousePosition = editor.getMousePosition();
        var clientFontSize = editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;
        var initialWidth = clientFontSize * 15; // Find better way to initialize size.
        var initialHeight = clientFontSize * 3;

        // Center position.
        var size = this.size = editor.sizeFromClientToMarkups(initialWidth, initialHeight);
        var position = editor.positionFromClientToMarkups(
            mousePosition.x + (initialWidth * 0.5),
            mousePosition.y + (initialHeight * 0.5));

        this.creationBegin();
        editor.beginActionGroup();

        // Given the initial width and font size, we assume that the text fits in one line.
        var createText = new namespace.CreateText(
            editor,
            editor.getId(),
            position,
            size,
            '',
            this.style);

        createText.execute();
        this.creationEnd();

        this.selectedMarkup = editor.getMarkup(createText.targetId);
        this.textInputHelper.setActive(this.selectedMarkup, true);
        this.editor.actionManager.addEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);
    };

    proto.onMouseUp = function(event) {

    };

    proto.onMouseDoubleClick = function(markup) {

        if (markup === this.selectedMarkup) {
            this.editor.selectMarkup(null);
            this.textInputHelper.setActive(markup, false);
        }
    };

    proto.onHelperTextChange = function(event) {

        var dataBag = event.data;
        var textMarkup = dataBag.markup;
        var textStyle = dataBag.style;

        this.editor.actionManager.removeEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);

        // Deal with edge case first: Creating a Label without text
        if (dataBag.newText === '') {

            // If the text field is being created for the first time,
            // we need only to cancel the action group in progress
            if (dataBag.firstEdit) {
                this.editor.cancelActionGroup();
                this.editor.selectMarkup(null);
                return;
            }
            // Else, we must perform a Delete action
            else
            {
                var deleteText = new namespace.DeleteText(this.editor, textMarkup);
                deleteText.execute();
                this.editor.selectMarkup(null);
                return;
            }
        }

        // When the text is created for the first time, an action group
        // is already created and it includes the CreateText action.
        // Thus, no need to begin another action group.
        if (!dataBag.firstEdit) {
            this.editor.beginActionGroup();
        }

        // Size change action //
        var position = this.editor.positionFromClientToMarkups(dataBag.newPos.x, dataBag.newPos.y);
        var size = this.editor.sizeFromClientToMarkups(dataBag.width, dataBag.height);
        var setSize = new namespace.SetSize(
            this.editor,
            textMarkup,
            position,
            size.x,
            size.y);
        setSize.execute();

        // Text change action //
        var setText = new namespace.SetText(
            this.editor,
            textMarkup,
            textMarkup.position,
            textMarkup.size,
            dataBag.newText);
        setText.execute();

        var setStyle = new namespace.SetStyle(
            this.editor,
            textMarkup,
            textStyle
        );
        setStyle.execute();

        // However, we do need to close the action group at this point. For both cases.
        this.editor.closeActionGroup();
        this.editor.selectMarkup(null);
    };

    /**
     * We want to make sure that the Input Helper gets removed from the screen
     * whenever the user attempts to perform an undo or redo action.
     * @param {Event} event
     * @private
     */
    proto.onHistoryChange = function(event) {

        if (this.textInputHelper.isActive()) {
            this.editor.actionManager.removeEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);
            this.textInputHelper.setInactive();
        }
    };

    /**
     * Notify the markup that the displayed markups are being saved so edit mode can finish current editions.
     */
    proto.onSave = function() {

        namespace.EditMode.prototype.onSave.call(this);

        // Close input helper if it's open.
        if (this.textInputHelper.isActive()) {
            var firstEdit = this.textInputHelper.firstEdit;

            this.editor.actionManager.removeEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);
            this.textInputHelper.setInactive();

            // Close action group if open (first edit).s
            if (firstEdit) {
                this.editor.cancelActionGroup();
            }

            this.editor.selectMarkup(null);
            this.selectedMarkup = null;
        }
    };

    namespace.EditModeText = EditModeText;

})();
(function(){ 'use strict';

    var namespace = Autodesk.Viewing.Extensions.Markups.Core;
    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;
    var DEFAULT_TEXT = 'Write Something';

    /**
     * Auxiliary class that handles all input for the Label Markup (MarkupText.js)
     * It instantiates a TEXTAREA where the user can input text. When user input is
     * disabled, the textarea gets hidden and further rendering is delegated to
     * MarkupText.js
     *
     * @param {HTMLElement} parentDiv
     * @param {Object} editor - Core Extension
     * @constructor
     */
    function EditorTextInput(parentDiv, editor) {

        this.parentDiv = parentDiv;
        this.editor = editor;

        // Constants
        this.EVENT_TEXT_CHANGE = 'EVENT_CO2_TEXT_CHANGE';

        // The actual TextArea input
        this.textArea = document.createElement('textarea');
        this.textArea.setAttribute('maxlength', '260'); // TODO: Make constant? Change value?
        this.textArea.setAttribute('data-i18n', DEFAULT_TEXT);

        this.onKeyHandlerBinded = this.onKeyHandler.bind(this);
        this.textArea.addEventListener('keydown', this.onKeyHandlerBinded);

        this.styleTextArea = new namespaceUtils.DomElementStyle(); // TODO: Move this to EditMode.
        this.styleTextArea
            .setAttribute('position', 'absolute')
            .setAttribute('overflow-y', 'hidden');

        // Helper div to measure text width
        this.measureDiv = document.createElement('div');

        // Become an event dispatcher
        namespaceUtils.addTraitEventDispatcher(this);

        this.onResizeBinded = this.onWindowResize.bind(this);
    }

    var proto = EditorTextInput.prototype;

    proto.destroy = function() {

        this.textArea.removeEventListener('keydown', this.onKeyHandlerBinded);
        this.setInactive();
    };

    /**
     * Initializes itself given an Label Markup (textMarkup)
     * @param {Object} textMarkup
     * @param {Boolean} firstEdit - Whether the markup is being edited for the first time.
     */
    proto.setActive = function(textMarkup, firstEdit) {

        if (this.textMarkup === textMarkup) {
            return;
        }


        var placeholderText = Autodesk.Viewing.i18n.translate(DEFAULT_TEXT);
        this.textArea.setAttribute('placeholder', placeholderText);

        this.setInactive();
        this.parentDiv.appendChild(this.textArea);
        this.textMarkup = textMarkup;
        this.firstEdit = firstEdit || false;
        this.initFromMarkup();

        // Component breaks when resizing. Thus, we force close it
        window.addEventListener('resize', this.onResizeBinded);

        // Focus on next frame
        var txtArea = this.textArea;
        window.requestAnimationFrame(function(){
            txtArea.focus();
        });
    };

    /**
     * Closes the editor text input and goes back into normal markup edition mode.
     */
    proto.setInactive = function() {

        window.removeEventListener('resize', this.onResizeBinded);

        if (this.textMarkup) {
            this.textMarkup = null;
            this.parentDiv.removeChild(this.textArea);
        }
        this.style = null;
    };

    proto.isActive = function() {

        return !!this.textMarkup;
    };

    /**
     * Applies Markup styles to TextArea used for editing.
     * It also saves a copy of the style object.
     * @private
     */
    proto.initFromMarkup = function() {

        var markup = this.textMarkup;
        var position = markup.getClientPosition(),
            size = markup.getClientSize();

        var left = position.x - size.x * 0.5;
        var top = position.y - size.y * 0.5;

        var lineHeightPercentage = markup.lineHeight + "%";
        this.styleTextArea.setAttribute('line-height', lineHeightPercentage);

        this.setPosAndSize(left, top, size.x, size.y);
        this.setStyle(markup.getStyle());
        this.textArea.value = markup.getText();
    };

    proto.setPosAndSize = function(left, top, width, height) {

        // We also check here that it doesn't overflow out of the canvas
        if (left + width >= this.editor.viewer.container.clientWidth) {
            left = this.editor.viewer.container.clientWidth - (width + 10);
        }
        if (top + height >= this.editor.viewer.container.clientHeight) {
            top = this.editor.viewer.container.clientHeight - (height + 10);
        }

        this.styleTextArea
            // Size and position
            .setAttribute('left', left + 'px')
            .setAttribute('top', top + 'px')
            .setAttribute('width', width + 'px')
            .setAttribute('height', height + 'px');
    };

    proto.setStyle = function(style) {

        if (this.style) {
            // An already present style means that the user
            // has changed the style using the UI buttons.
            // We need to account for the user having changed the
            // width/height of the TextArea. Since there is no event
            // we can detect for it, we do it here.
            var temp = {};
            this.injectSizeValues(temp);
            this.setPosAndSize(
                temp.newPos.x - temp.width * 0.5,
                temp.newPos.y - temp.height * 0.5,
                temp.width, temp.height);
        }
        var fontHeight = this.editor.sizeFromMarkupsToClient(0, style['font-size']).y;
        var textAreaStyle = this.styleTextArea
            // Visuals
            .setAttribute('color', style['stroke-color'])
            .setAttribute('font-family', style['font-family'])
            .setAttribute('font-size', fontHeight + 'px')
            .setAttribute('font-weight', style['font-weight'])
            .setAttribute('font-style', style['font-style'])
            .getStyleString();
        this.textArea.setAttribute('style', textAreaStyle);
        this.style = namespaceUtils.cloneStyle(style);
    };

    /**
     * Helper function that, for a given markup with some text in it
     * returns an Array of lines in it.
     * @param {Object} markup
     * @returns {{text, lines}|{text: String, lines: Array.<String>}}
     */
    proto.getTextValuesForMarkup = function(markup) {

        var active = this.isActive();
        var activeMarkup = this.textMarkup;
        var activeFirstEdit = this.firstEdit;

        this.setActive(markup, false);
        var textValues = this.getTextValues();

        if (active) {
            this.setActive(activeMarkup, activeFirstEdit);
        } else {
            this.setInactive();
        }

        return textValues;
    };

    /**
     * Returns the current text as one string and an array of lines
     * of how the text is being rendered (1 string per line)
     * @returns {{text: String, lines: Array.<String>}}
     */
    proto.getTextValues = function() {

        var newText = this.textArea.value;
        if (newText === DEFAULT_TEXT) {
            newText = '';
        }
        return {
            text: newText,
            lines: this.generateLines()
        };
    };

    /**
     * Function called by UI
     */
    proto.acceptAndExit = function() {

        // If placeholder text, then remove.
        var textValues = this.getTextValues();

        var dataBag = {
            markup: this.textMarkup,
            style: this.style,
            firstEdit: this.firstEdit,
            newText: textValues.text,
            newLines: textValues.lines
        };
        this.injectSizeValues(dataBag);
        this.fireEvent({ type: this.EVENT_TEXT_CHANGE, data: dataBag });
        this.setInactive(); // Do this last //
    };

    /**
     * Injects position, width and height of the textarea rect
     * @param {Object} dataBag
     * @private
     */
    proto.injectSizeValues = function(dataBag) {

        // Explicit usage of parseFloat to remove the 'px' suffix.
        var width = parseFloat(this.textArea.style.width);
        var height = parseFloat(this.textArea.style.height);
        var ox = parseFloat(this.textArea.style.left);
        var oy = parseFloat(this.textArea.style.top);

        dataBag.width = width;
        dataBag.height = height;
        dataBag.newPos = {
            x: ox + (width * 0.5),
            y: oy + (height * 0.5)
        };
    };

    /**
     * Handler for when the window gets resized
     * @param {Object} event - Window resize event
     * @private
     */
    proto.onWindowResize = function(event) {
        window.requestAnimationFrame(function(){
            var str = this.textArea.value;
            this.style = null; // TODO: Revisit this code because style changes are lost by doing this.
            this.initFromMarkup();
            this.textArea.value = str;
        }.bind(this));
    };

    proto.onKeyHandler = function(event) {
        var keyCode = event.keyCode;
        var shiftDown = event.shiftKey;

        // We only allow RETURN when used along with SHIFT
        if (!shiftDown && keyCode === 13) { // Return
            event.preventDefault();
            this.acceptAndExit();
        }
    };

    /**
     * Grabs the text content of the textarea and returns
     * an Array of lines.  Wrapped lines are returned as 2 lines.
     */
    proto.generateLines = function() {

        // First, get lines separated by line breaks:
        var textContent = this.textArea.value;
        var linesBreaks = textContent.split(/\r*\n/);

        var styleMeasureStr = this.styleTextArea.clone()
            .removeAttribute(['top', 'left', 'width', 'height', 'overflow-y'])
            .setAttribute('position','absolute')
            .setAttribute('white-space','nowrap')
            .setAttribute('float','left')
            .setAttribute('visibility','hidden')
            .getStyleString();
        this.measureDiv.setAttribute('style', styleMeasureStr);
        this.parentDiv.appendChild(this.measureDiv);

        var maxLineLength = parseFloat(this.textArea.style.width);

        // Now check whether the lines are wrapped.
        // If so, subdivide into other lines.
        var linesOutput = [];

        for (var i= 0, len = linesBreaks.length; i<len; ++i) {
            var line = trimRight(linesBreaks[i]);
            this.splitLine(line, maxLineLength, linesOutput);
        }

        this.parentDiv.removeChild(this.measureDiv);
        return linesOutput;
    };

    /**
     * Given a String that represents one line of text that is
     * longer than the max length a line is allowed, this method
     * cuts text into several ones that are no longer than the max
     * length.
     *
     * @param {String} text
     * @param {Number} maxLength
     * @param {Array} output
     * @private
     */
    proto.splitLine = function(text, maxLength, output) {

        // End condition
        if (text === '') {
            return;
        }

        var remaining = '';
        var done = false;

        while (!done){
            this.measureDiv.innerHTML = text;
            var lineLen = this.measureDiv.clientWidth;
            if (lineLen <= maxLength) {
                output.push(text);
                this.splitLine(trimLeft(remaining), maxLength, output);
                done = true;
            } else {
                // Need to try with a shorter word!
                var parts = this.getShorterLine(text);
                if (parts.length === 1) {
                    // text is only one word that is way too long.
                    this.splitWord(text, remaining, maxLength, output);
                    done = true;
                } else {
                    text = parts[0];
                    remaining = parts[1] + remaining;
                }
            }
        }
    };

    /**
     * Given a line of text such as "hi there programmer", it returns
     * an array with 2 parts: ["hi there", " programmer"].
     *
     * It accounts for special cases with multi-spaces, such as for
     * "hi there  two-spaces" returns ["hi there", "  two-spaces"]
     *
     * When there is only one word, it returns the whole word:
     * "JustOneWord" returns ["JustOneWord"] (an array of 1 element)
     *
     * @param {String} line
     * @returns {Array}
     */
    proto.getShorterLine = function(line) {

        // TODO: Account for TABs
        // Will probably never do unless a bug is reported.

        var iLastSpace = line.lastIndexOf(' ');
        if (iLastSpace === -1) {
            return [line]; // This is a single word
        }

        // Else
        // Iterate back removing additional spaces (multi spaces)
        while (line.charAt(iLastSpace-1) === ' ') {
            iLastSpace--
        }

        var trailingWord = line.substr(iLastSpace); // Contains the spaces
        var shorterLine = line.substr(0,iLastSpace);
        return [shorterLine, trailingWord];
    };

    /**
     * Given a single word, splits it into multiple lines that fits in maxWidth
     * @param {String} word
     * @param {String} remaining
     * @param {Number} maxLength
     * @param {Array} output
     */
    proto.splitWord = function(word, remaining, maxLength, output) {

        var lenSoFar = 1;
        var fits = true;
        while (fits) {

            var part = word.substr(0,lenSoFar);
            this.measureDiv.innerHTML = part;
            var lineLen = this.measureDiv.clientWidth;

            if (lineLen > maxLength) {

                if (lenSoFar === 1) {
                    // we can't split 1 character any longer.
                    output.push(part);
                    this.splitWord(word.substr(1), remaining, maxLength, output);
                    return;
                }

                // It was fine until one less char //
                var okayWord = word.substr(0,lenSoFar-1);
                output.push(okayWord);
                var extraWord = word.substr(lenSoFar-1);
                this.splitLine(extraWord + remaining, maxLength, output);
                return;
            }

            // Try one more character
            lenSoFar++;

            // Check if we are done with all characters
            if (lenSoFar > word.length) {
                // Okay it fits
                output.push(word);
                return;
            }
        }
    };

    function trimRight(text) {
        if (text.length === 0) {
            return "";
        }
        var lastNonSpace = text.length-1;
        for (var i=lastNonSpace; i>=0; --i) {
            if (text.charAt(i) !== ' ') {
                lastNonSpace = i;
                break;
            }
        }
        return text.substr(0, lastNonSpace+1);
    }

    function trimLeft(text) {
        if (text.length === 0) {
            return "";
        }
        var firstNonSpace = 0;
        for (var i=0; i<text.length; ++i) {
            if (text.charAt(i) !== ' ') {
                firstNonSpace = i;
                break;
            }
        }
        return text.substr(firstNonSpace);
    }

    namespace.EditorTextInput = EditorTextInput;

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */


// Source: https://git.autodesk.com/A360/firefly.js/blob/develop/src/AutodeskNamespace.js
var AutodeskNamespace = AutodeskNamespace || function (s) {
    "use strict";

    /* jshint -W117 */
    var ns = typeof window !== 'undefined' && window !== null ? window : self;

    var parts = s.split('.');
        parts.forEach(function(elem) {
        ns[elem] = ns[elem] || {};
        ns = ns[elem];
    });

    return ns;
};

(function() {
    "use strict";

    /* jshint -W117 */

    //
    // "Private" variables
    //

    /** @namespace Autodesk */
    /** @namespace Autodesk.Search */
    var ns = new AutodeskNamespace('Autodesk.Search');

    var DEBUG = DEBUG || false;

    // Page load time instrumentation
    var searchSDKInstantiated = +new Date();
    var isPagePerformanceLogged = false;

    // version
    var versionInfo = Object.freeze({
        version: '1.0.0',
        buildDate: '[local-dev]',
        buildNumber: '[local-dev]',
        minRestApiVersion: '1.35.0'
    });

    var SearchQueryAPIRoot = 'qs';
    var ApiPortalSearchQueryAPIRoot = 'search';
    var SearchQueryAPIVersion = 'v2';
    var DefaultSearchEnv = 'prod';

    var SearchApiUrls = Object.freeze({
        localdev: 'http://search-localdev.api.autodesk.com:8080' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        dev: 'https://search-dev.api.autodesk.com' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        'dev-dr': 'https://search-dev-dr.api.autodesk.com' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        stg: 'https://search-staging.api.autodesk.com' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        'stg-dr': 'https://search-staging-dr.api.autodesk.com' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        prod: 'https://search.api.autodesk.com' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        'prod-dr': 'https://search-dr.api.autodesk.com' + '/' + SearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        apidev: 'https://developer-dev.api.autodesk.com' + '/' + ApiPortalSearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        apistg: 'https://developer-stg.api.autodesk.com' + '/' + ApiPortalSearchQueryAPIRoot + '/' + SearchQueryAPIVersion,
        apiprod: 'https://developer.api.autodesk.com' + '/' + ApiPortalSearchQueryAPIRoot + '/' + SearchQueryAPIVersion
    });

    var searchEnv = DefaultSearchEnv;
    var searchEndPoint = SearchApiUrls[searchEnv];
    var defaultAjaxTimeout = null;      // ms
    var suggestionDelay = 250;          // ms

    var SearchQueryAPIs = Object.freeze({
        'Query': '/search',
        'Categories': '/categories',
        'Suggestions': '/suggestions',
        'Log': '/log',
        'Health': '/health'
    });

    // Page load-time, visibility, and unload instrumentation
    var searchSDKLoaded = +new Date(); // When the Search SDK JS was loaded
    var lastVisiblityChange = +new Date(); // Last time the document was visible to the user
    var totalVisibleDuration=0, totalNotVisibleDuration=0;
    var lastQueryId, lastSessionInfo; // Shared between instances of the SearchQueryAPIs class
    if (document.addEventListener) { document.addEventListener("visibilitychange", visibilityChangeHandler, false); }
    if (window.addEventListener) { window.addEventListener("beforeunload", beforeUnloadHandler, false); }

    var SearchQueryHeaders = {
        TOKEN_HEADER_NAME:'x-ads-token',
        ANON_SESSION_HEADER_NAME: 'x-ads-anon-session',
        CLIENT_ID_HEADER_NAME: 'x-ads-client-id',
        CLIENT_FEATURE_ID_HEADER_NAME: 'x-ads-client-feature-id',
        SESSION_ID_HEADER_NAME: 'x-ads-session-id',
        DEBUG_HEADER_NAME: 'x-ads-debug',
        EXTRA_USER_ID_HEADER_NAME: 'x-ads-ex-user-id',
        CONTENT_TYPE_HEADER_NAME: 'Content-Type',
        ACCEPT_HEADER_NAME: 'Accept',
        AUTHORIZATION_HEADER_NAME: 'Authorization'
    };

    /**
     * @typedef QueryParameterType
     * @property {number} pid Profile id, for more see {@tutorial profiles}
     * @property {string} query The query string to search for
     * @property {string} sort The sort type of the search, acceptable values depend on the profile
     * @property {string} page The page number to retrieve
     * @property {string} filters The filters to apply to the search, the possible values depend on the profile and the returned categories
     * @property {number} modifier Search modifier ID
     */

    /**
     * Description of the behavior of the profile
     * @typedef Profile
     * @property {number} id - Id of profile, for example 'adsk.simple.main' or 'adsk.a360team.main'
     * @property {number} pageSize - approximate number of results returned on each page by the search API
     * @property {string[]} sortTypes - the ways the returned results can be sorted, for example the simple profile has two ways,
     * date ascending ('dateAscending') and date descending ('dateDescending')
     */

    /**
     * @typedef SessionInfoType
     * @property {string} clientId - application specific client identifier that will be added to the searches, for example an ClientId issued by the Dev Portal or an App specific Guid
     * @property {string} clientFeatureId - application specific Client Feature Id that will be added to the searches, for example main_search_bar
     * @property {string} sessionId - a session specific id, improves search reliability
     * @property {string} token - Oxygen OAuth1.0a user access token
     * @property {string} oauth2Token - Oxygen OAuth2.0 user access token
     * @property {string} userId - application user id if available
     * If you don't know what this should be, you should leave it empty.
     */

    /**
     * Object holding the constants that define the search filter configuration
     * @typedef FilterConfig
     * @property {string} listItemDelimiter - Separates name/value pairs in the list of filters
     * @property {string} nameValueDelimiter - Separates filter name from filter value in a name/value pair
     * @property {string} arrayListItemDelimiter - Separates arrays in the outer array
     * @property {string} arrayListValueDelimiter - Separates values in an inner array
     * @property {string} escapeCharacter - Escapes the above characters in filter names and values
     * @property {string} reservedArrayListFilterNames - Reserved filter names that accept arrays as values that restrict the search in special ways
     * @example
     * filter=userName~John!projectId~XXZZYX
     * where '!' is the filter list item delimiter and '~' is the filter name/value delimiter
     * or
     * filter=resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
     * where '*' is the array list value delimiter and "'" is the array list item delimiter
     * so the above filters have 3 items: adsk.wipmaster*fs.file*id123 and adsk.wipmaster*fs.file*id456 and adsk.wipmaster*fs.file*id789
     * and in this case every item has 3 values.
     * effect: restricts search to urns adsk.wipmaster:fs.file:id123, adsk.wipmaster:fs.file:id456, adsk.wipmaster:fs.file:id789
     */

    // Filter delimiting and escaping
    //
    // resourceIds    List of URNs used to scope the search. The URNs are broken into composite identifiers in the format:
    // sourceSystem*type*id*version*elementId The sub-fields are optional going from left to right.
    // For example, one can have just a sourceSystem, or a sourceSystem plus type, or a sourceSystem plus type plus id.
    //
    // Filter examples:
    // filter=docType~FILE!creator~C456QB2N9YSX!lastModifier~XABYDC12122
    // filter=resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
    // Meaning: Restrict search to urns adsk.wipmaster:fs.file:id123, adsk.wipmaster:fs.file:id456, adsk.wipmaster:fs.file:id789
    //
    // List item = name~value
    // Multiple list items: name1~value1!name1~value2!name2~value3!
    //
    var FilterConfig = deepFreeze({
        listItemDelimiter: '!',
        nameValueDelimiter: '~',
        arrayListItemDelimiter: '\'',
        arrayListValueDelimiter: '*',

        escapeCharacter: '\\',

        reservedArrayListFilterNames: ['resourceIds']
    });


    var FilterEscapeSequences = deepFreeze({
        nameValueDelimiterEscSeq: FilterConfig.escapeCharacter + FilterConfig.nameValueDelimiter,
        listItemDelimiterEscSeq: FilterConfig.escapeCharacter + FilterConfig.listItemDelimiter,
        arrayListItemDelimiterEscSeq: FilterConfig.escapeCharacter + FilterConfig.arrayListItemDelimiter,
        arrayListValueDelimiterEscSeq: FilterConfig.escapeCharacter + FilterConfig.arrayListValueDelimiter,
        escapeCharacterEscSeq: FilterConfig.escapeCharacter + FilterConfig.escapeCharacter
    });


    var BCP47ToUPILanguageCode = deepFreeze({
        'pt-BR': 'PTB',     // Brazilian Portuguese
        'cs': 'CSY',        // Czech
        'en': 'ENU',        // English
        'en-us': 'ENU',     // English
        'fr': 'FRA',        // French
        'de': 'DEU',        // German
        'hu': 'HUN',        // Hungarian
        'it': 'ITA',        // Italian
        'ja': 'JPN',        // Japanese
        'ko': 'KOR',        // Korean
        'pl': 'PLK',        // Polish
        'ru': 'RUS',        // Russian
        'zh-CN': 'CHS',     // Simplified Chinese
        'es': 'ESP',        // Spanish
        'es-ES': 'ESP',     // Spanish
        'zh-TW': 'CHT'      // Traditional Chinese
    });


    //
    // "Private" functions
    //

    function parseUrlParams(urlSearch) {
        if (!urlSearch || urlSearch.length === 0) {
            return null;
        }
        return  urlSearch.replace(/^#?\?/,'')
            .split('&')
            .map(function(s){
                return s.split('=').map(function(v){ return decodeURIComponent(v);
            });
        });
    }

    function deepFreeze(obj) {
        if (typeof obj !== 'object' || obj === null) { return obj; }
        if (Object.getOwnPropertyNames) {
            Object.getOwnPropertyNames(obj).forEach(function(name) {
                var p = obj[name];
                if (typeof p === 'object' && !Object.isFrozen(p)) { deepFreeze(p); }
            });
        }
        return Object.freeze(obj);
    }

    // To prevent CORS preflight request:
    // method := {HEAD|GET|POST} ;
    // headers := {Accept, Accept-Language, Content-Language, Last-Event-ID, Content-Type}
    // Content-Type header := {application/x-www-form-urlencoded|multipart/form-data|text/plain}
    function ajaxReq(url, headers, cb, timeout) {
        cb = cb || function(){};

        if (!url || !headers) {
            console.error("Invalid URL or Request Headers for the Query Service REST API");
            setTimeout(function() { cb("Invalid URL or Request Headers for the Query Service REST API", null); }, 0);
            return;
        }

        var xhr = new XMLHttpRequest();
        xhr.open('GET', url);

        Object.keys(headers).forEach(function (headerName) {
            if (typeof headers[headerName] !== 'undefined' && headers[headerName] !== null) {
                xhr.setRequestHeader(headerName, headers[headerName]);
            }
        });

        var cbCalled = [];

        xhr.onreadystatechange = done();
        xhr.onload = done();
        xhr.onerror = done(null, 'Error');
        xhr.ontimeout = done(null, 'TimeOut');
        xhr.onabort = done(null, 'Abort');
        xhr.timeout = timeout || defaultAjaxTimeout;

        xhr.send();

        function done(statusCode, eventName) {
            return function() {
                var status, err=null, result=null;

                if (xhr.readyState === 4) {
                    status = xhr.status || statusCode || -1;

                    if (xhr.response && (xhr.getResponseHeader('Content-Type') === 'application/json' || xhr.responseType === 'json')) {
                        result = JSON.parse(xhr.response);
                    } else {
                        result = xhr.response;
                    }

                    if (!cbCalled[status]) {
                        cbCalled[status] = true;

                        if (status !== 200) {
                            err = xhr.status || statusCode || 'unknown error';
                        }

                        if (err) { cb(err, null); return; }
                        else { cb(null, result); return; }
                    }
                }
            };
        }
    }

    function visibilityChangeHandler() {
        var logBody, duration, now=+new Date();
        if (lastQueryId && lastSessionInfo) { // These are set after the first successful query or autosuggest request
            duration = now - lastVisiblityChange;
            lastVisiblityChange = now;

            if (document.hidden) { // Document went from visible to NOT visible
                totalVisibleDuration += duration;
                logBody = { documentVisibleDuration: duration, totalDocumentVisibleDuration: totalVisibleDuration, totalDocumentNotVisibleDuration: totalNotVisibleDuration };
                logEvent(lastQueryId, lastSessionInfo, "documentNotVisible", logBody);
            } else  { // Document went from NOT visible to visible
                totalNotVisibleDuration += duration;
                logBody = { documentNotVisibleDuration: duration, totalDocumentVisibleDuration: totalVisibleDuration, totalDocumentNotVisibleDuration: totalNotVisibleDuration };
                logEvent(lastQueryId, lastSessionInfo, "documentVisible", logBody);
            }
        }
    }

    function beforeUnloadHandler() {
        var logBody = {}, duration, now=+new Date();
        if (lastQueryId && lastSessionInfo) { // These are set after the first successful query or autosuggest request
            duration = now - lastVisiblityChange;
            lastVisiblityChange = now;
            if (document.hidden) { totalNotVisibleDuration += duration; }
            else { totalVisibleDuration += duration; }
            logBody = { totalDocumentVisibleDuration: totalVisibleDuration, totalDocumentNotVisibleDuration: totalNotVisibleDuration };
            logEvent(lastQueryId, lastSessionInfo, "documentUnloaded", logBody);
        }
    }

    function setLoggerLastQueryInfo(queryId, sessionInfo) {
        lastQueryId = queryId;
        lastSessionInfo = sessionInfo;
    }

    // Headers accepted by the Query Service REST API:
    // x-ads-token: identifies the user in oxygen
    // x-ads-client-id: identifies the client application
    // x-ads-client-feature-id: identifies the client application feature that uses search
    // x-ads-session-id: identifies the current session
    // x-ads-anon-session: true|false
    // x-ads-debug: true|false
    // 'Content-Type': 'application/json'
    function sessionInfoToHeaders(sessionInfo) {
        var headers = {};
        headers[SearchQueryHeaders.TOKEN_HEADER_NAME] = sessionInfo.token;
        headers[SearchQueryHeaders.AUTHORIZATION_HEADER_NAME] = sessionInfo.oauth2Token ? ("Bearer " + sessionInfo.oauth2Token) : undefined;
        headers[SearchQueryHeaders.ANON_SESSION_HEADER_NAME] = (sessionInfo.token || sessionInfo.oauth2Token) ? 'false' : 'true';
        headers[SearchQueryHeaders.CLIENT_ID_HEADER_NAME] = sessionInfo.clientId;
        headers[SearchQueryHeaders.CLIENT_FEATURE_ID_HEADER_NAME] = sessionInfo.clientFeatureId;
        headers[SearchQueryHeaders.SESSION_ID_HEADER_NAME] = sessionInfo.sessionId;
        headers[SearchQueryHeaders.EXTRA_USER_ID_HEADER_NAME] = sessionInfo.userId;
        headers[SearchQueryHeaders.DEBUG_HEADER_NAME] = DEBUG;
        headers[SearchQueryHeaders.CONTENT_TYPE_HEADER_NAME] = 'application/json';
        headers[SearchQueryHeaders.ACCEPT_HEADER_NAME] = 'application/json';
        return headers;
    }

    function validateHeaders(headers) {
        var err = null;

        // Check OAUTH2 is used only w/ apidev/apistg/apiprod endpoints
        if (headers[SearchQueryHeaders.AUTHORIZATION_HEADER_NAME] && searchEnv !== 'apidev' && searchEnv !== 'apistg' && searchEnv !== 'apiprod') {
            err = '\'' + SearchQueryHeaders.AUTHORIZATION_HEADER_NAME + '\'' + ' header for OAUTH2 not valid for ' + searchEnv + ' endpoint. Use one of apidev/apistg/apiprod endpoints.';
        }

        // Check OAUTH1 is not used w/ apidev/apistg/apiprod endpoints
        if (headers[SearchQueryHeaders.TOKEN_HEADER_NAME] && (searchEnv === 'apidev' || searchEnv === 'apistg' || searchEnv === 'apiprod')) {
            err = '\'' + SearchQueryHeaders.AUTHORIZATION_HEADER_NAME + '\'' + ' header for OAUTH1 not valid for ' + searchEnv + ' endpoint.';
        }

        // Check OAUTH1 & OAUTH2 tokens are not both defined
        if (headers[SearchQueryHeaders.TOKEN_HEADER_NAME] && headers[SearchQueryHeaders.AUTHORIZATION_HEADER_NAME]) {
            err = '\'' + SearchQueryHeaders.AUTHORIZATION_HEADER_NAME + '\'' + ' and ' + '\'' + SearchQueryHeaders.AUTHORIZATION_HEADER_NAME + '\'' + ' headers can not coexist.';
        }

        // Check OAUTH2 is used w/ ExtraUserId header
        if (headers[SearchQueryHeaders.EXTRA_USER_ID_HEADER_NAME] && !headers[SearchQueryHeaders.AUTHORIZATION_HEADER_NAME]) {
            err = '\'' + SearchQueryHeaders.AUTHORIZATION_HEADER_NAME + '\'' + ' OAUTH2 header must be used w/ ' + '\'' + SearchQueryHeaders.EXTRA_USER_ID_HEADER_NAME + '\'' + ' header.';
        }

        // Check clientId header exists
        if (!headers[SearchQueryHeaders.CLIENT_ID_HEADER_NAME]) {
            err = '\'' + SearchQueryHeaders.CLIENT_ID_HEADER_NAME + '\'' + ' header is required for all requests.';
        }

        // Check featureId header exists
        if (!headers[SearchQueryHeaders.CLIENT_FEATURE_ID_HEADER_NAME]) {
            err = '\'' + SearchQueryHeaders.CLIENT_FEATURE_ID_HEADER_NAME + '\'' + 'header is required for all requests.';
        }

        // Check content-type
        // TODO(jwo): Why is this set by the user if there is only one allowed value?
        if (headers[SearchQueryHeaders.CONTENT_TYPE_HEADER_NAME] !== 'application/json') {
            err = '\'' + SearchQueryHeaders.CONTENT_TYPE_HEADER_NAME + '\'' + ' header must be application/json for all requests.';
        }

        // Check ???
        // TODO(go): Explain validation step in comment above & break in to two steps if possible
        if (!headers[SearchQueryHeaders.TOKEN_HEADER_NAME] &&
            !headers[SearchQueryHeaders.AUTHORIZATION_HEADER_NAME] &&
            !(headers[SearchQueryHeaders.SESSION_ID_HEADER_NAME] && headers[SearchQueryHeaders.ANON_SESSION_HEADER_NAME])) {
            err = '\'' + SearchQueryHeaders.TOKEN_HEADER_NAME + '\'' + ' or ' + '\'' + SearchQueryHeaders.AUTHORIZATION_HEADER_NAME + '\'' + ' header needs to be a valid value or both ' +
                '\'' + SearchQueryHeaders.SESSION_ID_HEADER_NAME + '\'' + ' and ' + '\'' + SearchQueryHeaders.ANON_SESSION_HEADER_NAME + '\'' + ' header need to be specified.';
        }

        return err;
    }

    function validateParameters(queryParams) {
        var err = null;

        if (!queryParams) {
            err = 'queryParams: needs to be specified.';
        }

        if (!queryParams.pid && queryParams.pid !== 0) {
            err = 'queryParams.pid: needs to be a valid Profile Id.';
        }

        if (queryParams.pid < 0) {
            err = 'queryParams.pid: Profile Id needs to be an integer greater than zero.';
        }

        if (!queryParams.query) {
            err = 'queryParams.query empty.';
        }

        if (!queryParams.page) {
            err = 'queryParams.page empty.';
        }

        if (queryParams.page < 0 || queryParams.page > 100) {
            err = 'queryParams.page should be a positive integer between 1 and 100';
        }

        if (queryParams.language !== undefined && queryParams.language !== '' && typeof queryParams.language !== 'string') {
            console.warn('queryParams.language should be a language identifier');
        }

        return err;
    }

    function composeQueryURL(serviceUrl, queryParams) {
        var queryUrl = serviceUrl;

        if (queryParams.pid) {
            queryUrl += '?pid=' + queryParams.pid;
        }
        if (queryParams.query) {
            queryUrl += '&query=' + encodeURIComponent(queryParams.query);
        }
        if (queryParams.language) {
            queryUrl += '&language=' + encodeURIComponent(queryParams.language);
        }
        if (queryParams.modifier) {
            queryUrl += '&modifier=' + encodeURIComponent(queryParams.modifier);
        }
        if (queryParams.filters) {
            queryUrl += '&filters=' + encodeURIComponent(queryParams.filters);
        }
        if (queryParams.sort && queryParams.sort !== 'relevance') {
            queryUrl += '&sort=' + encodeURIComponent(queryParams.sort);
        }
        if (queryParams.page && queryParams.page !== 1) {
            queryUrl += '&page=' + encodeURIComponent('' + queryParams.page);
        }

        if (searchEnv !== DefaultSearchEnv) {
            queryUrl += '&env=' + encodeURIComponent(searchEnv);
        }

        queryUrl = queryUrl.replace(/^\?&/,'?');

        return queryUrl;
    }


    //
    // Filters
    //
    // docType~FILE!creator~C456QB2N9YSX!lastModifier~XABYDC12122!resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
    // becomes
    // [['docType', 'FILE'], ['creator', 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', [['adsk.wipmaster', 'fs.file', 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']]]];
    //
    // arr -> str steps: 1. escape strings -- 2. concatenate using the delimiters
    // str -> arr steps: 1. break up string by delimiters and create arrays -- 2. unescape strings in arrays
    // this functions assumes that the escape characters have already been escaped so there would be no characters
    // inserted that would cause the original string to contain unexpected string
    function escapeString(str, char, escapedChar) {
        if (str.indexOf(FilterConfig.escapeCharacter) === -1) {
            return str;
        }
        return str.split(char).join(escapedChar);
    }

    function escapeFilterStr(str) {
        str = str || '';

        str = escapeString(str, FilterConfig.escapeCharacter, FilterEscapeSequences.escapeCharacterEscSeq);
        str = escapeString(str, FilterConfig.listItemDelimiter, FilterEscapeSequences.listItemDelimiterEscSeq);
        str = escapeString(str, FilterConfig.nameValueDelimiter, FilterEscapeSequences.nameValueDelimiterEscSeq);
        str = escapeString(str, FilterConfig.arrayListItemDelimiter, FilterEscapeSequences.arrayListItemDelimiterEscSeq);
        str = escapeString(str, FilterConfig.arrayListValueDelimiter, FilterEscapeSequences.arrayListValueDelimiterEscSeq);

        return str;
    }


    // from [['adsk.wipmaster', 'fs.file', 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']];
    // to adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
    function filterArrayListFilterToEscapedFilterStr(filterArr) {
        var strArr = filterArr.map(function(a) {
            var str = a[0];
            for (var i = 1; i < a.length; i++) {
                str += FilterConfig.arrayListValueDelimiter + a[i];
            }
            return str;
        });
        return strArr.join(FilterConfig.arrayListItemDelimiter);
    }


    //
    // [['docType', 'FILE'], ['creator', 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', [['adsk.wipmaster', 'fs.file', 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']]]];
    // becomes
    // docType~FILE!creator~C456QB2N9YSX!lastModifier~XABYDC12122!resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
    //
    function filterArrayToEscapedFilterString(filterArr) {
        var escapedArrayValueListString = "";

        var strArr = filterArr.map(function(f) {
            if (FilterConfig.reservedArrayListFilterNames.indexOf(f[0]) !== -1 && Array.isArray(f[1])) {          // find reserved names that have values that should be converted to arrays and convert them to arrays
                var escapedFilterArrayStr = filterArrayListFilterToEscapedFilterStr(f[1]);
                return (escapeFilterStr(f[0]) + FilterConfig.nameValueDelimiter + escapedFilterArrayStr);
            } else {                                                            // normal name - value pair
                return escapeFilterStr(f[0]) + FilterConfig.nameValueDelimiter + escapeFilterStr(f[1]);
            }
        });

        return strArr.join(FilterConfig.listItemDelimiter);
    }


    //
    // if delimiter is ~ and the escape char is \ then:
    // 'a\\\\\\~aa~bb\\\\b' --> ['a\\\\\\~aa', 'bb\\\\b']
    //
    function filterStringToUnescapedArray(str, delimiterChar, escapeChar) {
        if (!str || !delimiterChar || !escapeChar) {
            return [];
        }

        var arr = [];
        var ch = '';
        var s1 = '';
        var escState = false;
        for (var i = 0; i < str.length; i++) {
            ch = str[i];
            if (ch === escapeChar) {
                escState = !escState;
                s1 += ch;
            } else if (ch === delimiterChar && !escState) {
                arr.push(s1);
                s1 = '';
                escState = false;
            } else {
                s1 += ch;
                escState = false;
            }
        }
        if (s1.length) {
            arr.push(s1);
        }
        return arr;
    }

    //
    // adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
    // to
    // [['adsk.wipmaster', 'fs.file' 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']]
    //
    function filterItemListArrayStringToItemListArray(itemListArrayString) {
        var itemListArray = filterStringToUnescapedArray(itemListArrayString, FilterConfig.arrayListItemDelimiter, FilterConfig.escapeCharacter);
        return itemListArray.map(function(itemList){
            return filterStringToUnescapedArray(itemList, FilterConfig.arrayListValueDelimiter, FilterConfig.escapeCharacter);
        });
    }

    //
    // Parse the list of name / value pairs and break up the arraylists to arrays
    // [['docType', 'FILE'], ['creator' 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', 'adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789']]
    // becomes
    // [['docType', 'FILE'], ['creator', 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', [['adsk.wipmaster', 'fs.file', 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']]]];
    //
    function filterNameValueItemArrayToFilterNameValueValueItemAndArrayListArray(nameValueItemArray) {
        var itemListArray = [];
        return nameValueItemArray.map(function(nameValuePair){
            if (FilterConfig.reservedArrayListFilterNames.indexOf(nameValuePair[0]) !== -1) {
                itemListArray = filterItemListArrayStringToItemListArray(nameValuePair[1]);
                return [nameValuePair[0], itemListArray];
            } else {
                return nameValuePair;
            }
        });
    }

    //
    // ['docType~FILE', 'creator~C456QB2N9YSX', 'lastModifier~XABYDC12122', 'resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789']
    // becomes
    // [['docType', 'FILE'], ['creator' 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', 'adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789']]
    //
    function filterItemValueStringArrayToItemValueArray(itemValueStringArray) {
        return itemValueStringArray.map(function(itemValueString) {
            return filterStringToUnescapedArray(itemValueString, FilterConfig.nameValueDelimiter, FilterConfig.escapeCharacter);
        });
    }

    //
    // break up a filter string, into an array of name-value pair  strings
    // docType~FILE!creator~C456QB2N9YSX!lastModifier~XABYDC12122!resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
    // becomes
    // ['docType~FILE', 'creator~C456QB2N9YSX', 'lastModifier~XABYDC12122', 'resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789']
    //
    function filterStringToItemArray(str) {
        return filterStringToUnescapedArray(str, FilterConfig.listItemDelimiter, FilterConfig.escapeCharacter)
    }


    function filterStringToUnescapedFilterArray(str) {
        if (!str || !str.length) {

            return [];
        }

        var itemArray = filterStringToItemArray(str);
        var itemValueArray = filterItemValueStringArrayToItemValueArray(itemArray);
        return filterNameValueItemArrayToFilterNameValueValueItemAndArrayListArray(itemValueArray);
    }



    //function unescapeString(filterArr, escapedSeq, unescapedStr) {
    //    if (str.indexOf(escapedSeq) === -1) {
    //        return filterArr;
    //    }
    //
    //    return filterArr.map(function(a) {
    //        return a.map(function(b) {
    //            return a.split(escapedSeq).join(unescapedStr); }); });
    //}
    //
    //
    ////
    //// 'a\\\\\\~aa~bb\\\\b' --> ['a\\\\\\~aa', 'bb\\\\b']
    ////
    //// s = 'a\\\\\\~aa~bb\\\\b'
    //// r = s.split(/\\\\/)
    //// r2 = r.map(function(a){ return a.split(/[^\\]~/) })
    //// s.split(/[^\\]~/) = ["a\~a", "bb\\b"]
    //// r4 = [r2[0][0] + '\\\\' + r2[1][0], r2[1][1] + '\\\\' + r2[2][0]]
    //// 1. split on double escapes ( \\ )
    //// 2. split on separators
    //// 3. put back double escapes
    //// 4. create new array from this by concating the last of subarray to first of next subarray
    ////
    //function filterStringToUnescapedFilterArray(str) {
    //    if (!str || !str.length) {
    //
    //        return [];
    //    }
    //
    //    str = str || '';
    //    // string -> name-value array
    //    var filterArr = str.split(FilterConfig.listItemDelimiter).map(function(f) {
    //            return f.split(FilterConfig.nameValueDelimiter); }) || [];
    //
    //    // find reserved names that have values that should be converted to arrays and convert them to arrays
    //    filterArr = filterArr.map(function(f) {
    //        if (qsReservedArrayListFilterNames.indexOf(f[0]) === -1) {
    //            return f;
    //        }
    //
    //        return f[1].split(FilterConfig.arrayListItemDelimiter).map(function(values) {
    //            return a.split(FilterConfig.arrayListValueDelimiter);
    //        });
    //    });
    //
    //    if (filterArr.length === 0) {
    //        return filterArr;
    //    }
    //
    //    // Unescape escaped strings
    //    filterArr = unescapeString(filterArr, FilterEscapeSequences.nameValueDelimiterEscSeq, FilterConfig.nameValueDelimiter);
    //    filterArr = unescapeString(filterArr, FilterEscapeSequences.listItemDelimiterEscSeq, FilterConfig.listItemDelimiter);
    //    filterArr = unescapeString(filterArr, FilterEscapeSequences.arrayListValueDelimiterEscSeq, FilterConfig.arrayListValueDelimiter);
    //    filterArr = unescapeString(filterArr, FilterEscapeSequences.arrayListItemDelimiterEscSeq, FilterConfig.arrayListItemDelimiter);
    //
    //    return filterArr;
    //}


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    //
    // "Public" API structures and calls
    //


    /**
     * @typedef SearchResultId - A structure describing the source of this result
     * @property {string} sourceSystem - id of the source system
     * @property {string} type - type of the result in the source system, for example 'file'
     * @property {string} id - id of the result in the source system
     * @property {int} version - version of the result in the source system
     */

    /**
     * @typedef QueryResult
     * @property {int} totalResultCount - approximate total result count
     * @property {string} queryId - guid of the query, unique for each request
     * @property {Object[]} queryResults - the array of results
     * @property {SearchResultId} queryResults[].searchResultId - a structure describing the source of this result
     * @property {string} queryResults[].name - name of the result
     * @property {date} queryResults[].dateModified - modification of the result
     */

    /**
     * @typedef CategoriesResult
     * @property {string} queryId - guid of the query, unique for each request
     * @property {Object[]} queryCategories - the array of categories
     * @property {string} queryCategories[].categoryName - name of category
     * @property {string} queryCategories[].categoryType - type of category, for example "term"
     * @property {Object[]} queryCategories[].values - list of values found for the category and the number of instances found
     * @property {string} queryCategories[].values[].value - a value for the category, this can be used as a filter in subsequent queries with the category name,
     * as in ...&filter=cat1:val11|cat1:val12|cat2:val22
     * @property {number} queryCategories[].values[].count - an approximate count for the instances this category value was found
     */

    /**
     * @typedef SuggestionsResult
     * @property {string} queryId - guid of the query, unique for each request
     * @property {Object[]} textSuggestions - The array of search term suggestions. These are 'normal' search terms or expressions
     * that could be used as the query parameter expanding the current word root.
     * @property {int} textSuggestions[].positionHint - the position where the suggestion should be displayed
     * @property {int} textSuggestions[].suggestion - the suggestion text. The matching substring is highlighted the same way as search results.
     * @property {Object[]} suggestionGroups - A list of specific groups of search results that the search would return if executed with the current search term.
     * @property {string} suggestionGroups[].modifier - search modifier ID
     * @property {string} suggestionGroups[].displayName - Name of group type, for example 'fileSuggestions' if the source system is a file system for this group of suggestions
     * @property {int} suggestionCount - the number of suggestions available for that group
     * @property {Object[]} suggestionGroups[].suggestions - A list of objects describing the suggested results
     * @property {SearchResultId} suggestionGroups[].suggestions[].searchResultId - a structure describing the source of this result
     * @property {string} suggestionGroups[].suggestions[].title - Title or name of this particular result
     * @property {string} suggestionGroups[].suggestions[].creator -
     * @property {string} suggestionGroups[].suggestions[].dateCreated -
     * @property {string} suggestionGroups[].suggestions[].dateModified -
     * @property {string} suggestionGroups[].suggestions[].lastModifier -
     * @property {int} suggestionGroups[].suggestions[].positionHint - the position where the suggestion should be displayed
     * @property {string} suggestionGroups[].suggestions[].snippet -
     * @property {string} suggestionGroups[].suggestions[].source -
     * @property {string} suggestionGroups[].suggestions[].stringFields -
     * @property {string} suggestionGroups[].suggestions[].url -
     * @property {string} suggestionGroups[].suggestions[].viewerContexts -
     */

    /**
     * @typedef ServiceInfoResult
     * @property {boolean} indexingWorkQueueHealthy
     * @property {boolean} searchesSuccessful
     * @property {boolean} searchClusterRunning
     * @property {Object} versionInfo
     * @property {string} versionInfo.version
     * @property {date} versionInfo.buildDate
     * @property {string} javaVersion
     * @example An example ServiceInfoResult would be:
     * {
     *  "indexingWorkQueueHealthy": true,
     *  "searchesSuccessful": false,
     *  "searchClusterRunning": false,
     *  "versionInfo": {
     *      "version": "1.27-SNAPSHOT",
     *      "buildDate": "2015-11-03T20:20 GMT-0800"
     *  },
     * "javaVersion": "1.7.0_80"
     * }
     */

    /**
     * This is the callback that is called when the http request to the Query Service REST API 'Search' endpoint is complete
     * and on success it returns a list of search results. The structure of these results is as described in the {QueryResult} structure
     *
     * @callback SearchAjaxCallback
     * @param {int} err - the status code of the response, when the ajax call succeeds, it's null, otherwise set to
     * the HTTP status code of the response. Possible error values include 401 (if a required header is missing, for example)
     * or 404 (if an endpoint is not found) or 500 (Internal error)
     * @param {QueryResult|CategoriesResult|SuggestionsResult|ServiceInfoResult} result - the result object if the operation is successful
     * or null if it failed
     */
     function logEvent(queryId, sessionInfo, type, body, cb) {
        var hadCb = !!cb, beaconSent = false;

        if (cb && typeof cb !== "function") { throw new Error("Callback was not a function"); }

        cb = cb || function () {};

        var logURL = searchEndPoint + SearchQueryAPIs.Log +
            '?queryId=' + queryId +
            '&type=' + encodeURIComponent(type) + // Note: if &type= is first, Adblockers block the logging call
            '&sessionId=' + (sessionInfo.sessionId || '') +
            '&userId=' + (sessionInfo.userId || '') +
            '&clientId=' + (sessionInfo.clientId || '') +
            '&clientFeatureId=' + (sessionInfo.clientFeatureId || '') +
            '&body=' + encodeURIComponent(JSON.stringify(body)) +
            '&_n=' + Math.floor(Math.random() * 100000);  // nonce to prevent caching

        var logCb = function (err, info) {
            if (err) { console.debug('Logged(err:' + (err || 'noerr') + ' info:' + (info || '-') + '): ' + logURL); }
            cb(err); return;
        };

        // to prevent CORS preflight, we need to keep it simple
        // for more, see http://www.html5rocks.com/en/tutorials/cors/#toc-types-of-cors-requests
        var headers = {};
        headers[SearchQueryHeaders.CONTENT_TYPE_HEADER_NAME] = 'text/plain';

        // Use a beacon if available & there is no callback
        //if (!hadCb && navigator.sendBeacon) {
        //    beaconSent = navigator.sendBeacon(logURL);
        //}

        if (!beaconSent) {
            ajaxReq(logURL, headers, logCb);
        }
    }


    function pagePerformanceLogger(queryId, sessionInfo) {
        var logBody, performanceObj;

        if (!isPagePerformanceLogged) {
            if (window && window.performance) {

                performanceObj = clonePerformanceObject();

                // Add in SDK timings
                performanceObj.searchSDKTimings = {
                    fetchStartToSearchSDKLoaded: searchSDKLoaded - performanceObj.timing.fetchStart,
                    fetchStartToSearchSDKInstantiated: searchSDKInstantiated - performanceObj.timing.fetchStart,
                    fetchStartToNow: +new Date() - performanceObj.timing.fetchStart,
                };

                // Add in calculated times. See performance object descriptions: http://w3c.github.io/navigation-timing/#h-processing-model
                performanceObj.timingDelta = {};
                if (performanceObj.timing) {
                    performanceObj.timingDelta.navigationStartToDomInteractive = performanceObj.timing.domInteractive - performanceObj.timing.navigationStart;
                    performanceObj.timingDelta.dns = performanceObj.timing.domainLookupEnd - performanceObj.timing.domainLookupStart;
                    performanceObj.timingDelta.htmlDownloadTime = performanceObj.timing.responseEnd - performanceObj.timing.responseStart;
                    performanceObj.timingDelta.tcpConnectionSetup = performanceObj.timing.connectEnd - performanceObj.timing.connectStart;
                    if (performanceObj.timing.secureConnectionStart) { performanceObj.timingDelta.secureConnectionSetup = performanceObj.timing.connectEnd - performanceObj.timing.secureConnectionStart; }

                    // Starting w/ the fetchStart time, calculate the delta duration to all other times
                    Object.keys(performanceObj.timing).forEach(function(key) {
                        if (performanceObj.timing[key] !== 0) {
                            performanceObj.timingDelta['fetchStartTo' + key[0].toUpperCase() + key.slice(1)] = performanceObj.timing[key] - performanceObj.timing.fetchStart;
                        }
                    });
                }

                // Remove the raw timing data (reduce logging URL parameter size)
                delete performanceObj.timing;

                logBody = {
                    url: document && document.location && document.location.href,
                    userAgent: navigator.userAgent,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    language: navigator.language,
                    performance: performanceObj,
                };
            } else {
                logBody = { noPerformance:true };
            }
            logEvent(queryId, sessionInfo, "performance", logBody);
        }

        isPagePerformanceLogged = true;
    }

    function clonePerformanceObject() {
        if (!window || !window.performance) { return {}; }

        var clonePerformanceSubSection = function(section) {
            if (!window.performance[section]) { return null; }

            return Object.keys(Object.getPrototypeOf(window.performance[section])).reduce(function(obj, k){
                if (window.performance[section][k] >= 0) { obj[k] = window.performance[section][k]; }
                return obj;
            }, {});
        };

        // Special work is needed to clone this built-in class
        return Object.keys(Object.getPrototypeOf(window.performance)).reduce(function(obj, section){
            if ((section.indexOf('onwebkit') !== 0) && window.performance[section] && typeof window.performance[section] === 'object') { obj[section] = clonePerformanceSubSection(section); }
            return obj;
        }, {});
    }

    function addClickLoggingCallbacksToSERP(queryId, sessionInfo, data /* Modifies */) {
        var allResults, querySource;

        if (!data) { return; }

        querySource = "SERP";
        allResults = [].concat(data.queryResults||[], data.federatedResults||[]); // TODO(jwo): Correctly insert AKN result in proper position

        // Add click logging callbacks to each result
        allResults.forEach(function(result, i) {
            addClickLoggingCallbacksToResult(result, i+1, queryId, sessionInfo, querySource, '');
        });
    }

    function addClickLoggingCallbacksToSuggestions(queryId, sessionInfo, data /* Modifies */) {
        var querySource;

        if (!data) { return; }
        querySource = "suggestions";

        (data.suggestionGroups||[]).forEach(function(suggestionGroup) {
            var suggestionGroupName = suggestionGroup.name;
            // Add click logging callbacks to each result
            suggestionGroup.suggestions.forEach(function(suggestion, i) {
                addClickLoggingCallbacksToResult(suggestion, i+1, queryId, sessionInfo, querySource, suggestionGroupName);
            });
        });

        (data.textSuggestions||[]).forEach(function(termSuggestion, i) {
            addClickLoggingToTextSuggestion(termSuggestion, i, queryId, sessionInfo, querySource, '');
        });
    }

    function addClickLoggingToTextSuggestion(result, position, queryId, sessionInfo, querySource, subQuerySource) {
        result.logClick = function() {
            var logBody = { position:position, url:'', querySource:querySource, subQuerySource:subQuerySource };
            if (result.suggestion) { logBody.title = result.suggestion; }

            logEvent(queryId, sessionInfo, "click", logBody);
        };
    }

    function addClickLoggingCallbacksToResult(result, position, queryId, sessionInfo, querySource, subQuerySource) {
        result.logClick = function() {
            var logBody = { position:position, url:'', querySource:querySource, subQuerySource:subQuerySource };
            if (result.searchResultId) { // Organic results have this field
                logBody.id = result.searchResultId.id;
                logBody.sourceSystem = result.searchResultId.sourceSystem;
            }
            if (result.url) { logBody.url = result.url; } // AKN results have this field

            logEvent(queryId, sessionInfo, "click", logBody);
        };
    }


    /**
     * The Search Query Javascript API main object
     * @class SearchQueryAPI
     * @memberof Autodesk.Search
     * @classdesc This is the main constructor that will provide simplified access to the Query Service REST API
     * @param env {string} environment specifier - one of dev, stg, prod (default)
     */
    function SearchQueryAPI(env) {
        if (env && SearchApiUrls.hasOwnProperty(env)) {
            searchEnv = env;
        } else {
            searchEnv = DefaultSearchEnv;
        }
        searchEndPoint = SearchApiUrls[searchEnv];

        var _this = this;

        /**
        * Returns the Search Query Javascript API version
        * @function
        * @memberof Autodesk.Search.SearchQueryAPI.prototype
        * @instance
        * @returns {string}
        */
        this.getApiVersion = function() {
            return versionInfo.version;
        };

        /**
         * Search Query REST API version that is compatible with this API. It is recommended that
         * this version is equal to the version that is returned by [queryServiceInfo]{@link Autodesk.Search.SearchQueryAPI#queryServiceInfo}
         * @see {@link Autodesk.Search.SearchQueryAPI#queryServiceInfo|queryServiceInfo}
         * @function getServerMinRestApiVersion
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @returns {string}
         */
        this.getServerMinRestApiVersion = function() {
            return versionInfo.minRestApiVersion;
        };

        /**
         * Returns the Search Query Javascript API version
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @returns {string}
         */
        this.getBuildDate = function() {
            return versionInfo.buildDate;
        };

        /**
         * Returns the Search Query Javascript API build number
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @returns {string}
         */
        this.getBuildNumber = function() {
            return versionInfo.buildNumber;
        };

        /**
         * Returns the available Environments
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @returns {Array}
         */
        this.getServiceEnvironments = function() {
            return Object.keys(SearchApiUrls);
        };


        /**
         * Returns the Search Query filter list item delimiter
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @returns {FilterConfig}
         * @example
         * filter=userName~John!projectId~XXZZYX
         * where '!' is the filter list item delimiter and '~' is the filter name/value delimiter
         * or
         * filter=resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
         * where '*' is the array list value delimiter and "'" is the array list item delimiter
         * so the above filters have 3 items: adsk.wipmaster*fs.file*id123 and adsk.wipmaster*fs.file*id456 and adsk.wipmaster*fs.file*id789
         * and in this case every item has 3 values.
         * effect: restricts search to urns adsk.wipmaster:fs.file:id123, adsk.wipmaster:fs.file:id456, adsk.wipmaster:fs.file:id789
         */
        this.getFilterConfig = function() {
            return FilterConfig;
        };

        /**
         * Returns the Search Query reserved filter names that can hold Array lists of filter values
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @param str {string} String to convert
         * @instance
         * @returns {string}
         * @example
         * [['docType', 'FILE'], ['creator', 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', [['adsk.wipmaster', 'fs.file', 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']]]]
         * would be converted to
         * docType~FILE!creator~C456QB2N9YSX!lastModifier~XABYDC12122&resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
         */
        this.filterStringToFilterArray = function(str) {
            return filterStringToUnescapedFilterArray(str);
        };


        /**
         * Returns the Search Query reserved filter names that can hold Array lists of filter values
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @param arr {Array} Array to convert to String
         * @instance
         * @returns {string}
         * @example
         * docType~FILE!creator~C456QB2N9YSX!lastModifier~XABYDC12122&resourceIds~adsk.wipmaster*fs.file*id123'adsk.wipmaster*fs.file*id456'adsk.wipmaster*fs.file*id789
         * would be converted to [['docType', 'FILE'], ['creator', 'C456QB2N9YSX'], ['lastModifier', 'XABYDC12122'], ['resourceIds', [['adsk.wipmaster', 'fs.file', 'id123'], ['adsk.wipmaster', 'fs.file', 'id456'], ['adsk.wipmaster', 'fs.file', 'id789']]]]
         */
        this.filterArrayToFilterString = function(arr) {
            return filterArrayToEscapedFilterString(arr);
        };


        /**
         * Returns the language code from the BCP47 code
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @param bcp47Code Code to convert
         * @instance
         * @returns {string}
         * @example
         * getLanguageFromBcp47Code('en') returns 'ENU'
         * getLanguageFromBcp47Code('de') returns 'DEU'
         */
        this.getLanguageFromBcp47Code = function(bcp47Code) {
            return BCP47ToUPILanguageCode[bcp47Code] || 'ENU';
        };


        /**
         * Utility function to help highlighting
         *  Replaces the characters "\uE000" and "\uE001" w/ HTML <em>highlighted</em> or given tags. Sanitizes any HTML tags in the input string. Replaces null & undefined w/ an empty string. Casts non-strings as strings.
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @param {string} str String to sanitize
         * @param {string} replaceStart - string to match for the beginning of the string to replace
         * @param {string} replaceEnd - string to match for the beginning of the string to replace
         * @returns {string}
         * @example
         * var sanitizedResult = qsAPI.sanitizeAndHighlightString('We just found \uE000something\uE001', '<em class="highlight">', '</em>');
         * will result in
         * sanitizedResult === 'We just found <em class="highlight">something</em>';
        **/
        this.sanitizeAndHighlightString = function(str, replaceStart, replaceEnd) {
            var returnStr, dom, isHighlighted=false;

            if (!str) { return ''; }

            replaceStart = replaceStart||"<em class='highlight'>";
            replaceEnd = replaceEnd||"</em>";

            dom = document.createElement('div');
            dom.textContent = str;
            returnStr = dom.innerHTML;
            returnStr = returnStr.replace(/[\uE000\uE001]/g, function(token, position, tmpStr){
                if (token === '\uE000' && !isHighlighted) { isHighlighted = true; return replaceStart; }
                else if (token === '\uE001' && isHighlighted) { isHighlighted = false; return replaceEnd; }
                else { console.warn("Warning: Incorrect number of highlight tokens in string: " + str); }
            });
            if (isHighlighted) { returnStr += replaceEnd; console.warn("Warning: Incorrect number of highlight tokens in string: " + str); }
            return returnStr;
        };

        /**
         * Utility function to convert highlighted strings to plain strings
         *  Removes the characters "\uE000" and "\uE001". Replaces null & undefined w/ an empty string. Casts non-strings as strings.
         * @function
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @param str
         * @returns {string}
         * @example
         * var plainString = qsAPI.removeHighlightTokens('We just found \uE000something\uE001');
         * will result in
         * plainString === 'We just found something';
        **/
        this.removeHighlightTokens = function(str) {
            if (!str) { return ''; }
            str = str.replace(/[\uE000\uE001]/g, '');
            return str;
        };

        /**
         * Returns the list of search results that can be found for a search term. The result are returned through the callback {queryCb}
         *
         * @function query
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {QueryParameterType} queryParams - The parameters needed to call the search query
         * @param {SessionInfoType} sessionInfo - The session information for the query: clientId, clientFeatureId, sessionId and oxygen user token (if user data needs to be searched)
         * @param {SearchAjaxCallback} cb - Callback called on completion of the search query: cb(err, data).
         */
        this.query = function (queryParams, sessionInfo, cb) {
            var queryURL, sent;

            // TODO(jwo): either freeze queryParams & sessionInfo, or copy it (can't trust the client no not modify it)

            var queryParamsErr = validateParameters(queryParams);
            if (queryParamsErr) {
                console.error("Invalid Query Parameters for the Query Service REST API - " + queryParamsErr);
                setTimeout(function() { cb("Invalid Query Parameters for the Query Service REST API - " + queryParamsErr, null); }, 0);
                return;
            }

            queryURL = composeQueryURL(searchEndPoint + SearchQueryAPIs.Query, queryParams);
            // console.debug('Search Query URL: ' + queryURL);

            var headers = sessionInfoToHeaders(sessionInfo);
            var headerErr = validateHeaders(headers);
            if (headerErr) {
                console.error("Invalid Request Headers for the Query Service REST API - " + headerErr);
                setTimeout(function() { cb("Invalid Request Headers for the Query Service REST API - " + headerErr, null); }, 0);
                return;
            }

            ajaxReq(queryURL, headers, function(err, data) {
                if (!err && data) {
                    addClickLoggingCallbacksToSERP(data.queryId, sessionInfo, data);
                    deepFreeze(data); // Disallow modification of data needed by click logging
                    pagePerformanceLogger(data.queryId, sessionInfo); // Log (only once) how long the page load time took
                    setLoggerLastQueryInfo(data.queryId, sessionInfo);
                }
                cb(err, data); return;
            });
        };

        /**
         * Returns the list of categories that can be found for a search term. The categories are returned through the callback {categoriesCb}
         *
         * @function findCategories
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {QueryParameterType} queryParams - The parameters needed to call the query
         * @param {SessionInfoType} sessionInfo - The session information for the query: clientId, clientFeatureId, sessionId and oxygen user token (if user data needs to be searched)
         * @param {SearchAjaxCallback} cb - Callback called on success of the categories query: cb(err, data)
         **/
        this.findCategories = function(queryParams, sessionInfo, cb) {
            var queryURL;

            var queryParamsErr = validateParameters(queryParams);
            if (queryParamsErr) {
                console.error("Invalid Query Parameters for the Query Service REST API - " + queryParamsErr);
                setTimeout(function() { cb("Invalid Query Parameters for the Query Service REST API - " + queryParamsErr, null); }, 0);
                return;
            }

            queryURL = composeQueryURL(searchEndPoint + SearchQueryAPIs.Categories, queryParams);
            // console.debug('Categories Query URL: ' + queryURL);

            var headers = sessionInfoToHeaders(sessionInfo);
            var headerErr = validateHeaders(headers);
            if (headerErr) {
                console.error("Invalid Request Headers for the Query Service REST API - " + headerErr);
                setTimeout(function() { cb("Invalid Query Parameters for the Query Service REST API - " + headerErr, null); }, 0);
                return;
            }

            ajaxReq(queryURL, headers, cb);
        };

        /**
         * Returns the list of suggestions that can be found for a search term. The categories are returned through the callback {suggestionsCb}
         *
         * @function suggest
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {QueryParameterType} queryParams - The parameters needed to call the suggestions query
         * @param {SessionInfoType} sessionInfo - The session information for the query: clientId, clientFeatureId, sessionId and oxygen user token (if user data needs to be searched)
         * @param {SearchAjaxCallback} cb - Callback called on success of the suggestions query: cb(err, data)
         */
         this.suggestionTimeoutId = null;
         this.lastSentSuggestionNum = -1;
         this.lastDisplayedSuggestionNum = -1;
         this.suggest = function (queryParams, sessionInfo, cb) {
            var suggestFn = function(queryParams, sessionInfo, cb) {
                var queryURL, suggestionNum;

                var queryParamsErr = validateParameters(queryParams);
                if (queryParamsErr) {
                    console.error("Invalid Request Parameters for the Query Service REST API - " + queryParamsErr);
                    setTimeout(function() { cb("Invalid Request Parameters for the Query Service REST API - " + queryParamsErr, null); }, 0);
                    return;
                }

                suggestionNum = _this.lastSentSuggestionNum + 1;
                _this.lastSentSuggestionNum = suggestionNum;

                queryURL = composeQueryURL(searchEndPoint + SearchQueryAPIs.Suggestions, queryParams);
                // console.debug('Suggestion Query URL: ' + queryURL);

                var headers = sessionInfoToHeaders(sessionInfo);
                var headerErr = validateHeaders(headers);
                if (headerErr) {
                    console.error("Invalid Request Headers for the Query Service REST API - " + headerErr);
                    setTimeout(function() { cb("Invalid Request Headers for the Query Service REST API - " + headerErr, null); }, 0);
                    return;
                }

                var cbInner = function(err, data) {
                    // Only display newer results than currently displayed result
                    if (suggestionNum > _this.lastDisplayedSuggestionNum) {
                        _this.lastDisplayedSuggestionNum = suggestionNum;
                        if (!err) {
                            addClickLoggingCallbacksToSuggestions(data.queryId, sessionInfo, data);
                            pagePerformanceLogger(data.queryId, sessionInfo); // Log (only once) how long the page load time took
                            setLoggerLastQueryInfo(data.queryId, sessionInfo);
                        }
                        cb(err, data); return;
                    }
                };

                ajaxReq(queryURL, headers, cbInner);
            };

            clearTimeout(_this.suggestionTimeoutId);
            _this.suggestionTimeoutId = setTimeout(function() {
                suggestFn(queryParams, sessionInfo, cb);
            }, suggestionDelay);

        };

        /**
         * Logs a query event
         *
         * @function logEvent
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {string} queryId - unique id of the query returned in the query results
         * @param {SessionInfoType} sessionInfo - The session information for the query: clientId, clientFeatureId, sessionId and oxygen user id if available (if user data needs to be searched). This helps optimize future searches.
         * @param {string} type - type of log entry, for example 'info', 'error', or event type
         * @param {string} body - log message
         * @param {SearchAjaxCallback} cb - log message
         */
        this.logEvent = logEvent; // Shared public & private


        /**
         * Returns the version info for the Query Service REST API as well as some basic health data.
         * The info is returned through the callbacks passed through the parameters
         *
         * @function queryServiceInfo
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {SessionInfoType} sessionInfo - The session information for the query: clientId, clientFeatureId, sessionId and oxygen user token (if user data needs to be searched)
         * @param {SearchAjaxCallback} cb: cb(err, data)
         */
        this.queryServiceInfo = function(sessionInfo, cb) {
            var queryHealthURL = searchEndPoint + SearchQueryAPIs.Health;
            // console.debug('Health Query URL: ' + queryHealthURL);

            var headers = sessionInfoToHeaders(sessionInfo);
            var headerErr = validateHeaders(headers);
            if (headerErr) {
                console.error("Invalid Request Headers for the Query Service REST API - " + headerErr);
                setTimeout(function() { cb("Invalid Request Headers for the Query Service REST API - " + headerErr, null); }, 0);
                return;
            }

            var localCb = function(err, data) {
                var minRestApiVersionSplit, remoteRestApiVersionSplit, i=0, versionErr=false;

                // Check the API version vs. local required version
                minRestApiVersionSplit = versionInfo.minRestApiVersion.split('.').map(function(a){ return parseFloat(a); });
                if (!err && data.versionInfo && data.versionInfo.version) {
                    remoteRestApiVersionSplit = data.versionInfo.version.split('.').map(function(a){ return parseFloat(a); });
                    while (i < remoteRestApiVersionSplit.length || i < minRestApiVersionSplit.length) {
                        versionErr = versionErr || (minRestApiVersionSplit[i]||0) > (remoteRestApiVersionSplit[i]||0);
                        i = i + 1;
                    }
                    if (versionErr) { console.error('Error: Remote API version (' + data.versionInfo.version + ') is older than required (' + versionInfo.minRestApiVersion + ')'); }
                }

                cb(err, data); return;
            };

            ajaxReq(queryHealthURL, headers, localCb);
        };


        /**
         * Serializes the passed URL encoded query parameters
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/History}
         * @example The query parameters of
         * {
         *     pid: 1,                           // profile id
         *     query: 'fox',                     // query string
         *     sort: 'dateDescending',
         *     page: 1,
         *     filters: 'content.name:dog|creator.userIdValue:uid2'
         * }
         * turn into the query
         * [apiurl]/qs/v2/search?pid=1&query=fox&filters=content.name%3Adog%7Ccreator.userIdValue%3Auid2&sort=dateDescending&page=1
         * and it gets serialized into the main window.location like this:
         * [windowsurl]/[path]?adqs=pid%3D1%26query%3Dfox%26filters%3Dcontent.name%253Adog%257Ccreator.userIdValue%253Auid2%26sort%3DdateDescending%26page%3D1
         *
         * @function queryParamsToUrl
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {QueryParameterType} queryParams - The parameters needed to call a query
         * @param {string} loc - Url of the current window/frame location
         * @param {History} history - History object where the new state can be serialized
         * @param {string?} prefix - Url of the current window/frame location
         *
         * @returns {boolean} True if success, false if there was a problem assigning the search parameters to the URL
         */
        this.queryParamsToUrl = function(queryParams, loc, history, prefix) {
            var url;

            // TODO(jwc): Make sure that the original URL parameters are preserved, for example: examples/?testing=the_url&more=testing#someOtherStuffHere
            if (!loc || !history || !history.pushState) {
                console.error("queryParamsToUrl() requres a History object in the urlLocation parameter such as window.history.");
                return false;
            }

            url = new URL(loc);
            url.search = new URL(composeQueryURL(searchEndPoint + SearchQueryAPIs.Query, queryParams)).search;

            try {
                history.pushState(null, '', url);
            } catch (err) {
                // Fallback to using the #HASH portion of the URL
                document.location.hash = url.search;
            }

            return true;
        };


        /**
         * Serializes the passed query parameters from the passed url
         *
         * @function readUrlParameters
         * @memberof Autodesk.Search.SearchQueryAPI.prototype
         * @instance
         * @param {Location} urlLocation
         * @returns {QueryParameterType} - The parameters needed to call the suggestions query
         */
        this.urlParametersToQueryParams = function(loc) {
            var queryParams = {
                pid: undefined,
                query: null,
                modifier: null,
                filters: '',
                sort: '',
                page: 1,
                language: '',
                oauth2Token: null,
                env: null,
            };

            var ignoredParams = {
                pid: 1, // we don't overwrite pid
            };

            var paramMap = {
                access_token: 'oauth2Token',
                expires_in: 'oauth2TokenExpiresIn',
            };

            var url = new URL(loc);
            var urlSearchAndHash = (url.search||'').slice(1) + '&' + (url.hash||'').slice(1);
            var arrParams = parseUrlParams(urlSearchAndHash);
            arrParams.forEach(function(p) {
                if (typeof queryParams[p[0]] !== undefined && !ignoredParams[p[0]]) {
                    queryParams[(paramMap[p[0]] || p[0])] = p[1];
                }
            });

            return queryParams;
        };


    }

    SearchQueryAPI.prototype.constructor = SearchQueryAPI;

    ns.SearchQueryAPI = SearchQueryAPI;

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function() {
    'use strict';

    var viewerNameSpace = Autodesk.Viewing;
    var viewUINameSpace = Autodesk.Viewing.UI;
	var viewPrivateNameSpace = Autodesk.Viewing.Private;
    var viewerSearchNameSpace = new AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    /* CONSTANTS*/
    var IN_VIEWER_SEARCH_THIS_VIEW_ID = 'in-viewer-search-this-view';
    var IN_VIEWER_SEARCH_THIS_ITEM_ID = 'in-viewer-search-this-item';
    var IN_VIEWER_SEARCH_THIS_PROJECT_ID = 'in-viewer-search-this-project';
    var SEARCHBAR_ID = 'in-viewer-search-bar';
    var RECENT_SEARCHES_KEY = 'recentSearches';
    var THRESHOLD_SEARCH_AS_YOU_TYPE = 3;
    var SEARCH_TIMEOUT = 200;

    var node = null; //this is a variable used for the UI mode
    var searchTimer = null;

    var KEY_CODES = Object.freeze({
        BACKSPACE: 8,
        SPACE: 32,
        ENTER: 13,
    });

/*************** INNER FUNCTIONS ***********************************/

    function initializeSearchTabs(self, currentGeometry, tabInitializedCallback) {
        var is2D = self.viewer.model.myData.is2d;

        if (self.inViewerSearchThisView) {
            self.inViewerSearchThisView.initialize(self.qsApiService, self.viewerProperties, currentGeometry, is2D, self.thisViewDom || IN_VIEWER_SEARCH_THIS_VIEW_ID, tabInitializedCallback);
        }

        if (self.inViewerSearchThisItem && !self.inViewerSearchThisItem.initialized) {
            self.inViewerSearchThisItem.initialize(self.qsApiService, self.viewerProperties, currentGeometry, self.thisItemDom || IN_VIEWER_SEARCH_THIS_ITEM_ID, tabInitializedCallback, function(nodeId) {
                self.changeToThisViewTabAndSelectNode(nodeId);
            });
        }

        if (self.inViewerSearchThisProject) {
            self.inViewerSearchThisProject.initialize(self.qsApiService, self.thisProjectDom || IN_VIEWER_SEARCH_THIS_PROJECT_ID);
        }
    }

    function checkIfLoadingRelatedGeometry(self) {
        var data = self.cacheObj().searchInfoThisItem;
        if (data) {
            repeatSearch(self, data.str, data.node);
            if (self.inViewerSearchPanel) {
                self.inViewerSearchPanel.setVisible(true);
                enableSearchButton(self);
            }
            self.cacheObj.searchInfoThisItem = null;
        }
    }

    function getSharedPropertyDbPath(bubbleData) {
        var sharedDb = null;

        bubbleData.children.forEach(function(child) {
            if (child.hasOwnProperty('sharedPropertyDbPath')) {
                sharedDb = child.sharedPropertyDbPath;
            }
        });

        return sharedDb;
    }

    function getDocumentRoot(bubbleData) {

        if (!bubbleData.parent) {
            return bubbleData;
        } else {
            return getDocumentRoot(bubbleData.parent);
        }
    }

    function tryJsonParse(jsonText) {
        var json = null;

        try {
            json = JSON.parse(jsonText);
        } catch(err) {
            console.error('JSON parse error: ' + err);
        }

        return json;
    }

    function getGeometries(self, viewer, callback) {
        var docNode = viewer.model.getDocumentNode();
        var bubbleData = (docNode ? viewer.model.getDocumentNode().parent : null);

        if (bubbleData) {
            var root = getDocumentRoot(bubbleData);
            setTimeout(function() {callback(root);}, 0); return; // Explicitly move cb to async
        } else {
            self.noBubbleData = true;
            if(self.inViewerSearchThisItem){
                delete self.inViewerSearchThisItem;
                self.inViewerSearchThisItem = null;
            }

            viewPrivateNameSpace.logger.warn('InViewerSearch Extension: no ViewingApplication is being used so relatedItemsTab will not be visible');
            setTimeout(function() {callback(null);}, 0); return; // Explicitly move cb to async
        }
    }

    function enableSearchButton(self) {
        var visible;

        if (self.options.uiEnabled && self.searchToolButton && self.inViewerSearchPanel) {
            visible = self.inViewerSearchPanel.isVisible();
            self.searchToolButton.setState(visible ? viewUINameSpace.Button.State.ACTIVE : viewUINameSpace.Button.State.INACTIVE);
            self.searchToolButton.setToolTip(viewerNameSpace.i18n.translate('Search'));
        }
    }

    /**
     * Initializes the services and logic
     *
     * @param  {function} cb - will be called after initialize
     */
   	function initialize(self, cb) {
        var viewer = self.viewer;
        var allInitialized = {};
        var environment = viewPrivateNameSpace.env;
        var currentGeometry = viewPrivateNameSpace.docItemId;
        var viewerUrl = viewerNameSpace.getViewingUrl();
        var loading = self.cacheObj().searchInfoThisItem;
        self.showingTabs = false;

        var onTabInitialized = function(id, init) {
            var done;

            allInitialized[id] = init;

            // Check if any id is not initialized
            done = Object.keys(allInitialized).every(function(a) { return !!allInitialized[a]; });

            if (done) {
                self.initialized = true;
                cb(true); // TODO(jwo): Can the callback after checkIfLoadingRelatedGeometry? Generally cb() is followed immediately by a return statement
                checkIfLoadingRelatedGeometry(self);

            } else if (allInitialized[IN_VIEWER_SEARCH_THIS_VIEW_ID]) { // if This View is already loaded and not returning from this item tab, we can enable the button
                if (!loading) {
                    enableSearchButton(self);
                }

            }
        };

        var onGetGeometriesDone = function(bubbleData){
            var flatGUIDS = {};
            var sharedPropertyDBPath = '';
            var modelSize;

            if (bubbleData){
                // Named function as it's called recursively
                var getFlatGeometries = function(node) {
                    var children = node.children || [];
                    var that = this;
                    children.forEach(function (child) {
                        if (!flatGUIDS[child.data.guid]) {
                            switch (child.data.type) {
                                case 'geometry':
                                    flatGUIDS[child.data.guid] = child;
                                    break;

                                case 'folder':
                                    getFlatGeometries.call(that, child);
                                    break;
                            }
                        }
                    });
                };

                getFlatGeometries(bubbleData);
                sharedPropertyDBPath = getSharedPropertyDbPath(bubbleData);
            }

            self.flatGUIDS = flatGUIDS;

            viewPrivateNameSpace.logger.debug('InViewerSearchExtension - has sharedPropertyDBPath: ' + sharedPropertyDBPath);

            if (self.qsApiService) {
                var modelInfo = { count: {} };
                modelSize = 0;

                Object.keys(flatGUIDS).forEach(function(key) {
                    if (flatGUIDS[key].data) {
                        modelSize += (flatGUIDS[key].data.size) ? flatGUIDS[key].data.size : 0;
                        if (flatGUIDS[key].data.role) {
                            modelInfo.count[flatGUIDS[key].data.role] = modelInfo.count[flatGUIDS[key].data.role] + 1 || 1;
                        }
                    }
                });
                modelInfo.size = modelSize;

                var global = av.getGlobal();
                var viewerBuildId = global.LMV_VIEWER_VERSION + '.' + global.LMV_VIEWER_PATCH;

                self.qsApiService.initialize(viewerBuildId, environment, self.options.clientId, self.options.sessionId);
                self.qsApiService.logInitEvent(self.viewer.model.myData.urn, modelInfo, "");
            }

            if (self.viewerProperties && !self.viewerProperties.initialized) {
                self.viewerProperties.initialize(self.viewer, self.noBubbleData, viewerUrl, self.flatGUIDS, currentGeometry, self.qsApiService, sharedPropertyDBPath);
            }

            //initializeTabs
            allInitialized[IN_VIEWER_SEARCH_THIS_VIEW_ID] = false;
            if (self.inViewerSearchThisItem) {
                allInitialized[IN_VIEWER_SEARCH_THIS_ITEM_ID] = self.inViewerSearchThisItem.initialized;
            }

            if (self.options.uiEnabled && !self.initialized) {
                self.createTabs();
            }

            initializeSearchTabs(self, currentGeometry, onTabInitialized);
        };

        getGeometries(self, viewer, onGetGeometriesDone);
    }

    function repeatSearch(self, str, dbId) {
        var searchBar = self.searchBarElem;

        if (str) {
            searchBar.value = str;
            self.uiSearch(dbId);
            self.updateRecentSearches(str);
        }
    }

    function recentSearchItem(self, string) {
        var itemDom = document.createElement('li');

        itemDom.className = 'recent-item';
        itemDom.appendChild(document.createTextNode(string));
        itemDom.addEventListener('click', function(/*event*/) { repeatSearch(self, this.innerText); }, false);

        return itemDom;
    }

    function createRecentSearchesUI(self, container) {
        var labelDom, listDom, recentList, itemDom;

        labelDom = document.createElement('label');
        labelDom.className = 'recent-label';
        labelDom.appendChild(document.createTextNode(viewerNameSpace.i18n.translate('Recent Searches')));

        listDom = document.createElement('ul');
        listDom.className = 'recent-searches-list dockingPanelScroll';

        recentList = self.getRecentSearches();
        recentList.forEach(function(item) {
            listDom.appendChild(recentSearchItem(self, item));
        });

        if (recentList.length < 1) {
            itemDom = document.createElement('li');
            itemDom.className = 'recent-item empty-list';
            itemDom.appendChild(document.createTextNode(viewerNameSpace.i18n.translate('Recent Searches Empty')));
            listDom.appendChild(itemDom);
        }

        container.appendChild(labelDom);
        container.appendChild(listDom);
    }

    /**
     *
     * @param tab - selected tab element
     * @param contentId
     */
    function selectClickTab(self, tab, contentId, tabId) {
        var contentWrapper, contents;
        var tabs = [].slice.call(tab.parentElement.children);

        // Unselect all tabs
        tabs.forEach(function(tabDom) { tabDom.classList.remove('selected'); });

        // Select current tab
        tab.classList.add('selected');

        self.qsApiService.logTabClickEvent(tabId);

        // TODO(jwo): this is fragile; indexing into the children directly should be a selector instead.
        // Perhaps should be: contentWrapper = tab.parentElement.parentElement.getElementsByClassName('???')[0]; to make it less fragile
        contentWrapper = tab.parentElement.parentElement.children[1]; //tab-content;

        contents = [].slice.call(contentWrapper.children);

        // Unhide contentId & hide others
        contents.forEach(function(contDom) {
            if (contDom.id === contentId) { contDom.classList.remove('hidden'); }
            else { contDom.classList.add('hidden'); }
        });
    }

    function createTabItem(self, contentId, tabClass, name, tabId) {
        var itemDom, labelDom;

        itemDom = document.createElement('div');
        itemDom.className = 'tab-item ' + tabClass;
        itemDom.addEventListener('click', function() { selectClickTab(self, this, contentId, tabId); }, false);

        labelDom = document.createElement('label');
        labelDom.appendChild(document.createTextNode(name)); // TODO(go) - 20160522: viewerNameSpace.i18n.translate(name) -- or even sooner;
        itemDom.appendChild(labelDom);

        return itemDom;
    }

    function createTabsHTML(containerDom, self) {
        var tabItemsContainerDom, tabContentDom, thisViewDom, thisItemDom, thisProjectDom, count;

        count = 1;

        tabItemsContainerDom =  document.createElement('div');

        tabContentDom = document.createElement('div');
        tabContentDom.className = 'tab-content';
        tabItemsContainerDom.appendChild(createTabItem(self, IN_VIEWER_SEARCH_THIS_VIEW_ID, 'this-view selected', self.options.loadedModelTab.displayName, 'thisView'));

        thisViewDom = document.createElement('div');
        thisViewDom.id = IN_VIEWER_SEARCH_THIS_VIEW_ID;
        self.thisViewDom = thisViewDom;
        tabContentDom.appendChild(thisViewDom);

        if (self.options.relatedItemsTab.enabled && self.inViewerSearchThisItem) {
            count++;
            tabItemsContainerDom.appendChild(createTabItem(self, IN_VIEWER_SEARCH_THIS_ITEM_ID, 'this-item', self.options.relatedItemsTab.displayName, 'thisItem'));

            thisItemDom = document.createElement('div');
            thisItemDom.className = 'hidden';
            thisItemDom.id = IN_VIEWER_SEARCH_THIS_ITEM_ID;
            self.thisItemDom = thisItemDom;
            tabContentDom.appendChild(thisItemDom);
        }

        if (self.options.serverSearchTab.enabled) {
            count++;
            tabItemsContainerDom.appendChild(createTabItem(self, IN_VIEWER_SEARCH_THIS_PROJECT_ID, 'this-project', self.options.serverSearchTab.displayName, 'thisProject'));

            thisProjectDom = document.createElement('div');
            thisProjectDom.className = 'hidden';
            thisProjectDom.id = IN_VIEWER_SEARCH_THIS_PROJECT_ID;
            self.thisProjectDom = thisProjectDom;
            tabContentDom.appendChild(thisProjectDom);
        }

        tabItemsContainerDom.className = 'tab-items tabs-count-' + count;

        containerDom.appendChild(tabItemsContainerDom);
        containerDom.appendChild(tabContentDom);
        self.tabContent = tabContentDom;
    }

/***************** END INNER FUNCTIONS **********************************/

    /**
     * InViewerSearchMain
     */
    viewerSearchNameSpace.InViewerSearchMain = function(viewer, options, cache) {

        this.initialized = false;

        this.cacheObj = cache;

        this.viewer = viewer;
        this.toolbarTools = null;

        this.options = options;
        this.qsApiService = new viewerSearchNameSpace.QsApiService();
        this.viewerProperties = new viewerSearchNameSpace.ViewerPropertiesService(viewer);
        this.noBubbleData = false;
        this.inViewerSearchPanel = null;

        this.inViewerSearchThisView = null;
        this.inViewerSearchThisItem = null;
        this.inViewerSearchThisProject = null;

        this.geometryLoadedCallback = null;

        this.tabsElem = null;
        this.searchBarElem = null;
        this.recentSearchesElem = null;

        this.saveLastQuery = null;
        this.recentSearches = null;
        this.flatGUIDS = {};
        this.container = null;        //inViewerSearch html container
        this.searchToolButton = null;
        this.tabContent = null;
        this.showingTabs = false;
        this.initCb = null;

        this.closeCallback = null;

        this.workersScriptsInitialized = false;
        this.initWorkersScripts = null;

        this.thisProjectDom = null;
        this.thisItemDom = null;
        this.thisViewDom = null;
    };

    viewerSearchNameSpace.InViewerSearchMain.prototype.constructor = viewerSearchNameSpace.InViewerSearchMain;

    /**
     * Loads the extension
     *
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.load = function() {
        var self = this;
        var viewer = this.viewer;

        var allTabsLoaded = !!(this.options && this.options.loadedModelTab && this.options.relatedItemsTab && this.options.serverSearchTab);
        var atleastOneTabEnabled = allTabsLoaded && (this.options.loadedModelTab.enabled || this.options.relatedItemsTab.enabled || this.options.serverSearchTab.enabled);

        if (!atleastOneTabEnabled) {
            viewPrivateNameSpace.logger.log('InViewerSearch Extension - all search types disabled, nothing to do.');
            return false;
        }

        //load worker scripts
        viewerSearchNameSpace.WorkerUtils.initInViewerSearchWorkersScripts(function(){
            self.workersScriptsInitialized = true;
            if (self.initWorkersScripts) {
                self.initWorkersScripts();
            }
            viewPrivateNameSpace.logger.info("InViewerSearch Extension: workers fetched.");
        }, function(){
            viewPrivateNameSpace.logger.warn("InViewerSearch Extension: error fetching workers.");
        });

        if (this.options.loadedModelTab.enabled && !this.inViewerSearchThisView) {
            this.inViewerSearchThisView = new viewerSearchNameSpace.InViewerSearchThisView(viewer, this.options);
        }

        if (this.options.relatedItemsTab.enabled && !this.inViewerSearchThisItem) {
            this.inViewerSearchThisItem = new viewerSearchNameSpace.InViewerSearchThisItem(viewer, this.options, this.cacheObj);
        }

        if (this.options.serverSearchTab.enabled && !this.inViewerSearchThisProject) {
            this.inViewerSearchThisProject = new viewerSearchNameSpace.InViewerSearchThisProject(this.options);
        }

        if (this.options.uiEnabled && !this.inViewerSearchPanel) {
            this.inViewerSearchPanel = new viewerSearchNameSpace.InViewerSearchPanel(viewer, 'in-viewer-search', 'Search', this.options, this.qsApiService);
            this.container = this.inViewerSearchPanel.container;

            this.closeCallback = function() { self.closeSearch.call(self); };
            this.inViewerSearchPanel.addEventListener(this.inViewerSearchPanel.closer, 'click', this.closeCallback);
        }

        // Add the ui to the viewer.
        if (this.options.uiEnabled && !self.searchToolButton) {
            this.addToolbarUI();
        }

        this.onInitialized = function(initializationDone) {
            if (!initializationDone) {
                return;
            }

            self.initialized = true;
            enableSearchButton(self);

            if (self.initCb) {
                self.initCb();
            }
        };

        this.geometryLoadedCallback = function() {
            if (!self.workersScriptsInitialized) {
                self.initWorkersScripts = function() {
                    initialize(self, self.onInitialized);
                };
            } else {
                initialize(self, self.onInitialized);
            }
        };

        var onGeometryLoadedEvent = function(event){
            viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoadedEvent);
            viewer.getObjectTree(function(){
                self.geometryLoadedCallback();
            }, function() {
                viewPrivateNameSpace.logger.warn("InViewerSearch Extension - failed getObjectTree");
                self.geometryLoadedCallback();
            });
        };

        viewer.getObjectTree(function(){
            self.geometryLoadedCallback();
        }, function(){
            if(viewer.model && viewer.model.getData){
                var data = viewer.model.getData();
                if(data && data.hasOwnProperty('hasObjectProperties')){
                    //Case where there is no object tree, but objects
                    //do still have properties. This is the case for F2D drawings.
                    self.geometryLoadedCallback();
                }
            } else {
                viewer.addEventListener(viewerNameSpace.GEOMETRY_LOADED_EVENT, onGeometryLoadedEvent);
            }

        });

        return true;
    };

    /**
     * [UI ENABLED] Creates the UI for the extension
     *
     * @return {type}  description
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.addToolbarUI = function() {
        var searchToolButton;
        var self = this;
        var viewer = this.viewer;
        if (!viewer.getToolbar) { return; } // Adds support for Viewer3D instance
        var viewUINameSpace = Autodesk.Viewing.UI; // FIXME(jwo): This is also defined at the file level
        var toolbar = viewer.getToolbar(true);

        this.toolbarTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);

        // Create a button for the tool.
        searchToolButton = new viewUINameSpace.Button('toolbar-in-viewer-search');
        searchToolButton.setToolTip(viewerNameSpace.i18n.translate('Loading Search'));
        searchToolButton.setIcon('adsk-button-icon-search');
        searchToolButton.setState(viewUINameSpace.Button.State.DISABLED);

        searchToolButton.addEventListener('click', function(/*e*/) {
            if (self.inViewerSearchPanel) {
                var isVisible = self.inViewerSearchPanel.isVisible();
                self.qsApiService.logGeneralEvent(isVisible?'searchWindowClose':'searchWindowOpen');
                self.inViewerSearchPanel.setVisible(!isVisible);
                self.searchBarElem.focus();
            }
        }, false);

        searchToolButton.addClass('in-viewer-search-button');

        // Add visibility callback
        if (self.inViewerSearchPanel) {
            self.inViewerSearchPanel.addVisibilityListener(function(visible) {
                searchToolButton.setState(visible ? viewUINameSpace.Button.State.ACTIVE : viewUINameSpace.Button.State.INACTIVE);
            });
        }

        self.searchToolButton = searchToolButton;

        self.toolbarTools.addControl(searchToolButton);
    };

    /**
     * Unloads the extension -- disabling for test
     *
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.unload = function() {

        this.initialized = false;

        if (this.options.uiEnabled) {
            this.closeSearch();

            if (this.toolbarTools) {
                this.toolbarTools.removeControl(this.searchToolButton);
            }

            var loading = this.cacheObj().searchInfoThisItem;
            if (loading) {
                this.viewer.getPropertyPanel(true).setVisible(false);
            }
        }

        if (this.options.uiEnabled && !this.options.saveExtensionStateEnabled) {
            if (this.searchBarElem) {
                this.inViewerSearchPanel.scrollContainer.removeChild(this.searchBarElem);
            }

            if (this.recentSearchesElem) {
                this.inViewerSearchPanel.scrollContainer.removeChild(this.recentSearchesElem);
            }

            if (this.tabsElem) {
                this.inViewerSearchPanel.scrollContainer.removeChild(this.tabsElem);
            }

            this.inViewerSearchPanel.removeEventListener(this.inViewerSearchPanel.closer, 'click', this.closeCallback);
        }

        if (this.geometryLoadedCallback) {
            this.viewer.removeEventListener(viewerNameSpace.GEOMETRY_LOADED_EVENT, this.geometryLoadedCallback);
        }

        if (this.inViewerSearchThisView && this.inViewerSearchThisView.initialized) {
            this.inViewerSearchThisView.uninitialize();
        }

        if (!this.options.saveExtensionStateEnabled) {
            if (this.inViewerSearchThisItem && this.inViewerSearchThisItem.initialized) {
                this.inViewerSearchThisItem.uninitialize();
            }

            if (this.inViewerSearchThisProject && this.inViewerSearchThisProject.initialized) {
                this.inViewerSearchThisProject.uninitialize();
            }
            if (this.inViewerSearchPanel) {
                this.inViewerSearchPanel.uninitialize();
            }
            this.viewerProperties.uninitialize();
        }

        delete this.searchToolButton;
        delete this.inViewerSearchThisView;
        if (this.options && !this.options.saveExtensionStateEnabled) {
            delete this.inViewerSearchThisItem;
            delete this.inViewerSearchThisProject;
            delete this.inViewerSearchPanel;
            delete this.qsApiService;
            delete this.viewerProperties;
        }

        return true;
    };

    /**
     * returns the recent searches saves in the browser local storage
     *
     * @return {string[]}  recent searches
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.getRecentSearches = function() {

        if (!this.recentSearches) {
            this.recentSearches = tryJsonParse(window.localStorage[RECENT_SEARCHES_KEY] || '[]');
        }

        return this.recentSearches;
    };

    /**
     * adds a new string to the recent searches list and save it to browser local storage
     *
     * @param  {string} str searched string
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.updateRecentSearches = function(str) {
        var self, index, emptyDom, listDom;

        if (str === null || str.length === 0) {
            return;
        }

        self = this;

        if (!this.recentSearches) {
            this.getRecentSearches();
        }

        index = this.recentSearches.indexOf(str);

        if (index === 0) {
            return;
        }

        listDom = this.recentSearchesElem.children[1];
        if (index > 0) {
            this.recentSearches.splice(index,1);
            listDom.removeChild(listDom.childNodes[index]);
            index = -1;
        }

        if (index < 0) {
            this.recentSearches = [str].concat(this.recentSearches.slice(0, 20));
            window.localStorage[RECENT_SEARCHES_KEY] = JSON.stringify(this.recentSearches);

            if (self.options.uiEnabled) {

                emptyDom = listDom.children[0];
                if (emptyDom.className.indexOf('empty-list') >= 0) {
                    emptyDom.parentNode.removeChild(emptyDom);
                }

                listDom.insertBefore(recentSearchItem(self, str), listDom.childNodes[0]);
            }
        }
    };


    /**
     * [UI ENABLED] hides the search panel and clean the search
     *
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.closeSearch = function() {
        var self = this;

        self.inViewerSearchPanel.setVisible(false);

        self.hideTabs();

        if (self.inViewerSearchThisView) {
            self.inViewerSearchThisView.clearSearchResults();
        }

        if (self.inViewerSearchThisItem) {
            self.inViewerSearchThisItem.clearSearch();
        }

        if (self.inViewerSearchThisProject) {
            self.inViewerSearchThisProject.clearSearch();
        }

        if (this.searchBarElem) {
            this.searchBarElem.value = "";
        }
    };

    /**
     * [UI ENABLED] helper to create the UI tabs
     *
     * @return {type}  description
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.createTabs = function() {
        if (!this.inViewerSearchPanel || !this.inViewerSearchPanel.scrollContainer) {
            return;
        }

        var recentSearchesDom;
        //var viewer = this.viewer;

        var self = this;
        var container = this.inViewerSearchPanel ? this.inViewerSearchPanel.scrollContainer: null;
        var searchBarDom;
        var tabsDom;
        var supportsSearch = "onsearch" in document.documentElement; //.hasOwnProperty doesn't work

        // If there was an existing search bar, exit and don't create a new one
        if (this.searchBarElem) {
            return;
        }

        searchBarDom = document.createElement('input');
        searchBarDom.className = 'in-viewer-search-bar';
        searchBarDom.id = 'in-viewer-search-bar';
        searchBarDom.type = 'search';

        if (this.options.searchPlaceholder) {
            searchBarDom.placeholder = this.options.searchPlaceholder;
        }



        searchBarDom.addEventListener('keyup', function(e) {
            var str = e.target.value.trim();
            var c = e.which || e.keyCode;
            if (!supportsSearch && c === KEY_CODES.ENTER) {
                //if onSearch is not supported we trigger the searchHander after enter.
                searchBarDom.onsearch(e);
            } else if (str && str.length >= THRESHOLD_SEARCH_AS_YOU_TYPE) {
                // TODO(jwo): What's the use of these high order keycodes?
                 if (c === KEY_CODES.BACKSPACE || c === KEY_CODES.SPACE || (c > 40 && c < 128) || (c > 185 && c < 193) || (c > 218 && c < 223)) {
                    clearTimeout(searchTimer);
                    searchTimer = setTimeout(function() {
                        self.saveLastQuery = false;
                        self.uiSearch();
                    }, SEARCH_TIMEOUT);
                }
            } else {
                self.hideTabs();
                self.inViewerSearchThisView.clearSearchResults();
            }
        });

        var searchHandler = function(e) {
            var str = e.target.value.trim();

            clearTimeout(searchTimer);

            if (!str) {
                self.hideTabs();
                self.inViewerSearchThisView.clearSearchResults();
            } else {
                searchTimer = setTimeout(function() {
                    self.saveLastQuery = true;
                    self.uiSearch();
                }, SEARCH_TIMEOUT);
            }
        };

        searchBarDom.onsearch = searchHandler;

        this.searchBarElem = searchBarDom;

        recentSearchesDom = document.createElement('div');
        recentSearchesDom.className = 'recent-searches';
        createRecentSearchesUI(self, recentSearchesDom);
        this.recentSearchesElem = recentSearchesDom;

        tabsDom = document.createElement('div');
        tabsDom.className = 'tabs-wrapper hidden';
        createTabsHTML(tabsDom, self);
        this.tabsElem = tabsDom;

        if (container) {
            container.appendChild(searchBarDom);
            this.searchBarElem.focus();
            container.appendChild(recentSearchesDom);
            container.appendChild(tabsDom);
        }

    };

    /**
     * calls the search algorithms that are enabled and call the calback functions
     * that apply after getting the results
     *
     * @param  {string} str                    - string to be searched
     * @param  {function} localSearchCb        - will be called with the local search results: function(SearchResultsType)
     * @param  {function} relatedItemsSearchCb - will be called with the related items search results: function(GeometriesSearchResultsType)
     * @param  {function} serverSearchCb       - will be called with the server search results: function(CategoriesSearchResultsType)
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.search = function(str, localSearchCb, relatedItemsSearchCb, serverSearchCb) {
        var strTrimmed = str.trim();

        if (strTrimmed) {
            this.qsApiService.generateQueryId();

            if (this.inViewerSearchThisView) {
                this.inViewerSearchThisView.search(strTrimmed, localSearchCb, node);
            }

            if (this.inViewerSearchThisItem) {
                this.inViewerSearchThisItem.search(strTrimmed, relatedItemsSearchCb);
            }

            if (this.inViewerSearchThisProject) {
                this.inViewerSearchThisProject.search(strTrimmed, serverSearchCb);
            }

            if (this.saveLastQuery) {
                this.updateRecentSearches(strTrimmed);
            }
        }
    };

    /**
     * [UI ENABLED] once the user enters a string and press enter search is triggered.
     *
     * @param  {number} nodeId - (optional)
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.uiSearch = function(nodeId) {
        var strBar = this.searchBarElem;
        var str = strBar.value.toLocaleLowerCase();

        node = nodeId;

        if (str) {
            this.showTabs();
            this.search(str);
        } else {
            this.hideTabs();
        }
    };

    /**
     * [UI ENABLED] shows the tabs UI
     *
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.showTabs = function() {
        var tabs, recentSearches;

        if (!this.showingTabs && this.options.loadedModelTab && this.options.loadedModelTab.enabled) {
            tabs = this.tabsElem;

            tabs.classList.remove('hidden');

            // TODO(jwo): Can we move from `tabs.firstChild.firstChild` to a selector `tabs.getElementsByClassName('???')[0]` to make this less fragile?
            selectClickTab(this, tabs.firstChild.firstChild, IN_VIEWER_SEARCH_THIS_VIEW_ID, 'thisView'); //starts this view tab selected

            recentSearches = this.recentSearchesElem;
            recentSearches.classList.add('hidden');
            this.showingTabs = true;
        }
    };

    viewerSearchNameSpace.InViewerSearchMain.prototype.changeToThisViewTabAndSelectNode = function(nodeid) {
        var tabs;

        if (!this.options.loadedModelTab || !this.options.loadedModelTab.enabled) {
            return;
        }

        tabs = this.tabsElem;

        // TODO(jwo): Can we move from `tabs.firstChild.firstChild` to a selector `tabs.getElementsByClassName('???')[0]` to make this less fragile?
        selectClickTab(this, tabs.firstChild.firstChild, IN_VIEWER_SEARCH_THIS_VIEW_ID, 'thisView'); //starts this view tab selected
        this.inViewerSearchThisView.selectNode(null, nodeid, true);
    };

    /**
     * [UI ENABLED] hides the tabs UI
     *
     */
    viewerSearchNameSpace.InViewerSearchMain.prototype.hideTabs = function() {

        if (this.showingTabs) {
            this.recentSearchesElem.classList.remove('hidden');

            this.tabsElem.classList.add('hidden');
            this.showingTabs = false;
            this.searchBarElem.focus();
        }
    };

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function() {
    'use strict';

    var viewerNameSpace = Autodesk.Viewing;
    //var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    //var viewUINameSpace = Autodesk.Viewing.UI;
    var viewerSearchNameSpace = new AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    var defaultOptions = {
        searchPlaceholder: "",
        uiEnabled: true,
        clientId: 'adsk.viewer.defaultClientId',
        sessionId: 'adsk.viewer.defaultSessionId',

        serverSearchTab: {
            enabled: false,
            displayName: 'This Project',
            // customize the following parameters for 'This Project' tab to work
            parameters: {
                pid: '',   // profile id
                filters: '',
                language: 'ENU',
                baseURL: '',
                urlCallback: ''
            },
            pageSize: 20
        },

        relatedItemsTab:{
            enabled: true,  //if false we hide the tab
            displayName: 'This Item',
            pageSize: 20
        },

        loadedModelTab: {
            enabled: true,  //if false we hide the tab
            displayName: 'This View',
            pageSize: 50
        }
    };


    /**
     * Extension that provides search capabilities.
     * The extension can be used as an API or directly thru the Viewer UI. The extension makes two types of search available:
     * - Loaded Model Search: searches into the property values of the geometry loaded in the viewer.
     * - Related Items Search: searches into the property values of all the geometries that belong to the document including the geometry loaded in the viewer.
     *
     * @example
     * // Load Extension
     * // example configuration object:
     * var options = {
     *     uiEnabled: true,
     *     clientId: 'adsk.viewer.defaultClientId',
     *     sessionId: 'adsk.viewer.defaultSessionId',
     *
     *     loadedModelTab: {
     *         enabled: true,
     *         displayName: 'This View',
     *         pageSize: 50
     *     },
     *
     *     relatedItemsTab: {
     *         enabled: true,
     *         displayName: 'This Item',
     *         pageSize: 20
     *     }
     * };
     *
     * viewer.loadExtension("Autodesk.InViewerSearch", options);
     *
     * //get Extension
     * var extension = viewer.getExtension("Autodesk.InViewerSearch");
     *
     * @constructor
     * @memberof Autodesk.Viewing.Extensions
     * @alias Autodesk.Viewing.Extensions.InViewerSearchExtension
     * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
     * @param {object} [options] - An optional dictionary of options for this extension.
     * @param {boolean} [options.uiEnabled] - A switch to enable UI. Default: true
     * @param {string} [options.clientId] - ID of the client application using the extension. Default: adsk.viewer.defaultClientId
     * @param {string} [options.sessionId] - ID that identifies a session which should be updated each time the extension is reloaded. Default: adsk.viewer.defaultSessionId
     * @param {boolean} [options.thresholdSearchMaxNodes] - Maximum number of nodes in the model that can be handled by the search extension. If exceeded, the search default to string match on Viewer's properties DB fields.
     * @param {boolean} [options.loadedModelTab.enabled] - A switch to enable loaded model tab. Default: true
     * @param {string} [options.loadedModelTab.displayName] - Name of loaded model tab. Default: This View
     * @param {number} [options.loadedModelTab.pageSize] - Number of results per page for loaded model tab. Default: 50
     * @param {boolean} [options.relatedItemsTab.enabled] - A switch to enable related items tab. Default: true
     * @param {string} [options.relatedItemsTab.displayName] - Name of related items tab. Default: This Item
     * @param {number} [options.relatedItemsTab.pageSize] - Number of results per page for related items tab. Default: 20
     * @category Extensions
     */
    viewerSearchNameSpace.InViewerSearchExtension = function(viewer, options) {
        var notHeadlessMode;

        viewerNameSpace.Extension.call(this, viewer, options);

        this.initialized = false;

        this.viewer = viewer;
        this.toolbarTools = null;

        // Make sure all options exist and are set up right, to at least the highest level
        // Doesn't protect from wrongly configured tabs
        if (!options) {
            options = {};
        }
        options.inViewerSearchConfig = options.inViewerSearchConfig || defaultOptions;
        this.options = options.inViewerSearchConfig;

        //case viewer headless uiEnabled is always false!
        notHeadlessMode = Autodesk.Viewing.Private.GuiViewer3D && viewer instanceof Autodesk.Viewing.Private.GuiViewer3D;
        this.options.uiEnabled = notHeadlessMode && ((this.options.uiEnabled === undefined) ? defaultOptions.uiEnabled : this.options.uiEnabled);
        this.options.serverSearchTab = this.options.serverSearchTab || defaultOptions.serverSearchTab;
        this.options.relatedItemsTab = this.options.relatedItemsTab || defaultOptions.relatedItemsTab;
        this.options.loadedModelTab = this.options.loadedModelTab || defaultOptions.loadedModelTab;

        // Options could exist without display name field properly configured. Use the default name in such case.
        this.options.serverSearchTab.displayName = this.options.serverSearchTab.displayName || defaultOptions.serverSearchTab.displayName;
        this.options.relatedItemsTab.displayName = this.options.relatedItemsTab.displayName || defaultOptions.relatedItemsTab.displayName;
        this.options.loadedModelTab.displayName = this.options.loadedModelTab.displayName || defaultOptions.loadedModelTab.displayName;

        if (!this.options.initialized) {
            this.inViewerSearchMain = new viewerSearchNameSpace.InViewerSearchMain(this.viewer, this.options, this.getCache);
        }
     };

    viewerSearchNameSpace.InViewerSearchExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
    viewerSearchNameSpace.InViewerSearchExtension.prototype.constructor = viewerSearchNameSpace.InViewerSearchExtension;

    /**
     * @private
     * Autodesk.Viewing.Extensions.InViewerSearch functions
     *
     */
    viewerSearchNameSpace.InViewerSearchExtension.prototype.getInViewerSearch = function() {

        return this.inViewerSearchMain;
    };


    /**
     * Autodesk.Viewing.Extension functions
     *
     */

     /**
      * Loads the search extension
      *
      * @return {boolean} True if measure extension is loaded successfully.
      */
    viewerSearchNameSpace.InViewerSearchExtension.prototype.load = function() {
        if (this.options.initialized && this.options.inViewerSearchMain) {
            this.inViewerSearchMain = this.options.inViewerSearchMain;
        }

        this.inViewerSearchMain.load();

        if (this.options.saveExtensionStateEnabled) {
            this.options.inViewerSearchMain = this.inViewerSearchMain;
            this.options.initialized = true;
        }

        return true;
    };

    /**
     * Unloads the search extension -- disabling for test
     *
     * @return {boolean} True if measure extension is unloaded successfully.
     */
    viewerSearchNameSpace.InViewerSearchExtension.prototype.unload = function() {
        this.inViewerSearchMain.unload();

        if (!this.options.saveExtensionStateEnabled) {     // Do not save state
            delete this.inViewerSearchMain;
            this.inViewerSearchMain = null;
            this.options.initialized = false;
            this.options.inViewerSearchMain = null;
        }

        return true;
    };

    /**
     * Adds a listener to the init event, after the extension initialized callback will be called.
     * If already initialized, will call callback.
     *
     * @param {function} cb - Method that gets called after init
     */
    viewerSearchNameSpace.InViewerSearchExtension.prototype.addInitListener = function(cb) {

        if (this.inViewerSearchMain && this.inViewerSearchMain.initialized) {
            setTimeout(function() { cb(); return; }, 0); // Explicitly move cb() to async
        } else {
            this.inViewerSearchMain.initCb = cb;
        }
    };


    Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.InViewerSearch', viewerSearchNameSpace.InViewerSearchExtension);

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function() {

    'use strict';

    //var viewerNameSpace  = Autodesk.Viewing;
    //var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    //var viewerPrivateNameSpace = Autodesk.Viewing.Private;
    var viewUINameSpace = Autodesk.Viewing.UI;
    var viewerSearchNameSpace = AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    /**
     * InViewerSearchPanel
     * Sets the model structure panel for displaying the loaded model.
     * @class
     * @augments Autodesk.Viewing.UI.DockingPanel
     *
     * @param {HTMLElement} parentContainer - The container for this panel.
     * @param {string} id - The id for this panel.
     * @param {string} title - The initial title for this panel.
     * @param {Object} [options] - An optional dictionary of options.
     * @param {boolean} [options.startCollapsed=true] - When true, collapses all of the nodes under the root.
     * @constructor
     */
    viewerSearchNameSpace.InViewerSearchPanel = function(viewer, id, title, options, qsApiService) {
        var that = this;

        this.viewer = viewer;
        this.qsApiService = qsApiService;

        viewUINameSpace.DockingPanel.call(this, viewer.container, id, title, options);

        this.container.classList.add('inViewerSearchPanel');

        options = options || {};

        if (!options.heightAdjustment) {
            options.heightAdjustment = 40;
        }

        if (!options.marginTop) {
            options.marginTop = 0;
        }

        options.left = true;

        this.createScrollContainer(options);

        this.options = options;
        this.selectedNodes = [];

        this.uiCreated = false;


        this.addVisibilityListener(function(show) {

            if (show) {
                if (!that.uiCreated) {
                    that.createUI();
                }

                that.resizeToContent();
            }
        });
    };

    viewerSearchNameSpace.InViewerSearchPanel.prototype = Object.create(viewUINameSpace.DockingPanel.prototype);
    viewerSearchNameSpace.InViewerSearchPanel.prototype.constructor = viewerSearchNameSpace.InViewerSearchPanel;

    viewerSearchNameSpace.InViewerSearchPanel.prototype.createUI = function() {
        // TODO(jwo): Why is this an empty function?
        //var self = this;
    };

    /**
     * Given a node's id, adds the given CSS class to this node.
     *
     * @param {string} id - The id of a node in an Autodesk.Viewing.Model
     * @param {string} className - The CSS class to add
     * @returns {boolean} - true if the class was added, false otherwise
     */
    viewerSearchNameSpace.InViewerSearchPanel.prototype.addClass = function(id, className) {
        var returnVal = ((this.tree !== null) && this.tree.addClass(id, className));

        return returnVal;
    };

    /**
     * Given a node's id, removes the given CSS class from this node.
     *
     * @param {string} id - The id of a node in an Autodesk.Viewing.Model
     * @param {string} className - The CSS class to remove
     * @returns {boolean} - true if the class was removed, false otherwise
     */
    viewerSearchNameSpace.InViewerSearchPanel.prototype.removeClass = function(id, className) {
        var returnVal = ((this.tree !== null) && this.tree.removeClass(id, className));

        return returnVal;
    };

    viewerSearchNameSpace.InViewerSearchPanel.prototype.initializeCloseHandler = function(closer) {
        var self = this;

        self.addEventListener(closer, 'click', function() {
            self.qsApiService.logGeneralEvent('searchWindowClose');
        }, false);
    };

    Autodesk.Viewing.UI.InViewerSearchPanel = viewerSearchNameSpace.InViewerSearchPanel;

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function() {
    'use strict';

    /**
     * @typedef GeometriesSearchResultType
     * @property {string} id - Geometry id
     * @property {string} name - Geometry Name
     * @property {SearchResultType[]} results - search results for the geometry
     * @property {boolean} moreResults - true is there are more results
     */

     /**
      * @typedef SearchResultType
      * @property {string} dbId - geometry node dbId
      * @property {string} fieldName - property field name
      * @property {string} fieldValue - property field value
      * @property {string} nodeName - geometry node name
      * @property {string} displayName - string representing the result label 'nodeName (fieldName: fieldValue)'. Highlighting the searched string.
      */

      /**
       * @typedef GeometriesSearchResultsType
       * @property {number} page - page number
       * @property {GeometriesSearchResultType[]} results - result list
       * @property {number} resultCount - the total amount of results
       */

    var viewerNameSpace = Autodesk.Viewing;
    var viewerPrivateNameSpace = Autodesk.Viewing.Private;
    // var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    // var viewUINameSpace = Autodesk.Viewing.UI;
    var viewerSearchNameSpace = new AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    var _this;

    /**
     * InViewerSearchThisItem
     */
    viewerSearchNameSpace.InViewerSearchThisItem = function(viewer, options, cache) {
        _this = this;
        this.viewer = viewer;
        this.options = options;
        this.container = null;
        this.initialized = false;
        this.controller = null;
        this.qsApi = null;
        this.searchString = null;
        this.geoPages = {};
        this.currentGeometry = null;
        this.limit = options.relatedItemsTab.pageSize;
        this.clicked = null;
        this.extensionViewer = null;
        this.cacheObj = cache;

        this.loading = null;
        this.stillLoadingAlertElemId = 'this-item-loading-alert';
        this.stillLoadingAlertElem = null;
        this.geometriesContainer = {};
        this.resultCountDom = null;
    };

    //viewerSearchNameSpace.InViewerSearchThisItem.prototype = Object.create(viewerNameSpace.Extension.prototype);
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.constructor = viewerSearchNameSpace.InViewerSearchThisItem;

    /**
     * InViewerSearchThisItem.initialize - initialize the geometries/properties and all the needed information
     *
     * @param  {type} qsApi            - QsApiService
     * @param  {type} viewerProperties - ViewerPropertiesService instance
     * @param  {type} currentGeometry  - geometry id loaded in the viewer
     * @param  {type} container      - html element
     * @param  {type} cb         - callback function
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.initialize = function(qsApi, viewerProperties, currentGeometry, container, cb, changeTab) {
        // FIXME(jwo): Move above `cb` to last parameter of the function. Callbacks are generally last so inline anonymous functions aren't followed by additional parameters.

        var self = this;
        this.qsApi = qsApi;

        if (this.options.uiEnabled) {
            this.container =  container;
            this.container.addEventListener('click', this.clickHandler);
        }

        this.currentGeometry = currentGeometry;
        this.changeTab = changeTab;

        this.controller = new Controller(currentGeometry, viewerProperties, qsApi, this.viewer.model.myData.urn);

        this.controller.initialize(function() { // TODO(jwo): Should initialize() be part of the constructor, or is there a case to create and not initalize?
            self.initialized = true;

            if (self.options.uiEnabled && self.viewer && self.viewer.getPropertyPanel) {
                self.extensionViewer = self.viewer.getPropertyPanel(true);
            }
            var containerId = (container && container.id) ? container.id : container;
            cb(containerId, self.initialized); return;
        });

    };

    viewerSearchNameSpace.InViewerSearchThisItem.prototype.uninitialize = function() {

        if (this.options.uiEnabled) {
            this.container.removeEventListener('click', this.clickHandler);
        }

        if (this.controller) {
            this.controller = null;
        }
    };

    var fnHandleClicks = function(event) {
        var node = event.target, found = false;
        var searchGeoGuid, searchDbId, searchIndex;

        while (node && this.container !== node && !found) {
            found = node.hasAttribute('adskSearchDbId');
            if (!found) { node = node.parentNode; }
        }

        if (found) {
            searchGeoGuid = node.getAttribute('adskSearchGeoGuid');
            searchDbId = parseInt(node.getAttribute('adskSearchDbId'), 10);
            searchIndex = parseInt(node.getAttribute('adskSearchIndex'), 10);
            if (event.type === 'click') {
                if (_this.currentGeometry === searchGeoGuid) {
                    _this.qsApi.logResultClickEvent(searchIndex + 1, searchDbId, true, 'thisItem');
                    // should be
                    //_this.showNodeProperties(event, searchDbId, searchIndex);
                    // is
                    _this.changeTab(searchDbId);
                } else {
                    _this.loadGeometryInViewer(searchGeoGuid, searchDbId, searchIndex);
                }
            } else if (event.type === 'dblclick') {
                //_this.showNodeProperties(event, searchDbId, searchIndex, true);
                //_this.viewer.fitToView();
                // TODO(jwo): Log double-click, etc
            } else if (event.type === 'hover') {
                //_this.viewer.impl.rolloverObjectNode(searchDbId);
            }
        }
    };

    viewerSearchNameSpace.InViewerSearchThisItem.prototype.clickHandler = function(event) {

        if (!event) {
            return;
        }


        // Working around both click and dblClick events arriving (SRCH-1169)
        if (_this.mouseClickTimeout) {
            clearTimeout(_this.mouseClickTimeout);
            _this.mouseClickTimeout = null;
        }

        _this.mouseClickTimeout = setTimeout(function() { fnHandleClicks.call(_this, event); }, 200);
    };

    /**
     * [UI ENABLED] shows/hides the loading message
     *
     * @param  {boolean} loading  - if true shows loading else it hides it
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.toggleLoading = function(loading) {
        var loadingElementDOM = this.loading;
        var spanDOM;

        if (loading && !loadingElementDOM) {
            loadingElementDOM = document.createElement('div');
            loadingElementDOM.className = 'loading this-item-loading';
            spanDOM = document.createElement('span');
            spanDOM.textContent = viewerNameSpace.i18n.translate('Loading');
            loadingElementDOM.appendChild(spanDOM);

            this.container.appendChild(loadingElementDOM);
            this.loading = loadingElementDOM;

        } else if (!loading && loadingElementDOM) {
            if (loadingElementDOM.parentNode) {
                loadingElementDOM.parentNode.removeChild(loadingElementDOM);
            }
            this.loading = null;
        }
    };


    /**
     * Searches into the property values of all geometries
     *
     * @param  {type} str      - string to search
     * @param  {type} cb - this func will be called with the results: function(GeometriesSearchResultsType)
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.search = function(query, cb) {
        var self = this;
        var ctrl = self.controller;
        var queryTrimmed = query.trim();

        this.clearSearch();

        if (queryTrimmed) {
            this.searchString = queryTrimmed;

            if (this.options.uiEnabled) {
                this.toggleLoading(true);
            }

            this.controller.doSearch(queryTrimmed, function(partialResults, loaded, total, ended, geometry) {
                var firstPage;

                if (self.options.uiEnabled) {
                    self.showResults(queryTrimmed, partialResults, loaded, total, geometry);
                } else if (ended) {

                    firstPage = ctrl.totalResults.map(function(g) {
                        var result = {
                            id: g.id,
                            name: g.name,
                            results: g.results.slice(0, self.limit),
                            moreResults: g.results.length > self.limit
                        };

                        return result;
                    });

                    var results = {
                        page: 1,
                        results: firstPage,
                        resultsCount: ctrl.resultsCount,
                    };

                    cb(results); return;
                }
            });
        }
    };

    /**
     * [UI ENABLED] loads the geometry in the viewer and triggers the search after viewer loaded.
     *
     * @param  {type} guid     - geometry id
     * @param  {type} dbId     - geometry node dbId
     * @param  {type} position - the position of the result selected
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.loadGeometryInViewer = function(guid, dbId, position) {
        var data = this.cacheObj();
        var ctrl = this.controller;
        var geo = ctrl.viewerProperties.getGeometry(guid);
        var item = geo ? geo.data : {guid: guid};

        this.qsApi.logResultClickEvent(position + 1, dbId, false, 'thisItem');
        data.searchInfoThisItem = {node: dbId, str: this.searchString};

        var onErrorCb = function() {
            viewerPrivateNameSpace.logger.error('Error loading geometry');
        };

        var onSuccessCb = function() {
            viewerPrivateNameSpace.logger.log('success loading geometry');
        };

        this.viewer.fireEvent({ type: viewerNameSpace.LOAD_GEOMETRY_EVENT, data: { item: item, onSuccessCb: onSuccessCb, onErrorCb: onErrorCb } });
    };

    /**
     * [UI ENABLED]shows/hides the results for the geometry
     *
     * @param  {type} event - click event
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.toggleGeometry = function(event) {

        if (event.target.parentElement.className.indexOf('collapsed') === -1) {
            event.target.parentElement.classList.add('collapsed');
        } else {
            event.target.parentElement.classList.remove('collapsed');
        }
    };

    function addItemResult(self, resultList, geometryItem, index, geoId) {
        var itemDom = document.createElement('li');
        var ctrl = self.controller;
        var displayName;
        if (!geometryItem.displayName) {
            var name = geometryItem.nodeName;

            if (!name) {
                name = ctrl.viewerProperties.defaultNodeName();
            }

            if (name.indexOf(ctrl.searchedString) >= 0 || (geometryItem.hasOwnProperty('fieldName') && geometryItem.fieldName === "Name")) {
                displayName = ctrl.viewerProperties.highlightText(name, ctrl.searchedString);
            } else {
                var itemValue = (Object.prototype.toString.call(geometryItem.fieldValue) === '[object Number]' ? String(geometryItem.fieldValue) : geometryItem.fieldValue);
                displayName = ctrl.viewerProperties.highlightText(name) + ' (' + ctrl.viewerProperties.highlightText(geometryItem.fieldName) + ': ' + ctrl.viewerProperties.highlightText(itemValue, ctrl.searchedString) + ')';
            }

        } else {
            displayName = geometryItem.displayName;
        }

        itemDom.className = 'item-result';
        itemDom.innerHTML = displayName; // TODO(jwo): Switch to using the SDK's highlighter
        //itemDom.id = 'geoGuid_' + geoId + '_dbId_' + geometryItem.dbId;
        itemDom.setAttribute('adskSearchGeoGuid', geoId); // TODO(jwo): Move these directly to JS props instead of HTML attributes
        itemDom.setAttribute('adskSearchDbId', geometryItem.dbId);
        itemDom.setAttribute('adskSearchIndex', index);
        resultList.appendChild(itemDom);
    }

    function addDummyItemResult(self, resultList, geoId) {
        var itemDom;
        var moreExist;

        if (resultList && resultList.children.length) {
            moreExist = resultList.lastChild.className.contains('more-items')
            if (!moreExist) {
              itemDom = document.createElement('li');
              itemDom.className = 'item-result more-items';
              itemDom.textContent = viewerNameSpace.i18n.translate('Load More');
              itemDom.addEventListener('click', function(event) {
                  self.qsApi.logLoadMoreClickEvent(geoId, 'thisItem');
                  self.loadMoreItems(geoId, event);
              }, false);

              resultList.appendChild(itemDom);
            }
        }

    }

    function addNewGeometryResults(self, geometriesContainer, geometry, index) {
        var geometryResultDom, geomNameDom, resultListDom, length;
        var ctrl = self.controller;

        geometryResultDom = document.createElement('div');
        geometryResultDom.className =  'geometry-results ' + 'geometry_' + geometry.id;
        geometryResultDom.className = geometryResultDom.className + ((ctrl.geometriesCount > 3 ) ? ' collapsed' : '');

        geomNameDom = document.createElement('label');
        geomNameDom.className = 'geometry-name';
        geomNameDom.setAttribute('adskGeomId', geometry.id);
        geomNameDom.setAttribute('adskGeomIndex', index);
        geomNameDom.addEventListener('click', function(event) {
            var geomId = event.currentTarget.getAttribute('adskGeomId');
            var index = parseInt(event.currentTarget.getAttribute('adskGeomIndex'), 10);
            self.qsApi.logResultGeomClickEvent(index + 1, geomId, self.currentGeometry === geomId, 'thisItem');
            self.toggleGeometry(event);
        }, false);
        geomNameDom.textContent = geometry.name;

        geometryResultDom.appendChild(geomNameDom);

        resultListDom = document.createElement('ul');
        resultListDom.className = 'geometry-result-list';

        length = Math.min(geometry.results.length, self.limit);
        self.geoPages[geometry.id] = length;

        geometry.results.slice(0, length).forEach(function(geoResult, i) {
            addItemResult(self, resultListDom, geoResult, i, geometry.id);
        });

        geometryResultDom.appendChild(resultListDom);

        if (ctrl.bruteSearch && index < ctrl.geometriesCount - 1) {
            geometriesContainer.insertBefore(geometryResultDom, geometriesContainer.childNodes[index]);
        } else {
            geometriesContainer.appendChild(geometryResultDom);
        }

        self.geometriesContainer[geometry.id] = geometryResultDom;
    }

    function updateResultsCount(count, self) {
        var term, ctx, strResultText, resultCountDom;

        resultCountDom = self.resultCountDom;

        if (resultCountDom) {
            term = resultCountDom.getAttribute('term');
            ctx = resultCountDom.getAttribute('ctx');

            strResultText = viewerNameSpace.i18n.translate('Results Count');
            strResultText = strResultText.split('{0}').join(count);
            strResultText = strResultText.split('{1}').join(term);
            strResultText = strResultText.split('{2}').join(ctx);

            resultCountDom.textContent = strResultText;
        }

    }

    function createContainersAndList(self, container, str, geometryResults, count, allLoaded, index) {
        var resultCountDom, ctrl, strResultText, wrapperDom, geometriesContainerDom, geometry;

        ctrl = self.controller;

        container.textContent = ''; // Empty the container

        wrapperDom = document.createElement('div');
        wrapperDom.id = 'result-count-this-item-wrapper';
        wrapperDom.className = 'result-count';

        resultCountDom = document.createElement('span');
        resultCountDom.id = 'result-count-this-item';
        resultCountDom.setAttribute('term', str);
        resultCountDom.setAttribute('ctx', self.options.relatedItemsTab.displayName);

        strResultText = viewerNameSpace.i18n.translate('Results Count')
            .split('{0}').join(count) // TODO(jwo): write function to apply templates
            .split('{1}').join(str)
            .split('{2}').join(self.options.relatedItemsTab.displayName);

        self.resultCountDom = resultCountDom;
        resultCountDom.textContent = strResultText;

        wrapperDom.appendChild(resultCountDom);
        container.appendChild(wrapperDom);

        geometriesContainerDom = document.createElement('div');
        geometriesContainerDom.className = 'geometries-results-container dockingPanelScroll';

        if (!allLoaded) {
            geometriesContainerDom.className = geometriesContainerDom.className + ' too-many-geometries';
        }

        container.appendChild(geometriesContainerDom);
        var geometryResult, moreResults;
        var geometryId = geometryResults.id;

        addNewGeometryResults(self, geometriesContainerDom, geometryResults, index);
        if (self.geoPages[geometryId] >= self.limit) {
            geometryResult = self.geometriesContainer[geometryId];
            moreResults = geometryResults.results.length > self.geoPages[geometryId];
            if (moreResults) {
                addDummyItemResult(self, geometryResult.children[1], geometryId);
            }
        }
    }

    function appendResults(self, geometriesContainer, geometry, count, ind) {
        var ctrl = self.controller;

        var resultList, length, remaining, index, init;
        var geometryResult;

        if (geometry.results && geometry.results.length) {
            if (!self.geometriesContainer.hasOwnProperty(geometry.id)) {
                addNewGeometryResults(self, geometriesContainer, geometry, ind);
            } else if (self.geoPages[geometry.id] < self.limit) {
                geometryResult = self.geometriesContainer[geometry.id];
                resultList = geometryResult.children[1];
                length = geometry.results.length;
                remaining = self.limit - self.geoPages[geometry.id];
                index = self.geoPages[geometry.id];
                init = 0;

                if (index > 0) {
                    init = index;
                }

                if (length > self.limit) {
                    self.geoPages[geometry.id] = self.limit;
                    length = self.limit;
                } else {
                    self.geoPages[geometry.id] = self.geoPages[geometry.id] + (length - index);
                }

                geometry.results.slice(init, length).forEach(function(result, i) {
                    addItemResult(self, resultList, result, i, geometry.id);
                });
            }

            if (self.geoPages[geometry.id] >= self.limit) {
                var moreResults = ctrl.totalResults[ctrl.totalResultsIndex[geometry.id]].results.length > self.geoPages[geometry.id];

                if (moreResults) {
                    geometryResult = self.geometriesContainer[geometry.id];
                    addDummyItemResult(self, geometryResult.children[1], geometry.id);
                }
            }
        }

        updateResultsCount(count, self);
    }

    function showNoResults(self, container, str, contextName) {
        container.innerHTML = '';

        var noResultsDom = document.createElement('p');
        noResultsDom.className = 'search-no-results';

        var strResultText = viewerNameSpace.i18n.translate('No Results')
            .split('{0}').join(str)
            .split('{1}').join(contextName);

        noResultsDom.textContent = strResultText;

        container.appendChild(noResultsDom);
    }


    /**
     * [UI ENABLED] show the results in the UI
     *
     * @param  {type} str            string searched
     * @param  {type} partialResults result list
     * @param  {type} loaded         the amount of geometries loaded (case big amount of geometries)
     * @param  {type} total          the total amount of the document geometries
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.showResults = function(str, results, loaded, total, geometry) {
        var geometryResults;
        var ctrl = this.controller;
        var self = this;
        var index;
        var totalResults;
        var container = self.container;
        var append = (container.children.length > 1);
        var allLoaded = (total === loaded);
        var stillLoadingAlertDom = this.stillLoadingAlertElem;

        if (results && results.totalResults && results.totalResults.length > 0) {
            totalResults = results.totalResults;
            var geometriesContainer = null;
            if (!geometry) {
                totalResults = ctrl.viewerProperties.orderGeometriesByName(results);
            }

            self.toggleLoading(false);
            totalResults.forEach(function(gemResults) {
                index = ctrl.totalResultsIndex[gemResults.id];
                if (!append) {
                    createContainersAndList(self, container, str, gemResults, ctrl.resultsCount, allLoaded, index, ctrl.bruteSearch);
                    append = true;
                } else {
                    geometriesContainer = container.children[1];
                    appendResults(self, geometriesContainer, gemResults, ctrl.resultsCount, index, ctrl.bruteSearch);
                }
            });

        } else if (ctrl.searchInItemEnded) {
            self.toggleLoading(false);
            showNoResults(self, container, str, self.options.relatedItemsTab.displayName);
        }

        if (!allLoaded && ctrl.searchInItemEnded && !stillLoadingAlertDom) {

            stillLoadingAlertDom = document.createElement('div');
            stillLoadingAlertDom.id = self.stillLoadingAlertElemId;
            stillLoadingAlertDom.className = 'alert-geometries-loading';

            var geometriesLoadingTxt = viewerNameSpace.i18n.translate('Geometries Loading');

            stillLoadingAlertDom.textContent = geometriesLoadingTxt;
            this.stillLoadingAlertElem = stillLoadingAlertDom;
            container.appendChild(stillLoadingAlertDom);
        }
    };


    /**
     * sets the search related data empty
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.clearSearch = function() {

        if (this.container && this.options.uiEnabled) {
            this.container.innerHTML = '';
            this.geometriesContainer = {};
            this.stillLoadingAlertElem = null;
            this.resultCountDom = null;
        }

        this.geoPages = {};
        this.toggleLoading(false);
    };

    /**
     * Gets the corresponding page of results for the geometry.
     * If no pageNumber it will return next page from the last offset saved (UI)
     * @param  {type} geometryId - geometry id
     * @param  {type} pageNumber - page to return
     * @param  {function} cb - this will be called with the results: function(GeometriesSearchResultsType)
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.getPage = function(geometryId, pageNumber, cb) {
        var geometry, resultsForGeometry, resToAdd, pageItems, results;
        var ctrl = this.controller;
        var self = this;
        var pageoffset = self.limit * (pageNumber - 1);

        pageItems = {
            id: '',
            name: '',
            results: [],
            moreResults: false
        };

        geometry = ctrl.totalResults[ctrl.totalResultsIndex[geometryId]];

        if (geometry) {
            resultsForGeometry = geometry.results;
            resToAdd = resultsForGeometry.slice(pageoffset, pageoffset + self.limit);

            pageItems = {
                id: geometry.id,
                name: geometry.name,
                results: resToAdd,
                moreResults: resultsForGeometry.length > (pageoffset + self.limit)
            };
        }

        results = {
            page: pageNumber,
            results: pageItems,
            resultsCount: ctrl.resultsCount
        };

        cb(results); return;
    };

    /**
     * [UI ENABLED] load more results to the geometry result list
     *
     * @param  {type} geometryId - geometry id
     * @param  {type} event      - click event
     */
    viewerSearchNameSpace.InViewerSearchThisItem.prototype.loadMoreItems = function(geometryId, event) {
        var geometry, resultsForGeometry, resToAdd, geometryResult, resultList, moreItems;
        var ctrl = this.controller;
        var self = this;
        var pageoffset = self.geoPages[geometryId];
        var index = pageoffset;

        geometry = ctrl.totalResults[ctrl.totalResultsIndex[geometryId]];
        resultsForGeometry = geometry.results;
        resToAdd = resultsForGeometry.slice(pageoffset, pageoffset + self.limit);

        self.geoPages[geometryId] = self.geoPages[geometryId] + self.limit;

        geometryResult = this.geometriesContainer[geometryId];
        resultList = geometryResult.children[1];
        event.target.parentNode.removeChild(event.target);

        moreItems = resultsForGeometry.length > self.geoPages[geometryId];

        resToAdd.forEach(function(res) {
            addItemResult(self, resultList, res, index, geometryId);
            index++;
        });

        if (moreItems) {
            addDummyItemResult(self, resultList, geometryId);
        }
    };

    function Controller(currentGeometry, viewerProperties, qsApi, documentId) {
        var ctrl = this;
        var initStart = null;
        var startBrute = null;

        /**
         *the Key is the geometry Id and save the geometry data and the names for the geometry nodes (if exists)
         * @type {Map[string, {data: object, viewerObjects: Map[string, object]}]}
         */
        ctrl.initialized = false;
        ctrl.totalResults = [];
        ctrl.searchInItemEnded = false;
        ctrl.resultsCount = -1;
        ctrl.totalResultsIndex = {};
        ctrl.bigModels = false;
        ctrl.bigAmountGeometries = false;
        ctrl.viewerProperties = viewerProperties;
        ctrl.searchedString = "";
        ctrl.lastSearchedString = "";
        ctrl.geometriesCount = 0;
        ctrl.bruteSearch = false;
        /**
         * once all components are initialized
         */
        function ready() {
            var time = new Date().getTime() - initStart;
            viewerPrivateNameSpace.logger.log('Execution time INIT: ' + time);
            qsApi.logTimeEvent("initTime", time, 'thisItem');
            ctrl.initialized = true;
        }

        /**
         * calculates if the geometries nodes count are bigger than maxNodeGeometryCount
         * @param geometries
         * @returns {boolean}
         */
        function areBigModels() {
            return ctrl.viewerProperties.tooManyNodes();
        }

        /**
         * if the geometries are not big, it gets the attributes for each geometry and calls ctrl.viewerProperties to initialize it.
         * if are big just ends
         * @param geometries
         */
        ctrl.initializeAttributes = function(geometries, cb) {

            ctrl.initialized = false;
            ctrl.totalResults = [];
            ctrl.searchInItemEnded = false;
            ctrl.resultsCount = -1;
            ctrl.totalResultsIndex = {};

            if (!ctrl.bigModels) {
                ctrl.viewerProperties.getGeometriesAttributes(function() {
                    ready();
                    cb();
                    return;
                });
            } else {
                ready();
                cb(); return;
            }
        };

        /**
         * when the geometries are big we just call to bruteSearch and transform the results
         * @param str
         * @param callback
         */
        function bruteSearch(str, callback) {
            // FIXME(jwo): recommend starting & ending timers in the same function.
            // The callback can be wrapped to catch the ending, or the starting time can be moved to calling function.
            // This removes the need for global-ish variables for timers, and allows for multiple running timers.
            startBrute = new Date().getTime();

            ctrl.viewerProperties.bruteSearch(str, function(str, result, ended, geometry) {
                if (ctrl.lastSearchedString === str) {
                    ctrl.totalResults = result.totalResults;
                    ctrl.searchInItemEnded = ended;
                    ctrl.resultsCount = result.resultsCount;
                    ctrl.totalResultsIndex = result.totalResultsIndex;
                    ctrl.searchedString = str;
                    ctrl.geometriesCount++;
                    ctrl.bruteSearch = true;

                    if (bruteSearch && ended) {
                        qsApi.logTimeEvent('bruteSearchTime', (new Date().getTime() - startBrute), 'thisItem');
                        qsApi.logSearchResults(ctrl.resultsCount, str, 'bruteSearch', 'thisItem');
                    }
                    var geomResults = result.totalResults[result.totalResultsIndex[geometry]];
                    var partial = null;
                    if (geomResults) {
                        partial = {totalResults: [geomResults]};
                    }

                    if (bruteSearch && ended) {
                        qsApi.logTimeEvent('bruteSearchTime', (new Date().getTime() - startBrute), 'thisItem');
                        qsApi.logSearchResults(ctrl.resultsCount, str, 'bruteSearch', 'thisItem');
                    }

                    callback(partial, ctrl.viewerProperties.geometriesLoaded(), ctrl.viewerProperties.getTotalCountGeometries(), ended, geometry); return;
                }
            });
        }

        /**
         * Initialize the ctrl.viewerProperties and get the properties/attributes for the geometries.
         */
        ctrl.initialize = function(cb) {
            var calledCb = false;
            initStart = new Date().getTime();

            ctrl.viewerProperties.initPropertyDatabases(function(geometries, ended, bigAmountGeometries) {
                ctrl.loadingGeom = geometries;
                ctrl.bigAmountGeometries = bigAmountGeometries;
                ctrl.bigModels = areBigModels(geometries);

                if (ctrl.viewerProperties.getTotalCountGeometries() === 1) {
                    ready();
                    cb();
                    return;
                }
                if (ended) {
                    ctrl.initializeAttributes(geometries, function() {
                        if (!bigAmountGeometries) {
                            cb(); return;
                        }
                    });
                }

                //if there are a lot of geometries I let them load in the background instead of waiting
                if (bigAmountGeometries) {
                    cb(); return;
                }
            });
        };

        /**
         * if the geometries are big it performs a bruteSearch
         * if not calls ctrl.viewerProperties search
         * @param str
         * @param cb - callback
         */
        ctrl.doSearch = function(str, cb) {
            ctrl.totalResults = [];
            ctrl.searchInItemEnded = false;
            ctrl.resultsCount = 0;
            ctrl.totalResultsIndex = {};
            ctrl.lastSearchedString = str;
            ctrl.geometriesCount = 0;
            ctrl.bruteSearch = false;

            if (ctrl.bigModels || !ctrl.initialized) {
                bruteSearch(str, cb);
            } else {
                var start = +new Date();
                ctrl.viewerProperties.doSearch(str, function(str, result, ended) {
                    //checking that the result is not old
                    if (ctrl.lastSearchedString === str) {
                        ctrl.totalResults = result.totalResults;
                        ctrl.searchInItemEnded = ended;
                        ctrl.resultsCount = result.resultsCount;
                        ctrl.totalResultsIndex = result.totalResultsIndex;
                        ctrl.searchedString = str;
                        ctrl.geometriesCount = result.totalResults.length;

                        if (ended) {
                            qsApi.logTimeEvent('searchTime', (new Date() - start), 'thisItem');
                            qsApi.logSearchResults(ctrl.resultsCount, str, 'fullproof-StringSearch', 'thisItem');
                        }

                        cb(result, ctrl.viewerProperties.geometriesLoaded(), ctrl.viewerProperties.getTotalCountGeometries(), ended); return;
                    }

                });
            }
        };
    }
})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function() {
    'use strict';

    var viewerNameSpace = Autodesk.Viewing;
    //var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    //var viewUINameSpace = Autodesk.Viewing.UI;
    var viewerPrivateNameSpace = Autodesk.Viewing.Private;
    var viewerSearchNameSpace = new AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    var viewerPrivateNameSpace = Autodesk.Viewing.Private;

    /* CONSTANTS*/
    var MESSAGE_FEATURE_NOT_CONFIGURED = 'This feature has not been configured.';

    /**
     * @typedef CategoryResultType
     * @property {string} name - item name
     * @property {string} url - item url
     * @property {function} logClick - function to log click on the result
     */

     /**
      * @typedef CategoryDataType
      * @property {string} name - item name
      * @property {number} modifier - query id
      */

    /**
     * @typedef categoriesResultsType
     * @property {string} name - category name
     * @property {number} modifier - query id
     * @property {boolean} moreItems - true if there are more results
     * @property {CategoryResultType[]} categoryResults - search results for the geometry
     */

     /**
      * @typedef CategoriesSearchResultsType
      * @property {number} page - page number
      * @property {GeometriesSearchResultType[]} results - result list
      * @property {number} resultCount - the total amount of results
      */


    /**
     * InViewerSearchThisProject
     */
    viewerSearchNameSpace.InViewerSearchThisProject = function(options) {

        this.options = options;
        this.initialized = false;
        this.controller = null;
        this.qsApi = null;

        this.container =  null;
        this.contextMenu = null;
        this.urlCb = null;
        this.loadingId = 'this-project-loading';
        this.searchParams = null;
        if (options && options.serverSearchTab && options.serverSearchTab.parameters) {
            this.searchParams = options.serverSearchTab.parameters;
        }

        this.loadingElementDom = null;
        self.categoriesContainerDom = null;
    };

    //viewerSearchNameSpace.InViewerSearchThisProject.prototype = Object.create(viewerNameSpace.Extension.prototype);
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.constructor = viewerSearchNameSpace.InViewerSearchThisProject;


    /**
     * Initialize this project logic
     *
     * @param  {QsApiService} qsApi       - QsApiService initialized
     * @param  {string} container - html container of this project html
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.initialize = function(qsApi, container) {
        var self = this;
        var initStart = +new Date();

        this.qsApi = qsApi;
        if (!self.options || !self.options.serverSearchTab || !self.searchParams) {
            viewerPrivateNameSpace.logger.warn('Error initializing server search tab: missing options.');
            return;
        }

        this.urlCb = self.searchParams.urlCallback;
        this.baseURL = (self.searchParams.baseURL ? self.searchParams.baseURL.replace(/\/$/g, '') : '');
        this.fallbackURL = self.searchParams.fallbackURL;
        this.controller = new Controller(qsApi);

        if (this.options.uiEnabled) {
            this.container =  container;

            window.addEventListener('click', function() {
                if (self.contextMenu) {
                    self.contextMenu.classList.add('hidden');
                }
            }, false);
        }

        qsApi.logTimeEvent("initTime", (new Date() - initStart), 'thisProject');
        this.initialized = true;
    };

    viewerSearchNameSpace.InViewerSearchThisProject.prototype.uninitialize = function() {
        if (this.controller) {
            this.controller.uninitialize();
        }
    };

    // FIXME(jwo): This function has both callbacks & a normal non-async return path. why?
    // -- this is not an asyn js callback, it's a sync cb that performs the url resolution if needed
    function createURL(fallbackURL, baseURL, item, urlCb) {
        var url = fallbackURL;
        var reFullUrl = /^https?:\/\//i;
        try {
            if (urlCb) {
                url = urlCb(item);
            } else if (item.url) {
                if (item.url.search(reFullUrl) === 0) {
                    url = item.url;
                } else {
                    url = baseURL + "/" + item.url;
                    url = url.replace(/([^:]\/)\/+/g, '$1');
                }
            }
        } catch(e) {
            url = null;
        }

        return url || fallbackURL;
    }

    /**
     * [UI ENABLED] opens the context menu for the result clicked
     *
     * @param  {object} event - click event (user clicked on a result)
     * @param  {object} item  description
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.openMenu = function(event, item) {
        var anotherWindowOptionDom, thisWindowOptionDom, left;
        var menuDom = this.contextMenu;
        var url = createURL(this.fallbackURL, this.baseURL, item, this.urlCb);
        var containerDom = this.container;
        var offset = containerDom.getBoundingClientRect();

        item.logClick();
        event.stopPropagation();
        menuDom.textContent = ''; // Empty menuDom

        if (url) {
            anotherWindowOptionDom = document.createElement('div');
            anotherWindowOptionDom.className = 'menu-item open-another-window';
            // FIXME(jwo): Remove .innerHTML by building dom elements instead + .textContent
            anotherWindowOptionDom.innerHTML = '<a href=\'' + url + '\' target=\'_blank\'>' + viewerNameSpace.i18n.translate('Open Another Window') + '</a>';

            thisWindowOptionDom = document.createElement('div');
            thisWindowOptionDom.className = 'menu-item open-this-window';
            // FIXME(jwo): Remove .innerHTML by building dom elements instead + .textContent
            thisWindowOptionDom.innerHTML = '<a href=\'' + url + '\' target=\'_self\'>' + viewerNameSpace.i18n.translate('Open This Window') + '</a>';
            menuDom.appendChild(anotherWindowOptionDom);
            menuDom.appendChild(thisWindowOptionDom);

            left = event.pageX - offset.left + event.currentTarget.offsetLeft - 10;
            if (left > 195) {
                left = left - 145;
            }
            menuDom.style.top = (event.pageY - 7) + 'px';
            menuDom.style.left = left + 'px';

            menuDom.className = menuDom.className.replace(' hidden', '');
        } else {
            viewerPrivateNameSpace.logger.warn('The url for ' + item.name + ' is empty');
        }

    };


    /**
     * [UI ENABLED] shows/hides search results for the category
     *
     * @param  {oject} event - click event (user clicked on a category name)
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.toggleCategory = function(event) {
        var expanded = (event.target.parentElement.className.indexOf('collapsed') === -1);

        if (expanded) {
            event.target.parentElement.classList.add('collapsed');
        } else {
            event.target.parentElement.classList.remove('collapsed');
        }

    };


    /**
     * [UI ENABLED] shows/hides loading message
     *
     * @param  {boolean} loading - if true shows else hides
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.toggleLoading = function(loading) {
        var loadingElementDom = this.loadingElementDom;

        if (loading && !loadingElementDom) {
            loadingElementDom = document.createElement('div');
            loadingElementDom.id = this.loadingId;
            loadingElementDom.className = 'loading';
            // FIXME(jwo): Replace .innerHTML w/ dom elements + .textContent
            loadingElementDom.innerHTML = '<span>' + viewerNameSpace.i18n.translate('Loading') + '</span>';
            this.loadingElementDom = loadingElementDom;
            this.container.appendChild(loadingElementDom);
        } else if (!loading && loadingElementDom) {
            if (loadingElementDom.parentNode) {
                loadingElementDom.parentNode.removeChild(loadingElementDom);
            }
            this.loadingElementDom = null;
        }
    };


    /**
     * [UI ENABLED] returns the next page of results for the category
     *
     * @param  {object} event    - click event
     * @param  {categoriesResultsType} category - category data
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.loadMoreItems = function(event, category) {
        var self = this;
        var ctrl = this.controller;
        var listDom = event.target.parentElement;

        this.toggleLoading(true);

        ctrl.getMoreResults(this.searchParams.pid, category.name, category.modifier, function(newpage, moreItems) {
            var elementScrollDom;

            if (!moreItems) {
                event.target.parentNode.removeChild(event.target);
            }

            self.toggleLoading(false);

            newpage.forEach(function(catItem) {
                var itemDom = document.createElement('li');

                // FIXME(jwo): Replace .innerHTML w/ .textContent
                itemDom.innerHTML = catItem.name;
                itemDom.className = 'item-result';

                itemDom.addEventListener('click', function(event) {
                    self.openMenu(event, catItem);
                }, false);

                if (moreItems) {
                    listDom.insertBefore(itemDom, listDom.childNodes[(listDom.childElementCount - 1)]);
                } else {
                    listDom.appendChild(itemDom);
                }

            });

            elementScrollDom = this.categoriesContainerDom;
            elementScrollDom.scrollTop = elementScrollDom.scrollTop + 70;
        });
    };


    /**
     * Gets the page of results passed as parameter
     *
     * @param  {CategoryDataType} category - category data
     * @param  {number} pageNumber     - page number
     * @param  {function} cb - callback function(CategoriesSearchResultsType)
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.getPage = function(category, pageNumber, cb) {
        //var self = this;
        var ctrl = this.controller;
        //var list = event.target.parentElement;

        if (this.options.uiEnabled) {
            this.toggleLoading(true);
        }

        ctrl.getMoreResults(this.searchParams.pid, category.name, category.modifier, function(newpage, moreItems) {
            // TODO(jwo): moreItems is unused; should it be?

            var moreResults = {
                page: pageNumber,
                results: newpage,
                resultsCount: ctrl.count,
            };

            cb(moreResults); return;
        }, pageNumber);
    };


    function showNoResults(self, container, str, contextName) {
        var strResultText, noResultsDOM;

        container.textContent = ''; // clear container

        noResultsDOM = document.createElement('p');
        noResultsDOM.className = 'search-no-results';

        strResultText = viewerNameSpace.i18n.translate('No Results');
        strResultText = strResultText.split('{0}').join(str);
        strResultText = strResultText.split('{1}').join(contextName);

        noResultsDOM.textContent = strResultText;

        container.appendChild(noResultsDOM);
    }

    /**
     * [UI ENABLED] displays the results in the UI
     *
     * @param  {type} str     - string searched
     * @param  {categoriesResultsType[]} results - results search
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.showResults = function(str, results) {
        var wrapperDom, strResultText, resultsCountDom, categoriesContainerDom;
        var self = this;
        var container = this.container;
        var ctrl = this.controller;

        this.toggleLoading(false);
        container.textContent = '';

        self.qsApi.logSearchResults(ctrl.count, str, 'elasticsearch', 'thisProject');
        if (ctrl.count > 0) {
            wrapperDom = document.createElement('div');
            wrapperDom.className = 'result-count';

            strResultText = viewerNameSpace.i18n.translate('Results Count');

            strResultText = strResultText.split('{0}').join(ctrl.count);
            strResultText = strResultText.split('{1}').join(str);
            strResultText = strResultText.split('{2}').join(self.options.serverSearchTab.displayName);

            resultsCountDom = document.createElement('span');
            resultsCountDom.id = 'result-count-this-project';
            resultsCountDom.textContent = strResultText;

            wrapperDom.appendChild(resultsCountDom);
            container.appendChild(wrapperDom);

            categoriesContainerDom = document.createElement('div');
            categoriesContainerDom.className = 'categories-results-container dockingPanelScroll';
            container.appendChild(categoriesContainerDom);
            self.categoriesContainerDom = categoriesContainerDom;
            self.contextMenu = document.createElement('div');
            self.contextMenu.className = 'context-menu hidden';
            container.appendChild(self.contextMenu);

            results.forEach(function(category, index) {
                var categoryResultDom, categoryNameDom, resultListDom, moreItemDom;

                categoryResultDom = document.createElement('div');
                categoryResultDom.id = 'category_' + category.name;
                categoryResultDom.className = 'category-results';

                categoryNameDom = document.createElement('label');
                categoryNameDom.className = 'category-name';
                categoryNameDom.setAttribute('adskCatId', category.name);
                categoryNameDom.setAttribute('adskCatIndex', index);

                categoryNameDom.addEventListener('click', function(event) {
                    var catId = event.currentTarget.getAttribute('adskCatId');
                    var index = parseInt(event.currentTarget.getAttribute('adskCatIndex'), 10);
                    self.qsApi.logResultGeomClickEvent(index + 1, catId, false, 'thisProject');
                    self.toggleCategory(event);
                }, false);

                categoryNameDom.innerText = category.name;
                categoryResultDom.appendChild(categoryNameDom);

                resultListDom = document.createElement('ul');
                resultListDom.className = 'category-result-list';

                [].slice.call(category.categoryResults).forEach(function(catItem, index) {
                    var itemDom = document.createElement('li');
                    itemDom.className = 'item-result';
                    // FIXME(jwo): Replace .innerHTML w/ .textContent (need to check that it's pure text)
                    itemDom.innerHTML = catItem.name;
                    itemDom.setAttribute('adskItemId', catItem.url);
                    itemDom.setAttribute('adskItemIndex', index);
                    itemDom.addEventListener('click', function(event) {
                        var itemId = event.currentTarget.getAttribute('adskItemId');
                        var index = parseInt(event.currentTarget.getAttribute('adskItemIndex'), 10);
                        self.qsApi.logResultClickEvent(index + 1, itemId, false, 'thisProject');
                        self.openMenu(event, catItem);
                    }, false);
                    resultListDom.appendChild(itemDom);
                });

                if (category.moreItems) {
                    moreItemDom = document.createElement('li');
                    moreItemDom.className = 'more-items item-result';
                    moreItemDom.textContent = viewerNameSpace.i18n.translate('Load More');
                    moreItemDom.addEventListener('click', function(event) {
                        self.qsApi.logLoadMoreClickEvent(category.name, 'thisProject');
                        self.loadMoreItems(event, category);
                    }, false);
                    resultListDom.appendChild(moreItemDom);
                }

                categoryResultDom.appendChild(resultListDom);
                categoriesContainerDom.appendChild(categoryResultDom);
            });
        } else {
            showNoResults(self, container, str, self.options.serverSearchTab.displayName);
        }

    };

    /**
     * Server side search
     *
     * @param  {string} str      - string to search
     * @param  {function} cb - after getting the results this func will be called (Optional): function(CategoriesSearchResultsType)
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.search = function(str, cb) {
        var self = this;
        var ctrl = this.controller;
        var strTrimmed = str.trim();

        this.clearSearch();

        if (!this.searchParams.pid || !this.searchParams.filters) {
            self.displayMessage(MESSAGE_FEATURE_NOT_CONFIGURED);
            return;
        }

        if (strTrimmed) {
            if (this.options.uiEnabled) {
                this.toggleLoading(true);
            }

            this.controller.search(this.searchParams.pid, strTrimmed, 'dateModifiedDescending', this.searchParams.filters, 1, function(results) {

                if (self.options.uiEnabled) {
                    self.showResults(strTrimmed, results);
                } else {
                    cb({
                        page: 1,
                        results: results,
                        resultsCount: ctrl.count
                    });
                }
            });
        }
    };

    /**
     * displays a message provided
     *
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.displayMessage = function(message) {
        var containerDom, messageDisplayDom;

        if (this.container && this.options.uiEnabled) {
            containerDom = this.container;
            this.toggleLoading(false);
            containerDom.textContent = '';

            messageDisplayDom = document.createElement('p');
            messageDisplayDom.className = 'display-message';
            messageDisplayDom.textContent = message;

            containerDom.appendChild(messageDisplayDom);
        }
    };

    /**
     * clears the search data
     *
     */
    viewerSearchNameSpace.InViewerSearchThisProject.prototype.clearSearch = function() {
    var containerDom;

        if (this.container && this.options.uiEnabled) {
            containerDom = this.container;
            containerDom.textContent = '';
            this.toggleLoading(false);
        }

    };

    function Controller(qsApi) {
        var ctrl = this;
        var string = null;
        var actualParameters = {};
        var actualCategory = '';
        var next = {};
        //var categories = [];
        //var total = 0;
        //var filters = '';

        ctrl.categories = null;
        ctrl.categoriesIndex = {};
        ctrl.count = 0;
        ctrl.projectResults = null;

        /**
         * transform the search results and store them in ctrl.categories collection.
         * ctrl.categories: [{name, categoryResults}]
         * @param result
         */
        function translateResults(result, cb) {
            var categories = [];
            //var moreItems = false;

            if (result) {
                result.forEach(function(group) {
                    var category;

                    if (group.suggestionCount > 0) {
                        category = {
                            modifier: group.modifier,
                            name: group.displayName,
                            categoryResults: [],
                            moreItems: group.suggestionCount > 3,
                        };

                        group.suggestions.forEach(function(suggestion) {
                            var categoryResult = {
                                name: qsApi.sanitizeAndHighlightString(suggestion.title, '<b>', '</b>'),
                                logClick: suggestion.logClick,
                                url: suggestion.url,
                                resultData: suggestion
                            };

                            category.categoryResults.push(categoryResult);
                        });

                        ctrl.count = ctrl.count + group.suggestionCount;
                        categories.push(category);
                        ctrl.categoriesIndex[category.name] = categories.length - 1;
                    }
                });

                ctrl.categories = categories;
            }

            cb(ctrl.categories); return;
        }

        /**
         * if the response from QsApi is success
         * @param status
         * @param result
         * @returns {boolean}
         */
        function handleResult(err, result, cb) {

            if (!err) {
                if (result && result.suggestionGroups) {
                    translateResults(result.suggestionGroups, cb);
                }
            } else {
                qsApi.logErrorEvent('Error getting suggestions: ' + err, 'in_viewer_search_this_project', 'handleResult', 'thisProject');
                // TODO(jwo): Call the cb w/ the error, so the upsteam caller can properly handle (or squash) the error.
                cb([]);
            }
        }

        /**
         * calls to QsApi to get the search results
         * @param query
         * @param sort
         * @param filters
         * @param page
         */
        ctrl.search = function(pid, query, sort, filters, page, cb) {

            if (page === 1) {
                ctrl.categories = null;
                ctrl.count = 0;
                next = {};
            }

            string = query;

            actualParameters = {
                query: query,
                sort: sort,
                filters: filters,
            };

            var start = +new Date();
            qsApi.search(pid, query, sort, filters, page, function(err, result) {
                qsApi.logTimeEvent("searchTime", (new Date() - start), 'thisProject');
                handleResult(err, result, cb);
            }, 'thisProject');
        };

        ctrl.uninitialize = function() {};

        /**
         * Retrieves the next page results
         * @param err
         * @param result
         */
        function loadMoreResults(err, result, cb) {
            var newPage, moreItems, categoryResults;

            if (err) {
                qsApi.logErrorEvent('Error getting more item results: ' + err, 'in_viewer_search_this_project', 'loadMoreResults', 'thisProject');
                // FIXME(jwo): cb() is never called.
                // TODO(jwo): Return an error message to the callback. cb(err, data) is the standard form of callback where atleast one is always null. Data is an object containing /ALL/ of the return variables besides the err.
            } else {
                if (result && result.queryResults) {
                    newPage = [];
                    categoryResults = ctrl.categories[ctrl.categoriesIndex[actualCategory]].categoryResults;

                    result.queryResults.forEach(function(queryResult) {
                        var cat = {
                            name: qsApi.sanitizeAndHighlightString(queryResult.title, '<b>', '</b>'),
                            logClick: queryResult.logClick,
                            url: queryResult.url,
                            resultData: queryResult
                        };

                        newPage.push(cat);

                        categoryResults.push(cat);
                    });

                    moreItems = result.queryResultCount > categoryResults.length;

                    cb(newPage, moreItems); return;
                }
            }
        }

        /**
         * Gets the next page of results
         * @param page
         * @param modifierId
         */
        ctrl.getMoreResults = function(pid, category, modifier, cb, page) { // TODO(jwo): Move cb to last property. This allows inline anonymous functions to be the last variable in a function call.
            var nextPage = 2;

            actualCategory = category;

            if (next.hasOwnProperty(category.name)) {
                nextPage = next[category.name];
            }

            if (page) {
                nextPage = page;
            }

            qsApi.getMoreResults(pid, modifier, actualParameters.query, actualParameters.sort, actualParameters.filters, nextPage, function(err, result) {
                loadMoreResults(err, result, cb);
            });

            if (!page) {
                next[category.name] = nextPage + 1;
            }
        };

    }

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function() {
    'use strict';

    var viewerNameSpace = Autodesk.Viewing;
    var viewerPrivateNameSpace = Autodesk.Viewing.Private;
    //var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    //var viewUINameSpace = Autodesk.Viewing.UI;
    var viewerSearchNameSpace = new AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    /**
     * @typedef SearchResultType
     * @property {string} dbId - geometry node dbId
     * @property {string} fieldName - property field name
     * @property {string} fieldValue - property field value
     * @property {string} nodeName - geometry node name
     * @property {string} displayName - string representing the result label 'nodeName (fieldName: fieldValue)'. Highlighting the searched string.
     */

     /**
      * @typedef SearchResultsType
      * @property {number} page - page number
      * @property {SearchResultType[]} results - result list
      * @property {number} resultCount - the total amount of results
      * @property {boolean} moreResults - true is there are more results
      */

      /**
       * @typedef SearchResultBruteType
       * @property {number} id - node dbId
       * @property {string} name - property field name
       * @property {string} value - property field value
       * @property {string} nodeName - geometry node name
       */

    var _this;

    /**
     * InViewerSearchThisView
     */
    viewerSearchNameSpace.InViewerSearchThisView = function(viewer, options) {
        _this = this;
        this.options = options;
        this.viewer = viewer;
        this.container = null;
        this.initialized = false;
        this.controller = null;
        this.resultList = null;
        this.extensionViewer = null;
        this.clicked = null;
        this.is2DMode = null;
        this.qsApi = null;
        this.highlightNode = null;
        this.scrollOffset = 500;
        this.limitScroll = 200;
        this.limit = options.loadedModelTab.pageSize;
        this.offset = 0;
        this.mouseClickTimeout = null;

        this.loadingId = 'this-view-loading';
        this.loadingDom = null;
        this.resultsDom = null;
        this.resultCountDOM = null;
    };

    //viewerSearchNameSpace.InViewerSearchThisView.prototype = Object.create(viewerNameSpace.Extension.prototype);
    viewerSearchNameSpace.InViewerSearchThisView.prototype.constructor = viewerSearchNameSpace.InViewerSearchThisView;

    /**
     * initialize this view search
     *
     * @param  {QsApiService} qsApi            - QsApiService initialized
     * @param  {ViewerPropertiesService} viewerProperties - viewer initialized
     * @param  {string} currentGeometry  - geometry guid of the geometry loaded in the viewer
     * @param  {boolean} is2D             - true id model is 2D
     * @param  {string} container      - html container
     * @param  {function} cb         - after initialized will be called
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.initialize = function(qsApi, viewerProperties, currentGeometry, is2D, container, cb) {
        var self = this;
        var viewer = this.viewer;

        if (this.options.uiEnabled) {
            this.container = container;
            this.container.addEventListener('click', this.clickHandler);
            this.container.addEventListener('dblclick', this.clickHandler);
            this.container.addEventListener('hover', this.clickHandler);
        }

        this.is2DMode = is2D;
        this.qsApi = qsApi;

        this.controller = new Controller(viewer, qsApi, viewerProperties, currentGeometry);
        this.controller.initializeAllAttributes(function() {
            self.initialized = true;
            if (self.options.uiEnabled && self.viewer && self.viewer.getPropertyPanel) {
                self.extensionViewer = self.viewer.getPropertyPanel(true);
            }
            var containerId = (container && container.id) ? container.id : container;
            cb(containerId, self.initialized); return;
        });
    };

    viewerSearchNameSpace.InViewerSearchThisView.prototype.uninitialize = function() {

        if (this.options.uiEnabled) {
            this.container.removeEventListener('click', this.clickHandler);
            this.container.removeEventListener('dblclick', this.clickHandler);
            this.container.removeEventListener('hover', this.clickHandler);
        }

        if (this.controller) {
            this.controller = null;
        }
    };


    var fnHandleClicks = function(event) {
        var searchDbId, searchIndex;
        var node = event.target, found = false;

        while (node && this.container !== node && !found) {
            found = node.hasAttribute('adskSearchDbId');
            if (!found) { node = node.parentNode; }
        }

        if (found) {
            searchDbId = parseInt(node.getAttribute('adskSearchDbId'), 10);
            searchIndex = parseInt(node.getAttribute('adskSearchIndex'), 10);

            if (event.type === 'click') {
                _this.showNodeProperties(event, searchDbId, searchIndex);
            } else if (event.type === 'dblclick') {
                _this.showNodeProperties(event, searchDbId, searchIndex, true);
                _this.viewer.fitToView();
            } else if (event.type === 'hover') {
                _this.viewer.impl.rolloverObjectNode(searchDbId);
            }
        }
    };

    viewerSearchNameSpace.InViewerSearchThisView.prototype.clickHandler = function(event) {
        if (!event) {
            return;
        }

        // Working around both click and dblClick events arriving (SRCH-1169)
        clearTimeout(_this.mouseClickTimeout);
        _this.mouseClickTimeout = setTimeout(function() { fnHandleClicks.call(_this, event); }, 200);
    };

    /**
     * searches into the property values of the geometry loaded in the viewer
     *
     * @param  {string} str  - string to search
     * @param  {function} cb  - function to be called with the results as a parameter function(SearchResultsType)
     * @param  {number} node - if redirecting front this item tab (Optional, UI)
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.search = function(str, cb, node) {
        // FIXME(jwo): Move above `cb` to last parameter of the function. Callbacks are generally last so inline anonymous functions aren't followed by additional parameters.
        //var viewer = this.viewer;
        var self = this;
        var ctrl = this.controller;
        var strTrimmed = str.trim();

        this.clearSearchResults();

        if (strTrimmed) {
            self.resultList = null;

            if (this.options.uiEnabled) {
                this.toggleLoading(true);
                this.highlightNode = node;
            }

            this.controller.doSearch(strTrimmed, function(strTrimmed, results, ended) {
                var res;

                if (self.options.uiEnabled) {
                    self.showResults(strTrimmed, results, ended);
                } else {
                    processResults(self, strTrimmed, results, ended);

                    if (ended) {
                        res = {
                            page: 1,
                            results: ctrl.totalResults.slice(0, self.limit),
                            resultsCount: ctrl.resultsCount,
                            moreResults: ctrl.resultsCount > self.limit
                        };
                        cb(res); return;
                    }
                }
            });
        }
    };

    var setSelectedNode = function(self, item) {
        var selected, item;

        selected = self.selectedNode;

        if (selected) {
            selected.classList.remove('selected');
        }

        if (item) {
            self.selectedNode = item;
            if (item) {
                item.classList.add('selected');
            }
        }
    };

    /**
     * [UI ENABLED] after clicking on a result the properties are shown
     * (if the result is already clicked we hide the properties)
     *
     * @param  {object} event    - click event
     * @param  {string} nodeId   - node id of the selected result
     * @param  {number} position - position in the result list
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.showNodeProperties = function(event, nodeId, position, showExtensionViewer) {
        var self = this;
        this.qsApi.logResultClickEvent(position + 1, nodeId, true, 'thisView');

        if (this.clicked === nodeId) {
            this.clicked = null;
            this.viewer.clearSelection();

            if (this.is2DMode) {
                this.viewer.select(this.controller.searchResultIds);
            } else {
                this.viewer.isolate(this.controller.searchResultIds);
            }

            if (this.extensionViewer && this.extensionViewer.container) {
                this.extensionViewer.setVisible(!!showExtensionViewer);
            }

            if (showExtensionViewer) {
                setSelectedNode(self, event.target, event);
            } else {
                setSelectedNode(self, null);
            }

        } else {
            this.selectNode(event.target, nodeId, false);
        }
    };

    /**
     * The callback is called if the node is visible
     *
     * @param  {type} nodeId node id
     * @param  {type} cb     callback function
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.isNodeVisible = function (nodeId, cb) {
        var self = this;
        if (this.is2DMode) {
            cb();
            return;
        }

        if (this.viewer.model && this.viewer.model.getData()) {
            var instanceTree = this.viewer.model.getData().instanceTree;
            if (instanceTree) {
                var fragments = instanceTree.nodeAccess.enumNodeFragments(nodeId, function(frag) {
                    cb();
                    return;
                });
            }
        }

    }

    /**
     * [UI ENABLED] after clicking on a result the properties are shown
     * (if the result is already clicked we hide the properties)
     *
     * @param  {string} nodeId   - node id of the selected result
     * @param  {boolean} doScroll - scroll to the position in the list
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.selectNode = function(item, nodeId, doScroll) {
        var self = this;
        var finished = false;
        var ctrl = this.controller;
        var i;
        var items;

        if (this.nodeNotVisibleAlert) {
            clearTimeout(this.nodeNotVisibleAlertTimer);
            document.body.removeChild(this.nodeNotVisibleAlert);
            this.nodeNotVisibleAlert = null;
        }

        this.clicked = nodeId;
        if (!item && this.container.children.length > 1) {

            items = this.container.children[1].children;
            length = items.length;
            i = 0;
            while (!finished && i < length) {
                if (items[i].className.indexOf("dbId_" + nodeId + "_") >= 0) {
                    finished = true;
                    item = items[i];
                }
                i++;
            }
        }

        if (this.is2DMode) {
            this.viewer.select(nodeId);
        } else {
            this.viewer.isolate(nodeId);
        }

        if (this.extensionViewer &&  this.extensionViewer.container) {
            this.extensionViewer.setVisible(true);
        }

        setSelectedNode(self, item);

        if (doScroll) {
            if (item && item.parentNode) {
                item.parentNode.scrollTop = item.offsetTop;
            }
        }

        if (!item && ctrl.searchResultIds.indexOf(nodeId) < 0 ) {
            //node is not visible
            this.clicked = null;
            this.showAlertNodeNotVisible(self.container);
        }
    };


    function appendItem(self, item, containerDom, index) {
        var resultDom = document.createElement('li');

        resultDom.innerHTML = item.displayNameSanitized;
        resultDom.setAttribute('adskSearchDbId', item.dbId);
        resultDom.setAttribute('adskSearchIndex', index);
        resultDom.className = 'in-viewer-search-item item-result ' + 'dbId_' + item.dbId + "_";

        if (self.highlightNode === item.dbId) {
            //we have to add here the class because it isn't appended in the container yet
            self.selectedNode = resultDom;
            resultDom.className = resultDom.className + ' selected';
            self.selectNode(resultDom, item.dbId, true);
        }
        self.resultsDom = resultDom;
        containerDom.appendChild(resultDom);
    }

    /**
     * clears search data
     *
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.clearSearchResults = function() {

        this.offset = 0;
        this.scrollOffset = 500;
        this.limitScroll = 200;
        this.clicked = null;
        this.selectedNode = null;
        this.highlightNode = null;

        if (this.options.uiEnabled) {
            if (this.container) {
                this.container.textContent = '';
            }

            if (this.controller && this.controller.searchResultIds && this.controller.searchResultIds.length > 0) {
                if (!this.is2DMode) {
                    try {
                        // TODO(jwo): Is there specific conditions we can check for so we don't need a try/catch?
                        this.viewer.showAll();
                    } catch(e) {
                        viewerPrivateNameSpace.logger.error(e);
                    }
                }

                this.toggleLoading(false);
                this.viewer.clearSelection();
                this.controller.searchResultIds = [];
                this.resultList = null;
            }

            this.loadingDom = null;
            this.resultsDom = null;
            this.resultCountDOM = null;
        }
    };

    /**
     * [UI ENABLED] shows/hides loading message
     *
     * @param  {boolean} loading - if true shows else hides
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.toggleLoading = function(loading) {
        var loadingDom = this.loadingDom;

        if (loading && !loadingDom) {
            loadingDom = document.createElement('div');
            loadingDom.id = this.loadingId;
            loadingDom.className = 'loading';
            loadingDom.textContent = viewerNameSpace.i18n.translate('Loading');
            this.loadingDom = loadingDom;
            this.container.appendChild(loadingDom);
        } else if (loadingDom) {
            if (loadingDom.parentNode) {
                loadingDom.parentNode.removeChild(loadingDom);
            }
            this.loadingDom = null;

        }
    };


    /**
     * [UI ENABLED] loads the next page of results
     *
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.loadMoreResults = function() {
        var nextLastIndex, i;
        var ctrl = this.controller;
        var self = this;
        var offset = this.offset;
        var length = ctrl.resultsCount;

        if (length > offset) {
            nextLastIndex = (offset + self.limit);
            for (i = offset; i < nextLastIndex; i++) {
                if (length > i) {
                    appendItem(self, ctrl.totalResults[i], self.resultList, i);
                }
            }

            self.offset = offset + self.limit;
        }
    };

    /**
     * Returns the page of results
     *
     * @param  {number} pageNumber - page to be returned
     * @param  {function} cb   - function to be called passing the results as a parameter: function(SearchResultType[])
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.getPage = function(pageNumber, cb) {
        var results, returnVal;
        var ctrl = this.controller;
        var self = this;
        var offset = self.limit * (pageNumber - 1);

        if (ctrl.resultsCount > offset) {
            results = ctrl.totalResults.slice(offset, offset + self.limit);

            returnVal = {
                page: pageNumber,
                results: results,
                resultsCount: ctrl.resultsCount,
                moreResults: ctrl.resultsCount > (offset + self.limit)
            };


        } else {
            returnVal = {
                page: pageNumber,
                results: [],
                resultsCount: ctrl.resultsCount,
                moreResults: false
            };
        }

        setTimeout(function() { cb(returnVal); return; }, 0); // Explicitly move cb to async
    };


    function showNoResults(self, container, str, contextName) {
        var noResultsDOM, strResultText;

        container.textContent = ''; // Clear container

        strResultText = viewerNameSpace.i18n.translate('No Results')
            .split('{0}').join(str) // TODO(jwo): Move to templating function
            .split('{1}').join(contextName);

        noResultsDOM = document.createElement('p');
        noResultsDOM.className = 'search-no-results';
        noResultsDOM.textContent = strResultText;

        container.appendChild(noResultsDOM);
    }

    function getDisplayName(self, item, ctrl, str) {
        var itemValue, nodeName, displayNameSanitized;

        nodeName = item.nodeName;

        if (!nodeName && self.viewer.model.myData.instanceTree) {
            nodeName = self.viewer.model.myData.instanceTree.getNodeName(item.dbId);
        }

        if (!nodeName) {
            nodeName = ctrl.viewerProperties.defaultNodeName();
        }

        if (nodeName.indexOf(str) >= 0 || (item.hasOwnProperty('fieldName') && item.fieldName === "Name")) {
            displayNameSanitized = ctrl.viewerProperties.highlightText(nodeName, str);
        } else {
            if (item.hasOwnProperty('fieldName') && item.hasOwnProperty('fieldValue')) {
                itemValue = (Object.prototype.toString.call(item.fieldValue) === '[object Number]' ? String(item.fieldValue) : item.fieldValue);

                // highlightText() is called to sanitize the text, and to do actual highlighting in for itemValue
                displayNameSanitized = ctrl.viewerProperties.highlightText(nodeName) + ' (' + ctrl.viewerProperties.highlightText(item.fieldName) + ': ' + ctrl.viewerProperties.highlightText(itemValue, str) + ')';
            } else {
                // highlightText() is called to sanitize the text
                displayNameSanitized = ctrl.viewerProperties.highlightText(nodeName);
            }
        }

        return displayNameSanitized;
    }

    function updateResultsCount(count, self) {
        var term, ctx, strResultText, resultCountDOM;

        resultCountDOM = self.resultCountDOM;

        if (!resultCountDOM) {
            return;
        }

        term = resultCountDOM.getAttribute('term');
        ctx = resultCountDOM.getAttribute('ctx');

        strResultText = viewerNameSpace.i18n.translate('Results Count');
        strResultText = strResultText.split('{0}').join(count);
        strResultText = strResultText.split('{1}').join(term);
        strResultText = strResultText.split('{2}').join(ctx);

        resultCountDOM.textContent = strResultText;
    }

    function processResults(self, str, results, ended) {
        var wrapperDom, resultCountDom, strResultText, displayNameSanitized, nodeItem;
        var containerDom = self.container;
        var ctrl = self.controller;
        var length = results.length;
        var limit = self.limit;
        var offset = self.offset;
        var nextLastIndex = offset + limit;

        if (length < limit) {
            nextLastIndex = offset + length;
        }

        if (length) {
            if (self.options.uiEnabled) {
                self.toggleLoading(false);

                if (!self.resultList) {
                    // Clear containerDom
                    containerDom.textContent = '';

                    wrapperDom = document.createElement('div');
                    wrapperDom.className = 'result-count';

                    resultCountDom = document.createElement('span');
                    resultCountDom.id = 'result-count-this-view';
                    resultCountDom.setAttribute('term', str);
                    resultCountDom.setAttribute('ctx', self.options.loadedModelTab.displayName);

                    strResultText = viewerNameSpace.i18n.translate('Results Count');

                    resultCountDom.textContent = strResultText.split('{0}').join(length)
                        .split('{1}').join(str)
                        .split('{2}').join(self.options.loadedModelTab.displayName);

                    self.resultCountDOM = resultCountDom;
                    wrapperDom.appendChild(resultCountDom);
                    containerDom.appendChild(wrapperDom);

                    self.resultList = document.createElement('ul');
                    self.resultList.className = 'search-result-list dockingPanelScroll';

                    self.resultList.addEventListener('scroll', function() {
                        if (this.scrollTop > self.scrollOffset) {
                            self.loadMoreResults();
                            self.scrollOffset = self.scrollOffset + self.limitScroll;
                        }
                    });

                    containerDom.appendChild(self.resultList);
                }
            }

            results.slice(offset, length).forEach(function(item, i) {
                if (!item.hasOwnProperty("dbId")) {
                    item = {
                        fieldName: item.name,
                        fieldValue: item.value,
                        dbId: item.id,
                        nodeName: item.nodeName
                    }
                }

                self.isNodeVisible(item.dbId, function() {
                    //we show the nodes that are visible in the results for this view
                    if (!ctrl.searchedIds.hasOwnProperty(item.dbId)) {
                        displayNameSanitized = getDisplayName(self, item, ctrl, str);

                        nodeItem = { displayNameSanitized: displayNameSanitized, dbId: item.dbId, fieldName: item.fieldName, fieldValue: item.fieldValue };

                        ctrl.totalResults.push(nodeItem);
                        ctrl.searchResultIds.push(item.dbId);
                        ctrl.searchedIds[item.dbId] = 1;
                        ctrl.resultsCount++;

                        if (self.options.uiEnabled) {
                            if (ctrl.resultsCount <= limit && offset < nextLastIndex) {
                                appendItem(self, nodeItem, self.resultList, i);
                                offset = offset + 1;
                            }
                        }
                    }
                });
            });

            self.offset = offset;

            if (self.options.uiEnabled) {
                updateResultsCount(ctrl.resultsCount, self);
            }
        }
    }

    viewerSearchNameSpace.InViewerSearchThisView.prototype.showAlertNodeNotVisible = function(container) {
        var self = this;
        var alert = document.createElement("div");
        alert.className = "alert-node-not-visible";
        alert.textContent = viewerNameSpace.i18n.translate('AlertNodeNotVisible');
        document.body.appendChild(alert);
        this.nodeNotVisibleAlertTimer = setTimeout(function() {
            if (alert) {
                document.body.removeChild(self.nodeNotVisibleAlert);
                self.nodeNotVisibleAlert = null;
            }
        }, 7000);

        this.nodeNotVisibleAlert = alert;
    }

    /**
     * [UI ENABLED] displays the results list
     *
     * @param  {string} str     - searched string
     * @param  {SearchResultBruteType[]} results - results list
     * @param  {boolean} ended   - the search is done
     */
    viewerSearchNameSpace.InViewerSearchThisView.prototype.showResults = function(str, results, ended) {
        var self = this;
        var ctrl = this.controller;
        var container = self.container;

        processResults(self, str, results, ended);

        if (ctrl.searchResultIds && ctrl.searchResultIds.length) {
            if (self.is2DMode) {
                if (self.highlightNode) {
                    self.viewer.select(self.highlightNode);
                } else {
                    self.viewer.select(ctrl.searchResultIds);
                }

            } else {
                if (self.highlightNode) {
                    self.viewer.isolate(self.highlightNode);
                    self.viewer.select(self.highlightNode);
                } else {
                    self.viewer.isolate(ctrl.searchResultIds);
                }
            }
        }

        if (ended && (ctrl.resultsCount < 1 || !self.resultList.childNodes.length)) {
            self.toggleLoading(false);
            showNoResults(self, container, str, self.options.loadedModelTab.displayName);
        }

        if (ended && self.highlightNode) {
            if (!ctrl.searchedIds.hasOwnProperty(self.highlightNode)) {
                //the node is not visible
                this.selectNode(null, self.highlightNode, false);
            }
        }

        if (ended) {
            ctrl.searchedIds = {}; //cleaning up
        }

        ctrl.searchEnded = ended;
    };

    // Logic
    function Controller(viewer, qsApi, viewerProperties, currentGeometry) {
        var ctrl = this;
        var initStart = null;

        ctrl.initialized = false;
        ctrl.searchResultIds = [];
        ctrl.searchedIds = {};
        ctrl.resultsCount = 0;
        ctrl.totalResults = [];
        ctrl.searchEnded = null;
        ctrl.viewerProperties = viewerProperties;
        ctrl.bigModel = false;
        ctrl.isSharedPropertyDb = false;

        /**
         * after initialized ready will be called
         */
        function ready() {
            var duration = new Date().getTime() - initStart;

            viewerPrivateNameSpace.logger.log('Execution time INIT: ' + duration);
            qsApi.logTimeEvent("initTime", duration, 'thisView');
            ctrl.initialized = true;
        }

        /**
         * when the geometry is big we call the search implemented in the viewer that returns the ids of the nodes that
         * matched the search
         * @param str
         * @param cb
         */
        function bruteSearch(str, cb) {
            var start = new Date().getTime();

            var onSuccessCb = function(results) {
                ctrl.searchEnded = true;
                qsApi.logTimeEvent('bruteSearchTime', (new Date().getTime() - start), 'thisView');
                qsApi.logSearchResults(results.length, str, 'bruteSearch', 'thisView');
                cb(str, results, true); return;
            };

            var onErrorCb = function() { // TODO(jwo): shouldn't viewer.search() send an error message back to this OnErrorCb()?
                qsApi.logErrorEvent('LMV search bruteForceSearch failed', 'in_viewer_search_this_view', 'bruteSearch', 'thisView');
                // TODO(jwo): Call cb() w/ an error message so the callee can know the search failed and respond appropriately
            };

            //viewer.search(str, onSuccessCb, onErrorCb, [], true);
            ctrl.viewerProperties.bruteSearchCurrent(str, onSuccessCb, onErrorCb);
        }

        /**
         * returns true if the node count exceeds maxSize
         * @returns {boolean}
         */
        function isBigModel() {
            var isBig = ctrl.viewerProperties.tooManyNodes(true);
            return isBig;
        }

        /**
         * if the geometry is not big, it gets the attributes/properties for the geometry and initialize the viewerProperties
         * if it is big, just initialize the viewerOptions
         */
        ctrl.initializeAllAttributes = function(onReady) {
            initStart = new Date().getTime();
            ctrl.bigModel = isBigModel();

            if (!currentGeometry) {
                ctrl.bigModel = true;
            }

            if (!ctrl.bigModel) {
                ctrl.viewerProperties.getCurrentGeometryAttributes(function() {
                    ready();
                    onReady();
                    return;
                });
            } else {
                ready();
                onReady();
            }
        };

        /**
         * if the model is big calls bruteSearch
         * if not, calls viewerProperties search
         * @param str
         * @param cb
         */
        ctrl.doSearch = function(str, cb) {
            var start;

            ctrl.searchResultIds = [];
            ctrl.searchedIds = {};
            ctrl.resultsCount = 0;
            ctrl.totalResults = [];
            ctrl.searchEnded = false;

            if (ctrl.bigModel) {
                bruteSearch(str, cb);
            } else {
                start = new Date().getTime();

                ctrl.viewerProperties.doSearch(str, function(str, resultObj, ended) {
                    var partialResults = [];
                    if (resultObj && resultObj.totalResults.length){
                        partialResults = resultObj.totalResults[resultObj.totalResultsIndex[currentGeometry]].results;
                    }

                    if (ended) {
                        qsApi.logTimeEvent('searchTime', (new Date().getTime() - start), 'thisView');
                        qsApi.logSearchResults(ctrl.resultsCount.length, str, 'fullproof-StringSearch', 'thisView');
                    }

                    cb(str, partialResults, ended); return;
                });
            }
        };
    }

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function(){
    "use strict";

    var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    var viewerPrivateNameSpace = Autodesk.Viewing.Private;
    var viewerSearchNameSpace = AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    /* CONSTANT */
    var APPLICATION_ID = 'adsk.viewer';

    /**
     * QsApi is a service that interacts with qs-api library
     * @constructor
     */
    viewerSearchNameSpace.QsApiService = function () {
        this.qsAPI = null;
    };

    var proto = viewerSearchNameSpace.QsApiService.prototype;

    var params = {
            pid: '',        // profile id
            query: '',      // query string
            sort: '',
            page: 1,
            filters: '',
            language: 'ENU',
            modifier: null
    };

    var sessionInfo = {};
    var queryStr = null;
    var queryId = null;
    var envLMV = null;
    var viewerBuildId = null;

    var lmvToSearchEnv = Object.freeze({
        development: 'apidev',
        staging: 'apistg',
        production: 'apiprod',
        autodeskstaging: 'apistg',
        autodeskdevelopment: 'apidev',
        autodeskproduction: 'apiprod',
    });

    /**
     * Creates a new instance of SearchQueryAPI
     * @param authToken - user token
     * @param environment - dev/stg/prod
     * @param appId -
     * @param sessionId -
     * @param modelSize -
     */
    proto.initialize = function(viewerBuildIdArg, environment, appId, sessionId){
        sessionInfo = {
            token: null,
            oauth2Token: null,
            clientId: appId,
            sessionId: sessionId,
            clientFeatureId: "",
        };

        viewerBuildId = viewerBuildIdArg;

        envLMV = environment.toLowerCase();

        this.qsAPI = new Autodesk.Search.SearchQueryAPI(lmvToSearchEnv[envLMV]);
    };

    function getSessionInfo(tabName) {

        if (!envLMV) {
            return sessionInfo;
        }

        if (envLMV.indexOf('autodesk') >= 0) {     // TODO(go) -- 20160601 - is there a better way to decide is it's oauth2 or 1?
            sessionInfo.token = null;
            sessionInfo.oauth2Token = viewerPrivateNameSpace.token.accessToken;
        } else {
            sessionInfo.token = viewerPrivateNameSpace.token.getAccessToken ? viewerPrivateNameSpace.token.getAccessToken() : null;
            sessionInfo.oauth2Token = null;
        }

        if (tabName) {
            sessionInfo.clientFeatureId = APPLICATION_ID + (tabName ? ("." + tabName) : "");
        }

        return sessionInfo;
    }

    function loggedCb(err){
        if (err) {
            viewerPrivateNameSpace.logger.log('InViewerSearch Extension: QsApi not initialized');
        }
    }

    /**
     * generate UUID to be used as query ID
     */
    proto.generateQueryId = function(){
        var d = new Date().getTime();

        if (window.performance && typeof window.performance.now === 'function') {
            d += performance.now(); //use high-precision timer if available
        }

        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = (d + Math.random()*16)%16 | 0;
            d = Math.floor(d/16);
            return (c=='x' ? r : (r&0x3|0x8)).toString(16);
        });
        queryId = uuid;
    };

    /**
     * helper to get the browser name
     * @returns {string}
     */
    function browser() { // TODO(jwo): Is there a library we can pull in to do this? This is seems fragile.
        // Chrome 1+
        var isChrome = !!window.chrome && !!window.chrome.webstore;
        if (isChrome) {
            return 'Chrome';
        }
        // Opera 8.0+
        var isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
        if (isOpera){
            return 'Opera';
        }
        // Firefox 1.0+
        var isFirefox = typeof InstallTrigger !== 'undefined';
        if (isFirefox){
            return 'Firefox';
        }
        // At least Safari 3+: '[object HTMLElementConstructor]'
        var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
        if (isSafari) {
            return 'Safari';
        }
        // Internet Explorer 6-11
        var isIE = /*@cc_on!@*/false || !!document.documentMode;
        if (isIE) {
            return 'Internet Explorer';
        }
        // Edge 20+
        var isEdge = !isIE && !!window.StyleMedia;
        if (isEdge){
            return 'Edge';
        }
        // Blink engine detection
        var isBlink = (isChrome || isOpera) && !!window.CSS;
        if (isBlink) {
            return 'Blink';
        }

        return 'Unknown';
    }

    /**
     * executes a search calling the suggest Api and calls handleResultSuccess or handleResultFailure depending on the response
     * @param query
     * @param sort
     * @param filters
     * @param page
     * @param handleResult - success callback
     */
    proto.search = function(pid, query, sort, filters, page, handleResult, tabName) {
        if (!this.qsAPI) {
            viewerPrivateNameSpace.logger.log('InViewerSearch Extension: QsApi not initialized');
        }

        queryStr = query;
        params.pid = pid;
        params.page = page;
        params.query = query;
        params.sort = sort;
        params.filters = filters;

        var sessionInfo = getSessionInfo(tabName);

        this.qsAPI.suggest(params, sessionInfo, handleResult);
    };

    /**
     * gets more results given the modifier identifier and query params
     * @param modifier
     * @param query
     * @param sort
     * @param filters
     * @param page
     * @param successCallback
     */
    proto.getMoreResults = function(pid, modifier, query, sort, filters, page, successCallback) {
        if (!this.qsAPI) {
            viewerPrivateNameSpace.logger.log('InViewerSearch Extension: QsApi not initialized');
        }

        queryStr = query;
        params.pid = pid;
        params.page = page;
        params.query = query;
        params.sort = sort;
        params.filters = filters;
        params.modifier = modifier;

        var sessionInfo = getSessionInfo();

        this.qsAPI.query(params, sessionInfo, successCallback);
    };

    /**
     * logs an event to the QS service
     * @param type
     * @param body
     */
    proto.logEvent = function(type, sessionInfo, body){
        if (this.qsAPI) {
            this.qsAPI.logEvent(queryId, sessionInfo, type, body, loggedCb);
        }
    };

    /**
     * This logs static information at initialization.
     * @param documentId - document ID
     * @param modelInfo - Information gathered about the model
     * @param tabName - thisProject, thisView, thisItem
     */
    proto.logInitEvent = function(documentId, modelInfo, tabName){
        var eventType = 'inViewer.initialization';

        var body = {
            viewerVersion: viewerBuildId,
            id: documentId,
            modelInfo: modelInfo,
            url: window.location.href,
            browser: browser(),
            userAgent: window.navigator.userAgent,
        };

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(eventType, sessionInfo, body);
    };

    /**
     * logs a click event on a result
     * @param position
     * @param tabName
     * @param documentId
     * @param nodeId
     * @param current
     */
    proto.logGeneralEvent = function(timerType, tabName){
        var timerEventType = 'inViewer.' + timerType;

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(timerEventType, sessionInfo, "");
    };

    /**
     * This logs times, for example init time in This Viewer tab
     * @param timerType - searchTime / bruteSearchTime
     * @param duration - in milliseconds
     * @param tabName - thisProject, thisView, thisItem
     */
    proto.logTimeEvent = function(timerType, duration, tabName){
        var timerEventType = 'inViewer.' + timerType;

        var body = { };
        body[timerType + 'DurationMs'] =  duration;

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(timerEventType, sessionInfo, body);
    };

    /**
     * logs the query data
     * @param count - amount of results
     * @param query - query string
     * @param documentId
     * @param algorithm - {bruteSearch - fullproof-StringSearch}
     * @param tabName - thisProject, thisView, thisItem
     */
    proto.logSearchResults = function(count, query, algorithm, tabName){
        var resultType = 'inViewer.searchResults';

        var body = {
                resultCount: count,
                queryString: query,
                algorithm: algorithm
            };

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(resultType, sessionInfo, body);
    };

    /**
     * logs a change tab event
     * @param tabName
     */
    proto.logTabClickEvent = function(tabName){
        var tabClickType = 'inViewer.tabClick';

        var body = null;

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(tabClickType, sessionInfo, body);
    };

    /**
     * logs a click event on a result
     * @param position
     * @param nodeId
     * @param current
     * @param tabName
     */
    proto.logResultClickEvent = function(position, nodeId, current, tabName) {
        var resultClickType = 'inViewer.resultClick';

        this.logResultComponentClickEvent(resultClickType, position, nodeId, current, tabName);
    };

    /**
     * logs a click event on a geometry (collapsible item that holds results for a geometry)
     * @param position
     * @param nodeId
     * @param current
     * @param tabName
     */
    proto.logResultGeomClickEvent = function(position, nodeId, current, tabName) {
        var resultClickType = 'inViewer.resultGeomClick';

        this.logResultComponentClickEvent(resultClickType, position, nodeId, current, tabName);
    };

    /**
     * utility function to handle click event on result components
     * @param resultClickType - resultClick / resultGeomClick
     * @param position
     * @param nodeId
     * @param current
     * @param tabName
     */
    proto.logResultComponentClickEvent = function(resultClickType, position, nodeId, current, tabName) {
        var body = {
            position: position, /* first result is at position '1' */
            nodeId: nodeId,
            clickedCurrentGeometry: current,
        };

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(resultClickType, sessionInfo, body);
    };

    /**
     * logs a click event on a "Load More" link
     * @param documentId
     * @param tabName
     */
    proto.logLoadMoreClickEvent = function(documentId, tabName){
        var resultClickType = 'inViewer.loadMoreClick';

        var body = {
            id: documentId
        };

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(resultClickType, sessionInfo, body);
    };

    /**
     * logs errors
     * @param message
     * @param file - file where it happen
     * @param method - file where it happen
     */
    proto.logErrorEvent = function(message, file, method, tabName){
        var timeType = 'inViewer.error';

        var body = {
                file: file,
                method: method,
                querySource: 'inViewer',
                message: message
            };

        var sessionInfo = getSessionInfo(tabName);

        this.logEvent(timeType, sessionInfo, body);

    };

    /**
     * highlights the string using the passed replaceStrings
     * @param str
     * @param replaceStart
     * @param replaceEnd
     * @returns {string html}
     */
    proto.sanitizeAndHighlightString = function(str, replaceStart, replaceEnd){
        return this.qsAPI.sanitizeAndHighlightString(str, replaceStart, replaceEnd);
    };

})();

/*
 * Copyright 2016 Autodesk, Inc. All Rights Reserved.
 *
 * This computer source code and related instructions and comments
 * are the unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under applicable copyright and trade secret law.
 * They may not be disclosed to, copied or used by any third party without the prior
 * written consent of Autodesk, Inc.
 */

(function(){ "use strict";

    var viewerNameSpace = Autodesk.Viewing;
    //var viewerExtensionsNameSpace = Autodesk.Viewing.Extensions;
    var viewerPrivateNameSpace = viewerNameSpace.Private;
    var viewerSearchNameSpace = AutodeskNamespace('Autodesk.Viewing.Extensions.InViewerSearch');

    /**
     * viewer property service encapsulates the logic to get the geometries properties
     * @constructor
     */
    viewerSearchNameSpace.ViewerPropertiesService = function() {
        var self = this;
        this.worker = undefined;
        this.viewerpropertiesworker = undefined;
        this.initialized = false;
        this.viewer = null;

        this.isGeometry = false;
        this.isSearching = false;
        this.isSearchingTimer = null;
        this.searchingString = "";
        this.searchingStringCb = null;
    };

    var proto = viewerSearchNameSpace.ViewerPropertiesService.prototype;

    var maxGeometriesToLoad = 300; //we dont load more than 300 geometries to prevent memory crash
    var bigAmountGeometries = 20; //if there are more than 20 geometries we consider that there are a big amount
    var geometriesCache = {};
    var current = null; //current geometry
    var geometriesFlat = null;
    var totalGeometries = 0;
    var qsApi = null;
    var maxNodeGeometryCount = 131000;
    var geometriesLoaded = 0;
    var sharedPropertyDbPath = null;
    var isSharedPropertyDb = false;
    var loadContext = {};
    var runningBruteSearch = false; //this is to avoid calling twice bruteSearch
    var successBruteSearchListener = null;
    var errorBruteSearchListener = null;
    var orderedGeometries = [];

    var SHARED_PROPERTY_KEY = "_sharedPropertyDatabase_";

    /**
     * Deletes the worker to prevent memory leaks and many workers
     */
    proto.uninitialize = function() {

        if (this.worker !== undefined) {
            this.worker.terminate();
            this.worker = undefined;
            self.viewerpropertiesworker = undefined;
        }
        this.initialized = false;
    };

    /**
     * given the geometry it gets the URN to get the property files
     * @param children
     * @returns {string}
     */
    function getUrnFromChildren(children) {
        var urn;

        if (!children) {
            viewerPrivateNameSpace.logger.warn("InViewerSearch Extension: No URN to retrieve from in getUrnFromChildren()");
        } else {
            [].slice.call(children).forEach(function(childDom) {
                if (!urn) {
                    urn = childDom.urn();

                    if (urn) {
                        urn = urn.substr(0, urn.lastIndexOf('/') + 1);

                        if (urn.indexOf("output/Resource") > 0) {
                            urn = urn.substr(0, urn.lastIndexOf('Resource') + 9);
                        }
                    }
                }
            });

            if (!urn) {
                viewerPrivateNameSpace.logger.warn("InViewerSearch Extension: No URN found for geometry");
            }
        }

        return urn;  // TODO(jwo): When !children, can we return a null instead of an undefined variable?
    }

    /**
     * Initializes the important data.
     * @param viewerUrl - viewer url
     * @param geometries
     * @param currentGeometry - geometry loaded in the viewer
     */
    proto.initialize = function(viewer, noBubbleData, viewer_Url, geometries, currentGeometry, qsApiService, sharedPropertyDb) {
        this.viewer = viewer;
        qsApi = qsApiService;
        if(noBubbleData){
            if (this.worker !== undefined) {
                this.worker.terminate();
                this.worker = undefined;
                this.viewerpropertiesworker = undefined;
            }
        } else {
            geometriesCache = {};
            var acmSessionId = this.viewer.model.myData.acmSessionId;
            var basePath = this.viewer.model.myData.basePath;
            geometriesFlat = geometries;
            current = currentGeometry;
            geometriesLoaded = 0;
            sharedPropertyDbPath = sharedPropertyDb;
            isSharedPropertyDb = !!sharedPropertyDbPath;
            totalGeometries = Object.keys(geometries).length;
            viewerPrivateNameSpace.logger.debug("InViewerSearch Extension - Geometries amount: " + totalGeometries);
            var domainParam = (!viewerNameSpace.isNodeJS) ? ("domain=" + encodeURIComponent(window.location.origin)) : null;
            loadContext = {
                url: viewerNameSpace.getItemApi(),
                headers: {},
                basePath: viewer.model.myData.basePath,
                auth: true,
                viewing_url: viewerNameSpace.getItemApi(),
                queryParams: domainParam + ((acmSessionId && domainParam) ? ("&") : "") + (acmSessionId ? ("acmsession=" + acmSessionId) : "")
            };

            if (this.viewerpropertiesworker === undefined) {
                this.worker = viewerSearchNameSpace.WorkerUtils.createPropertyWorker();
                this.viewerpropertiesworker = this.worker;
            } else {
                this.worker = this.viewerpropertiesworker;
            }
            this.worker.postMessage({operation: "SET_DEBUG", enable: avp.ENABLE_DEBUG, level: avp.logger.level});
        }
        this.initialized = true;

    };

    function getSortedGeometries(self) {
        if (orderedGeometries && orderedGeometries.length) {
            return orderedGeometries;
        }

        var geometries = [];
        Object.keys(geometriesFlat).forEach(function(geom) {
            geometries.push(geometriesFlat[geom].data);
        });

        orderedGeometries = geometries.sort(geometriesSortingAlg);

        return orderedGeometries;
    }

    /**
     * Gets the PropertyDatabase for each geometry except he one that is loaded in the viewer
     * @param cb - callback
     */
    proto.initPropertyDatabases = function(cb) {
        var geoPropertyPacks = [];
        var self = this;
        var count = 0;
        var length;
        var bigAmount = false;

        var listener = function(e) {
            var context = e.data;

            switch(context.operation) {
                case "PROP_DB_CREATED":
                    if (context.guid !== current) {
                        geometriesLoaded++;
                        geometriesCache[context.guid].objCount = context.objCount;

                        if (geometriesLoaded === (count + 1)) {
                            self.worker.removeEventListener('message', listener);
                        }

                        cb(geometriesCache, geometriesLoaded === (count + 1), bigAmount); return;
                    }
                    break;

                default:
                    // TODO(jwo): add an error for the default case if it's never expected, or a note of /* why other cases are ignored */
            }
        };

        if (sharedPropertyDbPath) {
            //we dont need to get the propDB since is the same that is loaded in the viewer.
            Object.keys(geometriesFlat).forEach(function(key) {
                var geometry;

                if (geometriesLoaded < maxGeometriesToLoad) {
                    geometry = geometriesFlat[key];

                    if (!geometriesCache.hasOwnProperty(key)) {
                        geometriesCache[key] = {
                            geometry: geometry.data,
                            hasSharedProperties: true,
                            objCount: 0,
                        };
                    }

                    geometriesLoaded++;
                }
            });

            cb(geometriesCache, totalGeometries > 1, bigAmount); return;
        } else {
            Object.keys(geometriesFlat).forEach(function(key) {
                var urn;
                var geometry = geometriesFlat[key];
                if (key !== current) {
                    if (count < maxGeometriesToLoad) {
                        if (!geometriesCache.hasOwnProperty(key)) {
                            geometriesCache[key] = {
                                geometry: geometry.data
                            };

                            urn = getUrnFromChildren(geometry.children);

                            geoPropertyPacks.push({urn: urn, geo: geometry.data});
                            count++;
                        }
                    }
                }
            });
            length = geoPropertyPacks.length;
            if (length) {
                bigAmount = length > bigAmountGeometries;
                self.worker.addEventListener('message', listener);
                self.worker.postMessage({operation: "CREATE_PROP_DB", geoPropertyPacks: geoPropertyPacks, context: loadContext});
            } else {
                cb(geometriesCache, true, false); return;
            }
        }
    };

    /**
     * get the shared property database
     * @param cb - callback
     */
    proto.initSharedPropertyDatabase = function(cb) {
        var self = this;
        var key = SHARED_PROPERTY_KEY;
        var listener = function(e) {
            var context = e.data;

            switch (context.operation) {
                case "PROP_DB_CREATED":
                    if (context.guid === key) {
                        geometriesCache[key].objCount = context.objCount;
                        geometriesCache[key].loading = false;
                        self.worker.removeEventListener('message', listener);
                        if (geometriesCache[key].sharedDbInit) {
                            geometriesCache[key].sharedDbInit();
                        }
                        cb(); return;
                    }
                    break;

                default:
                    // TODO(jwo): add an error for the default case if it's never expected, or a note of /* why other cases are ignored */
            }
        };

        if (geometriesCache.hasOwnProperty(key)) {
            if (geometriesCache[key].loading) {
                geometriesCache[key].sharedDbInit = cb;
            } else {
                cb(); return;
            }

        } else {
            geometriesCache[key] = {
                isShared: true,
                loading: true,
            };

            geometriesCache[current] = {
                isShared: true,
                geometry: geometriesFlat[current].data
            };
            self.worker.addEventListener('message', listener);
            self.worker.postMessage({operation: "CREATE_PROP_DB", geoPropertyPacks: [{urn: sharedPropertyDbPath, geo: {guid: key}}], context: loadContext});
        }
    };

    /**
     * get the PropertyDatabase for the geometry loaded in the viewer
     * @param guid
     * @param cb - callback
     */
    proto.initCurrentPropertyDatabase = function(guid, cb) {
        var geometry;
        var urn;
        var self = this;

        if (sharedPropertyDbPath) {
            this.initSharedPropertyDatabase(function() {
                var geometryInner = geometriesFlat[guid];

                if (!geometriesCache.hasOwnProperty(guid)) {
                    geometriesCache[guid] = {
                        geometry: geometryInner.data,
                        hasSharedProperties: true,
                        objCount: 0,
                    };
                }

                cb(); return;
            });
        } else {
            var listener = function(e) {
                var context = e.data;

                switch(context.operation) {
                    case "PROP_DB_CREATED":
                        geometriesCache[context.guid].objCount = context.objCount;

                        if (context.guid === current) {
                            geometriesLoaded++;
                            self.worker.removeEventListener('message', listener);
                            cb(); return;
                        }
                        break;
                    default:
                        // TODO(jwo): add an error for the default case if it's never expected, or a note of /* why other cases are ignored */
                }
            };

            if (geometriesCache.hasOwnProperty(guid)) {
                cb(); return;
            } else {
                geometry = geometriesFlat[current] || {};
                geometriesCache[current] = {
                    geometry: geometry.data,
                };

                urn = getUrnFromChildren(geometry.children);
                self.worker.addEventListener('message', listener);
                self.worker.postMessage({operation: "CREATE_PROP_DB", geoPropertyPacks: [{urn: urn, geo: geometry.data}], context: loadContext});
            }
        }
    };


    /**
     * gets the properties for the current geometry. This calls to viewer getObjectProperties method.
     * @param guid
     */
    proto.getCurrentGeometryAttributes = function(cb) {
        var self = this;
        this.initCurrentPropertyDatabase(current, function() {
            self.getGeometryAttributes(current, function(){
                cb();
                return;
            });
        });
    };

    /**
     * gets the properties for the given geometry. This calls to PropertyDatabase getObjectProperties method.
     * The attributes are returned as a Map where the key is the value of the property and the values are
     * collections of nodes that contains that property value.
     * @param guid
     */
    proto.getGeometryAttributes = function(guid, cb) {
        var self = this;

        var listener = function(e) {
            var node, context = e.data;

            switch(context.operation) {
                case "GEOMETRY_ATTR_OK":
                    self.worker.removeEventListener('message', listener);
                    cb();
                    break;
                case "GEOMETRY_ATTR_ERR":
                    self.worker.removeEventListener('message', listener);
                    viewerPrivateNameSpace.logger.info("InViewerSearch Extension: No attributes found for: " + guid);
                    cb();
                    break;
                default:
                    // TODO(go) 20160520 - investigate this, should we call the callback? should we remove the listener?
                    viewerPrivateNameSpace.logger.warn("InViewerSearch Extension: Invalid operation found: " +
                        " Operation: " + (context.operation || "") +
                        " Error: " + (context.error || "") +
                        " Place: " + (context.place || "") +
                        " Method: " + (context.method || "")
                    );
                    break;
            }
        };

        this.worker.addEventListener('message', listener);
        this.worker.postMessage({operation: "GEOMETRY_ATTR", guid: guid, sharedPropDbKey: SHARED_PROPERTY_KEY, isSharedPropertyDb: isSharedPropertyDb});
    };

    /**
     * for each geometry but current, it gets the geometries attributes
     * @returns {Array}
     */
    proto.getGeometriesAttributes = function(cb) {
        var self = this;
        var localModelAttr = null;
        var currentGeometry = this.getGeometry(current);

        var listener = function(e) {
            var context = e.data;

            switch(context.operation) {
                case "GEOMETRIES_ATTR_OK":
                    cb();
                    self.worker.removeEventListener('message', listener);
                    break;
                case "GEOMETRIES_ATTR_ERR":
                    viewerPrivateNameSpace.logger.info("InViewerSearch Extension: No attributes found for: " + context.geometry.guid);
                    if (context.ended) {
                        cb();
                        self.worker.removeEventListener('message', listener);
                    }

                    break;
                default:
                  // TODO(go) 20160520 - investigate this, should we call the callback? should we remove the listener?
                  viewerPrivateNameSpace.logger.warn("InViewerSearch Extension: Invalid operation found: " +
                    " Operation: " + (context.operation || "") +
                    " Error: " + (context.error || "") +
                    " Place: " + (context.place || "") +
                    " Method: " + (context.method || "")
                  );
                  break;
            }
        };
        if (isSharedPropertyDb) {
            cb({}, isSharedPropertyDb, true); return;
        } else {
            this.worker.addEventListener('message', listener);
            this.worker.postMessage({operation: "GEOMETRIES_ATTR", sharedPropDbKey: SHARED_PROPERTY_KEY, isSharedPropertyDb: isSharedPropertyDb});
        }

    };


    /**
     * returns the geometry data
     *
     * @param  {GUID} guid - geometry Id
     * @return {object}      - geometry object
     */
    proto.getGeometry = function(guid) {
        var geometry;

        if (geometriesFlat.hasOwnProperty(guid)) {
            geometry = geometriesFlat[guid];
        } else {
            geometry = null;
        }

        return geometry;
    };

    function geometriesSortingAlg(g1, g2) {
        var nameA = g1.name.toUpperCase(); // ignore upper and lowercase
        var nameB = g2.name.toUpperCase(); // ignore upper and lowercase
        if (nameA < nameB) {
            return -1;
        }
        if (nameA > nameB) {
            return 1;
        }

        // names must be equal
        return 0;
    }
    /**
     * returns the geometry data
     *
     * @param  {GUID} guid - geometry Id
     * @return {object}      - geometry object
     */
    proto.orderGeometriesByName = function(geomResults) {
        var results = [];
        var index;
        var orderedGem = getSortedGeometries(this);

        orderedGem.forEach(function(g){
            if (geomResults.totalResultsIndex.hasOwnProperty(g.guid)) {
                index = geomResults.totalResultsIndex[g.guid];
                results.push(geomResults.totalResults[index]);
            }
        });
        return results;
    };

    /**
     * returns the amount of geometries of the loaded document
     *
     * @return {type}  description
     */
    proto.getTotalCountGeometries = function() {

        if (totalGeometries > maxGeometriesToLoad) {
            return maxGeometriesToLoad;
        }

        return totalGeometries;
    };

    proto.areMoreGeometriesToLoad = function() {

        return geometriesFlat.length > maxGeometriesToLoad;
    };

    proto.geometriesLoaded = function() {

        return geometriesLoaded;
    };

    proto.updateCurrent = function(guid) {

        current = guid;
    };

    /**
     * returns true if the node count exceeds maxSize
     * @returns {boolean}
     */
    function currentGeomObjectCount(viewer) {
        var objCount = 0;
        var myData = viewer.model.myData;

        if (myData.instanceTree && myData.instanceTree.objectCount) {
            objCount = myData.instanceTree.objectCount;
        } else if (myData.instanceTree && myData.instanceTree.children) {
            objCount = myData.instanceTree.children.length;
        } else {
            objCount = 0;
        }

        return objCount;
    }

    proto.tooManyNodes = function(currentGeo) {
        var objCount = 0;
        var objCurrent = currentGeomObjectCount(this.viewer);
        if (isSharedPropertyDb) {
            objCount = objCurrent;
        } else {

            //if there are more than 100 geometries we force brute search
            if (!currentGeo && this.getTotalCountGeometries() > 100) {
                return true;
            }

            if (currentGeo) {
                objCount = objCurrent;
            } else {
                Object.keys(geometriesCache).forEach(function(guid) {
                    if (guid !== current && geometriesCache[guid].objCount) {
                        objCount = objCount + geometriesCache[guid].objCount;
                    }
                });
            }
        }
        viewerPrivateNameSpace.logger.log("Object count? " + objCount);
        return (maxNodeGeometryCount < objCount);
    };

    proto.bruteSearchCurrent = function(str, onSuccessCb, onErrorCb) {
        var onsuccess = function(results) {
            runningBruteSearch = false;
            onSuccessCb(results);
            if (successBruteSearchListener) {
                successBruteSearchListener(results);
                successBruteSearchListener = null;
            }
        };

        var onerror = function() {
            onErrorCb();
            if (errorBruteSearchListener) {
                errorBruteSearchListener();
            }
        };

        if (current && !geometriesCache.hasOwnProperty(current)) {
            geometriesLoaded++;
            var geometry = geometriesFlat[current] || {};
            geometriesCache[current] = {
                geometry: geometry.data,
            };
        }

        if (!runningBruteSearch) {
            runningBruteSearch = true;
            this.viewer.search(str, onsuccess, onerror, [], true);
        } else {
            successBruteSearchListener = onSuccessCb;
            errorBruteSearchListener = onErrorCb;
        }

    }
    /**
     * searches in all geometries but current one.
     * @param str
     * @returns {Array}
     */
    proto.bruteSearch = function(str, cb) {
        var self = this;
        var orderedGeometriesList = getSortedGeometries(this);

        var listener = function(e) {
            var context = e.data;

            switch(context.operation) {
                case "BRUTE_SEARCH_OK":
                  if (context.ended) {
                      self.worker.removeEventListener('message', listener);
                  }

                  cb(context.str, context.result, context.ended, context.geometry); return;
                  break;

              default:
                  // TODO(jwo): add an error for the default case if it's never expected, or a note of /* why other cases are ignored */
            }
        };
        var onCurrentBruteSearch = function(results) {
            var resultForCurr = {geometry: current, results: results};
            self.worker.postMessage({operation: "PROCESS_BRUTE_SEARCH", str: str, results: resultForCurr, sharedPropDbKey: SHARED_PROPERTY_KEY, isSharedPropertyDb: isSharedPropertyDb, geometries: orderedGeometriesList});
        };
        var onErrorCurrentBruteSearch = function() {
            self.worker.postMessage({operation: "PROCESS_BRUTE_SEARCH", str: str, results: {geometry: current, results: []}, sharedPropDbKey: SHARED_PROPERTY_KEY, isSharedPropertyDb: isSharedPropertyDb, geometries: orderedGeometriesList});
        };

        this.worker.addEventListener('message', listener);
        this.bruteSearchCurrent(str, onCurrentBruteSearch, onErrorCurrentBruteSearch);
        if (!isSharedPropertyDb) {
            this.worker.postMessage({operation: "BRUTE_SEARCH", str: str, currentGeo: current, geometries: orderedGeometriesList});
        }

    };

    function escapeRegExpChars(str) {
        return String(str).replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }

    /**
     * highlights the highlightStr in the text passed as a parameter
     * @param text
     * @param highlightStr
     * @returns {*}
     */
    proto.highlightText = function(text, highlightStr) {
        var textWithHighlightChars, highlighted, highlightStrRegex;

        if (Object.prototype.toString.call(text) !== '[object String]') {
            viewerPrivateNameSpace.logger.error('Error: Non-string sent to highlightText(). Check type, and if correct, convert to String() first.');
        }

        highlightStrRegex = new RegExp('(' + escapeRegExpChars(highlightStr) + ')', 'gi');
        textWithHighlightChars = highlightStr && String(text).replace(highlightStrRegex, '\uE000' + '$1' + '\uE001') || String(text);
        highlighted = qsApi.qsAPI.sanitizeAndHighlightString(textWithHighlightChars, '<span class="bolder">', '</span>');

        return highlighted;
    };

    proto.replaceHtmlCh = function(str) {
        return qsApi.qsAPI.sanitizeAndHighlightString(str);
    };

    /**
     * searches using fullproof and string search algorithms
     * @param str
     * @param cb - callback to process the results
     */
    proto.doSearch = function(str, cb) {
        var _this = this;
        var geometries;

        var listener = function(e) {
            var context = e.data;

            switch(context.operation) {
                case 'SEARCH_RESULT':
                    if (context.ended) {
                        _this.worker.removeEventListener('message', listener);
                        _this.isSearching = false;
                        viewerPrivateNameSpace.logger.debug('The last SEARCH_RESULT messgage received for query \'' + context.str + '\' Ready for another search');
                        _this.searchingString = null;
                    }
                    if (_this.searchingStringCb) {
                        _this.searchingStringCb(context.str, context.results, context.ended);
                        if (context.ended) {
                            _this.searchingStringCb = null;
                        }
                    }
                    cb(context.str, context.results, context.ended); return;
                    break;

                case 'OLD_SEARCH_RESULT':
                    _this.worker.removeEventListener('message', listener);
                    _this.isSearching = false;
                    break;

                default:
                    viewerPrivateNameSpace.logger.warn('Received unexpected event for ' + context.str);
            }
        };

        clearTimeout(_this.isSearchingTimer);

        if (_this.isSearching === true) {
            if (str === _this.searchingString) {
                _this.searchingStringCb = cb;
            } else {
                _this.isSearchingTimer = setTimeout(function() { _this.doSearch(str, cb); }, 100);
            }
        } else {
            if (isSharedPropertyDb) {
                geometries = {};
                Object.keys(geometriesCache).forEach(function(key){
                    if(key !== SHARED_PROPERTY_KEY){
                        geometries[key] = {
                            guid: geometriesCache[key].geometry.guid,
                            name: geometriesCache[key].geometry.name
                        };
                    }
                });
            }
            viewerPrivateNameSpace.logger.debug('Submitting a new search request for query \'' + str + '\'');
            _this.isSearching = true;
            _this.searchingString = str;
            _this.worker.addEventListener('message', listener);
            _this.worker.postMessage({operation: 'SEARCH', str: str, isSharedPropertyDb: isSharedPropertyDb, geometries: geometries});
        }
    };

    proto.defaultNodeName = function() {
        return 'Untitled Node';
    };

})();

/**
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 *
 * @fileoverview Description of this file.
 *
 * A polyfill for HTML Canvas features, including
 * Path2D support.
 */
if (CanvasRenderingContext2D.prototype.ellipse == undefined) {
  CanvasRenderingContext2D.prototype.ellipse = function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
    this.save();
    this.translate(x, y);
    this.rotate(rotation);
    this.scale(radiusX, radiusY);
    this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
    this.restore();
  }
}

if (typeof Path2D !== 'function') {
  (function() {

    // Include the SVG path parser.
    parser = (function() {
      /*
       * Generated by PEG.js 0.8.0.
       *
       * http://pegjs.majda.cz/
       */
    
      function peg$subclass(child, parent) {
        function ctor() { this.constructor = child; }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
    
      function SyntaxError(message, expected, found, offset, line, column) {
        this.message  = message;
        this.expected = expected;
        this.found    = found;
        this.offset   = offset;
        this.line     = line;
        this.column   = column;
    
        this.name     = "SyntaxError";
      }
    
      peg$subclass(SyntaxError, Error);
    
      function parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
    
            peg$FAILED = {},
    
            peg$startRuleFunctions = { svg_path: peg$parsesvg_path },
            peg$startRuleFunction  = peg$parsesvg_path,
    
            peg$c0 = peg$FAILED,
            peg$c1 = [],
            peg$c2 = null,
            peg$c3 = function(d) { return ops; },
            peg$c4 = /^[Mm]/,
            peg$c5 = { type: "class", value: "[Mm]", description: "[Mm]" },
            peg$c6 = function(ch, args) {
                  var moveCh = ch
                  // If this is the first move cmd then force it to be absolute.
                  if (firstSubPath) {
                    moveCh = 'M';
                    firstSubPath = false;
                  }
                  ops.push({type: 'moveTo', args: makeAbsolute(moveCh, args[0])});
                  for (var i=1; i < args.length; i++) {
                    // The lineTo args are either abs or relative, depending on the
                    // original moveto command.
                    ops.push({type: 'lineTo', args: makeAbsolute(ch, args[i])});
                  }
                },
            peg$c7 = function(one, rest) { return concatSequence(one, rest); },
            peg$c8 = /^[Zz]/,
            peg$c9 = { type: "class", value: "[Zz]", description: "[Zz]" },
            peg$c10 = function() { ops.push({type: 'closePath', args: []}); },
            peg$c11 = /^[Ll]/,
            peg$c12 = { type: "class", value: "[Ll]", description: "[Ll]" },
            peg$c13 = function(ch, args) {
                  for (var i=0; i < args.length; i++) {
                    ops.push({type: 'lineTo', args: makeAbsolute(ch, args[i])});
                  }
                },
            peg$c14 = /^[Hh]/,
            peg$c15 = { type: "class", value: "[Hh]", description: "[Hh]" },
            peg$c16 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  ops.push({type: 'lineTo', args: makeAbsoluteFromX(ch, args[i])});
                }
              },
            peg$c17 = /^[Vv]/,
            peg$c18 = { type: "class", value: "[Vv]", description: "[Vv]" },
            peg$c19 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  ops.push({type: 'lineTo', args: makeAbsoluteFromY(ch, args[i])});
                }
              },
            peg$c20 = /^[Cc]/,
            peg$c21 = { type: "class", value: "[Cc]", description: "[Cc]" },
            peg$c22 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  ops.push({type: 'bezierCurveTo', args: makeAbsoluteMultiple(ch, args[i])});
                }
              },
            peg$c23 = function(cp1, cp2, last) { return cp1.concat(cp2, last); },
            peg$c24 = /^[Ss]/,
            peg$c25 = { type: "class", value: "[Ss]", description: "[Ss]" },
            peg$c26 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  ops.push({type: 'bezierCurveTo', args: makeReflected().concat(makeAbsoluteMultiple(ch, args[i]))});
                }
              },
            peg$c27 = function(cp1, last) { return cp1.concat(last); },
            peg$c28 = /^[Qq]/,
            peg$c29 = { type: "class", value: "[Qq]", description: "[Qq]" },
            peg$c30 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  ops.push({type: 'quadraticCurveTo', args: makeAbsoluteMultiple(ch, args[i])});
                }
              },
            peg$c31 = /^[Tt]/,
            peg$c32 = { type: "class", value: "[Tt]", description: "[Tt]" },
            peg$c33 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  var reflected = makeReflected();
                  ops.push({type: 'quadraticCurveTo', args: reflected.concat(makeAbsoluteMultiple(ch, args[i]))});
                  lastControl = reflected.slice(0);
                }
              },
            peg$c34 = /^[Aa]/,
            peg$c35 = { type: "class", value: "[Aa]", description: "[Aa]" },
            peg$c36 = function(ch, args) {
                for (var i=0; i < args.length; i++) {
                  var x1 = [lastCoord.slice()];
                  var x2 = [makeAbsolute(ch, args[i].slice(-2))];
                  absArgs = x1.concat(args[i].slice(0, -2), x2);
                  ellipseFromEllipticalArc.apply(this, absArgs);
                }
              },
            peg$c37 = function(rx, ry, xrot, large, sweep, last) { return [parseFloat(rx), parseFloat(ry), parseFloat(xrot.join('')), parseInt(large), parseInt(sweep), last[0], last[1]]; },
            peg$c38 = function(x, y) { return [x, y] },
            peg$c39 = function(number) { return parseFloat(number.join('')) },
            peg$c40 = "0",
            peg$c41 = { type: "literal", value: "0", description: "\"0\"" },
            peg$c42 = "1",
            peg$c43 = { type: "literal", value: "1", description: "\"1\"" },
            peg$c44 = ",",
            peg$c45 = { type: "literal", value: ",", description: "\",\"" },
            peg$c46 = ".",
            peg$c47 = { type: "literal", value: ".", description: "\".\"" },
            peg$c48 = /^[eE]/,
            peg$c49 = { type: "class", value: "[eE]", description: "[eE]" },
            peg$c50 = "+",
            peg$c51 = { type: "literal", value: "+", description: "\"+\"" },
            peg$c52 = "-",
            peg$c53 = { type: "literal", value: "-", description: "\"-\"" },
            peg$c54 = /^[0-9]/,
            peg$c55 = { type: "class", value: "[0-9]", description: "[0-9]" },
            peg$c56 = function(digits) { return digits.join('') },
            peg$c57 = /^[ \t\n\r]/,
            peg$c58 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },
    
            peg$currPos          = 0,
            peg$reportedPos      = 0,
            peg$cachedPos        = 0,
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
            peg$maxFailPos       = 0,
            peg$maxFailExpected  = [],
            peg$silentFails      = 0,
    
            peg$result;
    
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
    
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
    
        function text() {
          return input.substring(peg$reportedPos, peg$currPos);
        }
    
        function offset() {
          return peg$reportedPos;
        }
    
        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
    
        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
    
        function expected(description) {
          throw peg$buildException(
            null,
            [{ type: "other", description: description }],
            peg$reportedPos
          );
        }
    
        function error(message) {
          throw peg$buildException(message, null, peg$reportedPos);
        }
    
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p, ch;
    
            for (p = startPos; p < endPos; p++) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) { details.line++; }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
    
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
    
          return peg$cachedPosDetails;
        }
    
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) { return; }
    
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
    
          peg$maxFailExpected.push(expected);
        }
    
        function peg$buildException(message, expected, pos) {
          function cleanupExpected(expected) {
            var i = 1;
    
            expected.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
    
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }
    
          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
    
              return s
                .replace(/\\/g,   '\\\\')
                .replace(/"/g,    '\\"')
                .replace(/\x08/g, '\\b')
                .replace(/\t/g,   '\\t')
                .replace(/\n/g,   '\\n')
                .replace(/\f/g,   '\\f')
                .replace(/\r/g,   '\\r')
                .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
                .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
                .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
                .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
            }
    
            var expectedDescs = new Array(expected.length),
                expectedDesc, foundDesc, i;
    
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
    
            expectedDesc = expected.length > 1
              ? expectedDescs.slice(0, -1).join(", ")
                  + " or "
                  + expectedDescs[expected.length - 1]
              : expectedDescs[0];
    
            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
    
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
    
          var posDetails = peg$computePosDetails(pos),
              found      = pos < input.length ? input.charAt(pos) : null;
    
          if (expected !== null) {
            cleanupExpected(expected);
          }
    
          return new SyntaxError(
            message !== null ? message : buildMessage(expected, found),
            expected,
            found,
            pos,
            posDetails.line,
            posDetails.column
          );
        }
    
        function peg$parsesvg_path() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewsp();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewsp();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsemoveTo_drawTo_commandGroups();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsewsp();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsewsp();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c3(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsemoveTo_drawTo_commandGroups() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsemoveTo_drawTo_commandGroup();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsemoveTo_drawTo_commandGroups();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsemoveTo_drawTo_commandGroup() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsemoveto();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsedrawto_commands();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsedrawto_commands() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsedrawto_command();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsedrawto_commands();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsedrawto_command() {
          var s0;
    
          s0 = peg$parseclosepath();
          if (s0 === peg$FAILED) {
            s0 = peg$parselineto();
            if (s0 === peg$FAILED) {
              s0 = peg$parsehorizontal_lineto();
              if (s0 === peg$FAILED) {
                s0 = peg$parsevertical_lineto();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsecurveto();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsesmooth_curveto();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsequadratic_bezier_curveto();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsesmooth_quadratic_bezier_curveto();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseelliptical_arc();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
    
          return s0;
        }
    
        function peg$parsemoveto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c4.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsemoveto_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c6(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsemoveto_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate_pair();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parselineto_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parseclosepath() {
          var s0, s1;
    
          s0 = peg$currPos;
          if (peg$c8.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c9); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c10();
          }
          s0 = s1;
    
          return s0;
        }
    
        function peg$parselineto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c11.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c12); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parselineto_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parselineto_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate_pair();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parselineto_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsehorizontal_lineto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c14.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecoordinate_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c16(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsecoordinate_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecoordinate_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsevertical_lineto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c17.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecoordinate_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c19(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsecurveto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c20.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecurveto_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c22(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsecurveto_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsecurveto_argument();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecurveto_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsecurveto_argument() {
          var s0, s1, s2, s3, s4, s5;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate_pair();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma_wsp();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecoordinate_pair();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsecomma_wsp();
                if (s4 === peg$FAILED) {
                  s4 = peg$c2;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsecoordinate_pair();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c23(s1, s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsesmooth_curveto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c24.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsesmooth_curveto_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsesmooth_curveto_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsesmooth_curveto_argument();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsesmooth_curveto_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsesmooth_curveto_argument() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate_pair();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma_wsp();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecoordinate_pair();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c27(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsequadratic_bezier_curveto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c28.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c29); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsequadratic_bezier_curveto_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c30(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsequadratic_bezier_curveto_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsequadratic_bezier_curveto_argument();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsequadratic_bezier_curveto_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsequadratic_bezier_curveto_argument() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate_pair();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma_wsp();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecoordinate_pair();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c27(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsesmooth_quadratic_bezier_curveto() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c31.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c32); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate_pair();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parseelliptical_arc() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c34.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c35); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewsp();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseelliptical_arc_argument_sequence();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c36(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parseelliptical_arc_argument_sequence() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = peg$parseelliptical_arc_argument();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsecomma_wsp();
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseelliptical_arc_argument_sequence();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parseelliptical_arc_argument() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
    
          s0 = peg$currPos;
          s1 = peg$parsenonnegative_number();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma_wsp();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsenonnegative_number();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsecomma_wsp();
                if (s4 === peg$FAILED) {
                  s4 = peg$c2;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsenumber();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsecomma_wsp();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseflag();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsecomma_wsp();
                        if (s8 === peg$FAILED) {
                          s8 = peg$c2;
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseflag();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsecomma_wsp();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c2;
                            }
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parsecoordinate_pair();
                              if (s11 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c37(s1, s3, s5, s7, s9, s11);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsecoordinate_pair() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          s1 = peg$parsecoordinate();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma_wsp();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecoordinate();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c38(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsecoordinate() {
          var s0, s1;
    
          s0 = peg$currPos;
          s1 = peg$parsenumber();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c39(s1);
          }
          s0 = s1;
    
          return s0;
        }
    
        function peg$parsenonnegative_number() {
          var s0;
    
          s0 = peg$parsefloating_point_constant();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedigit_sequence();
          }
    
          return s0;
        }
    
        function peg$parsenumber() {
          var s0, s1, s2;
    
          s0 = peg$currPos;
          s1 = peg$parsesign();
          if (s1 === peg$FAILED) {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsefloating_point_constant();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesign();
            if (s1 === peg$FAILED) {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsedigit_sequence();
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
    
          return s0;
        }
    
        function peg$parseflag() {
          var s0;
    
          if (input.charCodeAt(peg$currPos) === 48) {
            s0 = peg$c40;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c41); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 49) {
              s0 = peg$c42;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
          }
    
          return s0;
        }
    
        function peg$parsecomma_wsp() {
          var s0, s1, s2, s3, s4;
    
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewsp();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewsp();
            }
          } else {
            s1 = peg$c0;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsewsp();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsewsp();
              }
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecomma();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsewsp();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsewsp();
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
    
          return s0;
        }
    
        function peg$parsecomma() {
          var s0;
    
          if (input.charCodeAt(peg$currPos) === 44) {
            s0 = peg$c44;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c45); }
          }
    
          return s0;
        }
    
        function peg$parsefloating_point_constant() {
          var s0, s1, s2;
    
          s0 = peg$currPos;
          s1 = peg$parsefractional_constant();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexponent();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedigit_sequence();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseexponent();
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
    
          return s0;
        }
    
        function peg$parsefractional_constant() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          s1 = peg$parsedigit_sequence();
          if (s1 === peg$FAILED) {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c46;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c47); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsedigit_sequence();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedigit_sequence();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c46;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c47); }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
    
          return s0;
        }
    
        function peg$parseexponent() {
          var s0, s1, s2, s3;
    
          s0 = peg$currPos;
          if (peg$c48.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsesign();
            if (s2 === peg$FAILED) {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsedigit_sequence();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
    
          return s0;
        }
    
        function peg$parsesign() {
          var s0;
    
          if (input.charCodeAt(peg$currPos) === 43) {
            s0 = peg$c50;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s0 = peg$c52;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
          }
    
          return s0;
        }
    
        function peg$parsedigit_sequence() {
          var s0, s1, s2;
    
          s0 = peg$currPos;
          s1 = [];
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (peg$c54.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
            }
          } else {
            s1 = peg$c0;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c56(s1);
          }
          s0 = s1;
    
          return s0;
        }
    
        function peg$parsewsp() {
          var s0;
    
          if (peg$c57.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c58); }
          }
    
          return s0;
        }
    
    
          // The last coordinate we are at in the path. In absolute coords.
          var lastCoord = [0, 0];
          // The last control point we encountered in the path. In absolute coords.
          var lastControl = [0, 0];
          // The list of operations we've parsed so far.
          var ops = [];
          // Have we parsed the first sub-path yet?
          var firstSubPath = true;
          // The letter of the last parsed command.
          var lastCh = '';
    
          // Convert a position into an absolute position.
          function makeAbsolute(c, coord) {
            if ('mlazhvcsqt'.indexOf(c) === -1) {
              lastCoord = coord;
            } else {
              lastCoord[0] += coord[0];
              lastCoord[1] += coord[1];
            }
            lastCh = c;
            return lastCoord.slice(0);
          }
    
          // Convert a sequence of coordinates into absolute coordinates.
          //
          // For arguments that take multiple coord pairs, such as bezier.
          function makeAbsoluteMultiple(c, seq) {
            var r = [];
            var lastPosCopy = lastCoord.slice(0);
            for (var i=0; i < seq.length; i+=2) {
              // Only the last point should update lastCoord.
              lastCoord = lastPosCopy.slice(0);
              var coord = makeAbsolute(c, seq.slice(i, i+2));
              r = r.concat(coord);
              // Record the last control point, it might be needed for
              // shorthand operations.
              if (i == seq.length-4) {
                lastControl = coord.slice(0);
              }
            }
            return r;
          }
    
          // Find the reflection of the last control point over
          // the last postion in the path.
          function makeReflected() {
            if ('CcSsQqTt'.indexOf(lastCh) == -1) {
              lastControl = lastCoord.slice(0);
            }
            // reflected = 2*lastCoord - lastControl
            // Note the result is absolute, not relative.
            var r = [0, 0];
            r[0] = 2*lastCoord[0] - lastControl[0];
            r[1] = 2*lastCoord[1] - lastControl[1];
            return r;
          }
    
          function makeAbsoluteFromX(c, x) {
            var coord = [x, 0];
            if (c == 'H') {
              coord[1] = lastCoord[1];
            }
            return makeAbsolute(c, coord);
          }
    
          function makeAbsoluteFromY(c, y) {
            var coord = [0, y];
            if (c == 'V') {
              coord[0] = lastCoord[0];
            }
            return makeAbsolute(c, coord);
          }
    
          function concatSequence(one, rest) {
            var r = [one];
            if (rest && rest.length > 1) {
              var rem = rest[1];
              for (var i = 0; i < rem.length; i++) {
                r.push(rem[i]);
              }
            }
            return r;
          }
    
          function mag(v) {
            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
          }
    
          function dot(u, v) {
            return (u[0]*v[0] + u[1]*v[1]);
          }
    
          function ratio(u, v) {
            return dot(u,v) / (mag(u)*mag(v))
          }
    
          function angle(u, v) {
            var sign = 1.0;
            if ((u[0]*v[1] - u[1]*v[0]) < 0) {
              sign = -1.0;
            }
            return sign * Math.acos(ratio(u,v));
          }
    
          function rotClockwise(v, angle) {
            var cost = Math.cos(angle);
            var sint = Math.sin(angle);
            return [cost*v[0] + sint*v[1], -1 * sint*v[0] + cost*v[1]];
          }
    
          function rotCounterClockwise(v, angle) {
            var cost = Math.cos(angle);
            var sint = Math.sin(angle);
            return [cost*v[0] - sint*v[1], sint*v[0] + cost*v[1]];
          }
    
          function midPoint(u, v) {
            return [(u[0] - v[0])/2.0, (u[1] - v[1])/2.0];
          }
    
          function meanVec(u, v) {
            return [(u[0] + v[0])/2.0, (u[1] + v[1])/2.0];
          }
    
          function pointMul(u, v) {
            return [u[0]*v[0], u[1]*v[1]];
          }
    
          function scale(c, v) {
            return [c*v[0], c*v[1]];
          }
    
          function sum(u, v) {
            return [u[0] + v[0], u[1] + v[1]];
          }
    
          // Convert an SVG elliptical arc to a series of canvas commands.
          //
          // x1, x2: start and stop coordinates of the ellipse.
          // rx, ry: radii of the ellipse.
          // phi: rotation of the ellipse.
          // fA: large arc flag.
          // fS: sweep flag.
          function ellipseFromEllipticalArc(x1, rx, ry, phi, fA, fS, x2) {
            // Convert from endpoint to center parametrization, as detailed in:
            //   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
            if (rx == 0 || ry == 0) {
              ops.push({type: 'lineTo', args: x2});
              return;
            }
            var phi = phi * (Math.PI / 180.0);
            rx = Math.abs(rx);
            ry = Math.abs(ry);
            var xPrime = rotClockwise(midPoint(x1, x2), phi);                // F.6.5.1
            var xPrime2 = pointMul(xPrime, xPrime);
            var rx2 = Math.pow(rx, 2);
            var ry2 = Math.pow(ry, 2);
    
            var lambda = Math.sqrt(xPrime2[0]/rx2 + xPrime2[1]/ry2);
            if (lambda > 1) {
              rx *= lambda;
              ry *= lambda;
              rx2 = Math.pow(rx, 2);
              ry2 = Math.pow(ry, 2);
            }
    
            var factor = Math.sqrt((rx2*ry2 - rx2*xPrime2[1] - ry2*xPrime2[0]) /
              (rx2*xPrime2[1] + ry2*xPrime2[0]));
            if (fA == fS) {
              factor *= -1.0;
            }
            var cPrime = scale(factor, [rx*xPrime[1]/ry, -ry*xPrime[0]/rx]); // F.6.5.2
            var c = sum(rotCounterClockwise(cPrime, phi), meanVec(x1, x2));  // F.6.5.3
            var x1UnitVector = [(xPrime[0] - cPrime[0])/rx, (xPrime[1] - cPrime[1])/ry];
            var x2UnitVector = [(-1.0*xPrime[0] - cPrime[0])/rx, (-1.0*xPrime[1] - cPrime[1])/ry];
            var theta = angle([1, 0], x1UnitVector);                         // F.6.5.5
            var deltaTheta = angle(x1UnitVector, x2UnitVector);              // F.6.5.6
            var start = theta;
            var end = theta+deltaTheta;
            ops.push(
              {type: 'save', args: []},
              {type: 'translate', args: [c[0], c[1]]},
              {type: 'rotate', args: [phi]},
              {type: 'scale', args: [rx, ry]},
              {type: 'arc', args: [0, 0, 1, start, end, 1-fS]},
              {type: 'restore', args: []}
              );
          }
    
    
        peg$result = peg$startRuleFunction();
    
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
    
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
    
      return {
        SyntaxError: SyntaxError,
        parse:       parse
      };
    })();

    function Path_(arg) {
      this.ops_ = [];
      if (arg == undefined) {
        return;
      }
      if (typeof arg == 'string') {
        try {
          this.ops_ = parser.parse(arg);
        } catch(e) {
          // Treat an invalid SVG path as an empty path.
        }
      } else if (arg.hasOwnProperty('ops_')) {
        this.ops_ = arg.ops_.slice(0);
      } else {
        throw 'Error: ' + typeof arg + 'is not a valid argument to Path';
      }
    };

    // TODO(jcgregorio) test for arcTo and implement via something.


    // Path methods that map simply to the CanvasRenderingContext2D.
    var simple_mapping = [
      'closePath',
      'moveTo',
      'lineTo',
      'quadraticCurveTo',
      'bezierCurveTo',
      'rect',
      'arc',
      'arcTo',
      'ellipse',
      'isPointInPath',
      'isPointInStroke',
      ];

    function createFunction(name) {
      return function() {
        this.ops_.push({type: name, args: Array.prototype.slice.call(arguments, 0)});
      };
    }

    // Add simple_mapping methods to Path2D.
    for (var i=0; i<simple_mapping.length; i++) {
      var name = simple_mapping[i];
      Path_.prototype[name] = createFunction(name);
    }

    Path_.prototype['addPath'] = function(path, tr) {
      var hasTx = false;
      if (tr
          && tr.hasOwnProperty('a')
          && tr.hasOwnProperty('b')
          && tr.hasOwnProperty('c')
          && tr.hasOwnProperty('d')
          && tr.hasOwnProperty('e')
          && tr.hasOwnProperty('f')) {
        hasTx = true;
        this.ops_.push({type: 'save', args: []});
        this.ops_.push({type: 'transform', args: [tr.a, tr.b, tr.c, tr.d, tr.e, tr.f]});
      }
      this.ops_ = this.ops_.concat(path.ops_);
      if (hasTx) {
        this.ops_.push({type: 'restore', args: []});
      }
    }

    original_fill = CanvasRenderingContext2D.prototype.fill;
    original_stroke = CanvasRenderingContext2D.prototype.stroke;
    original_clip = CanvasRenderingContext2D.prototype.clip;
    original_is_point_in_path = CanvasRenderingContext2D.prototype.isPointInPath;
    original_is_point_in_stroke = CanvasRenderingContext2D.prototype.isPointInStroke;

    // Replace methods on CanvasRenderingContext2D with ones that understand Path2D.
    CanvasRenderingContext2D.prototype.fill = function(arg) {
      if (arg instanceof Path_) {
        this.beginPath();
        for (var i = 0, len = arg.ops_.length; i < len; i++) {
          var op = arg.ops_[i];
          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);
        }
        original_fill.apply(this, Array.prototype.slice.call(arguments, 1));
      } else {
        original_fill.apply(this, arguments);
      }
    }

    CanvasRenderingContext2D.prototype.stroke = function(arg) {
      if (arg instanceof Path_) {
        this.beginPath();
        for (var i = 0, len = arg.ops_.length; i < len; i++) {
          var op = arg.ops_[i];
          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);
        }
        original_stroke.call(this);
      } else {
        original_stroke.call(this);
      }
    }

    CanvasRenderingContext2D.prototype.clip = function(arg) {
      if (arg instanceof Path_) {
        // Note that we don't save and restore the context state, since the
        // clip region is part of the state. Not really a problem since the
        // HTML 5 spec doesn't say that clip(path) doesn't affect the current
        // path.
        this.beginPath();
        for (var i = 0, len = arg.ops_.length; i < len; i++) {
          var op = arg.ops_[i];
          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);
        }
        original_clip.apply(this, Array.prototype.slice.call(arguments, 1));
      } else {
        original_clip.apply(this, arguments);
      }
    }

    CanvasRenderingContext2D.prototype.isPointInPath = function(arg) {
      if (arg instanceof Path_) {
        this.beginPath();
        for (var i = 0, len = arg.ops_.length; i < len; i++) {
          var op = arg.ops_[i];
          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);
        }
        return original_is_point_in_path.apply(this, Array.prototype.slice.call(arguments, 1));
      } else {
        return original_is_point_in_path.apply(this, arguments);
      }
    }
    CanvasRenderingContext2D.prototype.isPointInStroke = function(arg) {
      if (arg instanceof Path_) {
        this.beginPath();
        for (var i = 0, len = arg.ops_.length; i < len; i++) {
          var op = arg.ops_[i];
          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);
        }
        return original_is_point_in_stroke.apply(this, Array.prototype.slice.call(arguments, 1));
      } else {
        return original_is_point_in_stroke.apply(this, arguments);
      }
    }

    // Set up externs.
    Path2D = Path_;
  })();
}
/**
 * @author arodic / https://github.com/arodic
 *
 * @author chiena -- Modified for Autodesk LMV web viewer
 */
 /*jshint sub:true*/

function init_TransformGizmos() {

    'use strict';

    var GizmoMaterial = function ( parameters ) {

        THREE.MeshBasicMaterial.call( this );

        this.depthTest = false;
        this.depthWrite = false;
        this.side = THREE.FrontSide;
        this.transparent = true;

        this.setValues( parameters );

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function( highlighted ) {

            if ( highlighted ) {

                this.color.setRGB( 1, 230/255, 3/255 );
                this.opacity = 1;

            } else {

                this.color.copy( this.oldColor );
                this.opacity = this.oldOpacity;

            }

        };

    };

    GizmoMaterial.prototype = Object.create( THREE.MeshBasicMaterial.prototype );

    var GizmoLineMaterial = function ( parameters ) {

        THREE.LineBasicMaterial.call( this );

        this.depthTest = false;
        this.depthWrite = false;
        this.transparent = true;
        this.linewidth = 1;

        this.setValues( parameters );

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function( highlighted ) {

            if ( highlighted ) {

                this.color.setRGB( 1, 230/255, 3/255 );
                this.opacity = 1;

            } else {

                this.color.copy( this.oldColor );
                this.opacity = this.oldOpacity;

            }

        };

    };

    GizmoLineMaterial.prototype = Object.create( THREE.LineBasicMaterial.prototype );

    // polyfill
    if (THREE.PolyhedronGeometry === undefined) {
        THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

            THREE.Geometry.call( this );

            this.type = 'PolyhedronGeometry';

            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };

            radius = radius || 1;
            detail = detail || 0;

            var that = this;

            for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

                prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            }

            var midpoints = [], p = this.vertices;

            var faces = [];

            for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

                var v1 = p[ indices[ i     ] ];
                var v2 = p[ indices[ i + 1 ] ];
                var v3 = p[ indices[ i + 2 ] ];

                faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

            }

            var centroid = new THREE.Vector3();

            for ( var i = 0, l = faces.length; i < l; i ++ ) {

                subdivide( faces[ i ], detail );

            }


            // Handle case when face straddles the seam

            for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

                var uvs = this.faceVertexUvs[ 0 ][ i ];

                var x0 = uvs[ 0 ].x;
                var x1 = uvs[ 1 ].x;
                var x2 = uvs[ 2 ].x;

                var max = Math.max( x0, Math.max( x1, x2 ) );
                var min = Math.min( x0, Math.min( x1, x2 ) );

                if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

                    if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
                    if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
                    if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

                }

            }


            // Apply radius

            for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

                this.vertices[ i ].multiplyScalar( radius );

            }


            // Merge vertices

            this.mergeVertices();

            this.computeFaceNormals();

            this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


            // Project vector onto sphere's surface

            function prepare( vector ) {

                var vertex = vector.normalize().clone();
                vertex.index = that.vertices.push( vertex ) - 1;

                // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

                var u = azimuth( vector ) / 2 / Math.PI + 0.5;
                var v = inclination( vector ) / Math.PI + 0.5;
                vertex.uv = new THREE.Vector2( u, 1 - v );

                return vertex;

            }


            // Approximate a curved face with recursively sub-divided triangles.

            function make( v1, v2, v3 ) {

                var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
                that.faces.push( face );

                centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

                var azi = azimuth( centroid );

                that.faceVertexUvs[ 0 ].push( [
                    correctUV( v1.uv, v1, azi ),
                    correctUV( v2.uv, v2, azi ),
                    correctUV( v3.uv, v3, azi )
                ] );

            }


            // Analytically subdivide a face to the required detail level.

            function subdivide( face, detail ) {

                var cols = Math.pow(2, detail);
                var cells = Math.pow(4, detail);
                var a = prepare( that.vertices[ face.a ] );
                var b = prepare( that.vertices[ face.b ] );
                var c = prepare( that.vertices[ face.c ] );
                var v = [];

                // Construct all of the vertices for this subdivision.

                for ( var i = 0 ; i <= cols; i ++ ) {

                    v[ i ] = [];

                    var aj = prepare( a.clone().lerp( c, i / cols ) );
                    var bj = prepare( b.clone().lerp( c, i / cols ) );
                    var rows = cols - i;

                    for ( var j = 0; j <= rows; j ++) {

                        if ( j == 0 && i == cols ) {

                            v[ i ][ j ] = aj;

                        } else {

                            v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                        }

                    }

                }

                // Construct all of the faces.

                for ( var i = 0; i < cols ; i ++ ) {

                    for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

                        var k = Math.floor( j / 2 );

                        if ( j % 2 == 0 ) {

                            make(
                                v[ i ][ k + 1],
                                v[ i + 1 ][ k ],
                                v[ i ][ k ]
                            );

                        } else {

                            make(
                                v[ i ][ k + 1 ],
                                v[ i + 1][ k + 1],
                                v[ i + 1 ][ k ]
                            );

                        }

                    }

                }

            }


            // Angle around the Y axis, counter-clockwise when looking from above.

            function azimuth( vector ) {

                return Math.atan2( vector.z, - vector.x );

            }


            // Angle above the XZ plane.

            function inclination( vector ) {

                return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

            }


            // Texture fixing helper. Spheres have some odd behaviours.

            function correctUV( uv, vector, azimuth ) {

                if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
                if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
                return uv.clone();

            }

        };

        THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
    }

    // polyfill
    if (THREE.OctahedronGeometry === undefined) {
        THREE.OctahedronGeometry = function ( radius, detail ) {

            this.parameters = {
                radius: radius,
                detail: detail
            };

            var vertices = [
                1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
            ];

            var indices = [
                0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
            ];

            THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

            this.type = 'OctahedronGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };
        };

        THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
    }

    // polyfill
    if (THREE.TorusGeometry === undefined) {
        THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

            THREE.Geometry.call( this );

            this.type = 'TorusGeometry';

            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };

            radius = radius || 100;
            tube = tube || 40;
            radialSegments = radialSegments || 8;
            tubularSegments = tubularSegments || 6;
            arc = arc || Math.PI * 2;

            var center = new THREE.Vector3(), uvs = [], normals = [];

            for ( var j = 0; j <= radialSegments; j ++ ) {

                for ( var i = 0; i <= tubularSegments; i ++ ) {

                    var u = i / tubularSegments * arc;
                    var v = j / radialSegments * Math.PI * 2;

                    center.x = radius * Math.cos( u );
                    center.y = radius * Math.sin( u );

                    var vertex = new THREE.Vector3();
                    vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
                    vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
                    vertex.z = tube * Math.sin( v );

                    this.vertices.push( vertex );

                    uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
                    normals.push( vertex.clone().sub( center ).normalize() );

                }

            }

            for ( var j = 1; j <= radialSegments; j ++ ) {

                for ( var i = 1; i <= tubularSegments; i ++ ) {

                    var a = ( tubularSegments + 1 ) * j + i - 1;
                    var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
                    var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
                    var d = ( tubularSegments + 1 ) * j + i;

                    var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
                    this.faces.push( face );
                    this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

                    face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
                    this.faces.push( face );
                    this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

                }

            }

            this.computeFaceNormals();

        };

        THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
    }

    var createCircleGeometry = function ( radius, facing, arc ) {

        var geometry = new THREE.Geometry();
        arc = arc ? arc : 1;
        for ( var i = 0; i <= 64 * arc; ++i ) {
            if ( facing == 'x' ) geometry.vertices.push( new THREE.Vector3( 0, Math.cos( i / 32 * Math.PI ), Math.sin( i / 32 * Math.PI ) ).multiplyScalar(radius) );
            if ( facing == 'y' ) geometry.vertices.push( new THREE.Vector3( Math.cos( i / 32 * Math.PI ), 0, Math.sin( i / 32 * Math.PI ) ).multiplyScalar(radius) );
            if ( facing == 'z' ) geometry.vertices.push( new THREE.Vector3( Math.sin( i / 32 * Math.PI ), Math.cos( i / 32 * Math.PI ), 0 ).multiplyScalar(radius) );
        }

        return geometry;
    };

    var createArrowGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

        var arrowGeometry = new THREE.Geometry();
        var mesh = new THREE.Mesh( new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) );
        mesh.position.y = 0.5;
        mesh.updateMatrix();

        arrowGeometry.merge( mesh.geometry, mesh.matrix );

        return arrowGeometry;
    };

    var createLineGeometry = function ( axis ) {

        var lineGeometry = new THREE.Geometry();
        if ( axis === 'X') 
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 1, 0, 0 ) );
        else if ( axis === 'Y' ) 
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );
        else if ( axis === 'Z' )
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1 ) );

        return lineGeometry;
    };

    THREE.TransformGizmo = function () {

        var scope = this;
        var showPickers = false; //debug
        var showActivePlane = false; //debug

        this.init = function () {

            THREE.Object3D.call( this );

            this.handles = new THREE.Object3D();
            this.pickers = new THREE.Object3D();
            this.planes = new THREE.Object3D();
            this.highlights = new THREE.Object3D();
            this.hemiPicker = new THREE.Object3D();
            this.subPickers = new THREE.Object3D();

            this.add(this.handles);
            this.add(this.pickers);
            this.add(this.planes);
            this.add(this.highlights);
            this.add(this.hemiPicker);
            this.add(this.subPickers);

            //// PLANES

            var planeGeometry = new THREE.PlaneBufferGeometry( 50, 50, 2, 2 );
            var planeMaterial = new THREE.MeshBasicMaterial( { wireframe: true } );
            planeMaterial.side = THREE.DoubleSide;

            var planes = {
                "XY":   new THREE.Mesh( planeGeometry, planeMaterial ),
                "YZ":   new THREE.Mesh( planeGeometry, planeMaterial ),
                "XZ":   new THREE.Mesh( planeGeometry, planeMaterial ),
                "XYZE": new THREE.Mesh( planeGeometry, planeMaterial )
            };

            this.activePlane = planes["XYZE"];

            planes["YZ"].rotation.set( 0, Math.PI/2, 0 );
            planes["XZ"].rotation.set( -Math.PI/2, 0, 0 );

            for (var i in planes) {
                planes[i].name = i;
                this.planes.add(planes[i]);
                this.planes[i] = planes[i];
                planes[i].visible = false;
            }

            this.setupGizmos();
            this.activeMode = "";

            // reset Transformations

            this.traverse(function ( child ) {
                if (child instanceof THREE.Mesh) {
                    child.updateMatrix();

                    var tempGeometry = new THREE.Geometry();
                    if (child.geometry instanceof THREE.BufferGeometry) {
                        child.geometry = new THREE.Geometry().fromBufferGeometry( child.geometry );
                    }
                    tempGeometry.merge( child.geometry, child.matrix );

                    child.geometry = tempGeometry;
                    child.position.set( 0, 0, 0 );
                    child.rotation.set( 0, 0, 0 );
                    child.scale.set( 1, 1, 1 );
                }
            });

        };

        this.hide = function () {
            this.traverse(function( child ) {
                child.visible = false;
            });
        };

        this.show = function () {
            this.traverse(function( child ) {
                child.visible = true;
                if (child.parent == scope.pickers || child.parent == scope.hemiPicker ) child.visible = showPickers;
                if (child.parent == scope.planes ) child.visible = false;
            });
            this.activePlane.visible = showActivePlane;
        };

        this.highlight = function ( axis ) {
            this.traverse(function( child ) {
                if ( child.material && child.material.highlight ) {
                    if ( child.name == axis ) {
                        child.material.highlight( true );
                    } else {
                        child.material.highlight( false );
                    }
                }
            });
        };

        this.setupGizmos = function () {

            var addGizmos = function( gizmoMap, parent ) {

                for ( var name in gizmoMap ) {

                    for ( var i = gizmoMap[name].length; i--;) {

                        var object = gizmoMap[name][i][0];
                        var position = gizmoMap[name][i][1];
                        var rotation = gizmoMap[name][i][2];
                        var visble = gizmoMap[name][i][3];

                        object.name = name;

                        if ( position ) object.position.set( position[0], position[1], position[2] );
                        if ( rotation ) object.rotation.set( rotation[0], rotation[1], rotation[2] );
                        if ( visble ) object.visble = visble;

                        parent.add( object );

                    }

                }

            };

            this.setHandlePickerGizmos();

            addGizmos(this.handleGizmos, this.handles);
            addGizmos(this.pickerGizmos, this.pickers);
            addGizmos(this.highlightGizmos, this.highlights);
            addGizmos(this.hemiPickerGizmos, this.hemiPicker);
            addGizmos(this.subPickerGizmos, this.subPickers);

            this.hide();
            this.show();

        };

    };

    THREE.TransformGizmo.prototype = Object.create( THREE.Object3D.prototype );

    THREE.TransformGizmo.prototype.update = function ( rotation, eye ) {

        var vec1 = new THREE.Vector3( 0, 0, 0 );
        var vec2 = new THREE.Vector3( 0, 1, 0 );
        var lookAtMatrix = new THREE.Matrix4();

        this.traverse(function(child) {
            if ( child.name ) {
                if ( child.name.search("E") != -1 ) {
                    child.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( eye, vec1, vec2 ) );
                } else if ( child.name.search("X") != -1 || child.name.search("Y") != -1 || child.name.search("Z") != -1 ) {
                    child.quaternion.setFromEuler( rotation );
                }
            }
        });

    };

    THREE.TransformGizmoTranslate = function () {

        THREE.TransformGizmo.call( this );

        this.setHandlePickerGizmos = function () {

            var arrowGeometry = createArrowGeometry( 0, 0.05, 0.2, 12, 1, false );
            var lineXGeometry = createLineGeometry( 'X' );
            var lineYGeometry = createLineGeometry( 'Y' );
            var lineZGeometry = createLineGeometry( 'Z' );

            this.handleGizmos = {
                X: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xf12c2c } ) ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI/2 ] ],
                    [ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xf12c2c } ) ) ]
                ],
                Y: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0bb80b } ) ), [ 0, 0.5, 0 ] ],
                    [   new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x0bb80b } ) ) ]
                ],
                Z: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x2c2cf1 } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ],
                    [ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x2c2cf1 } ) ) ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.OctahedronGeometry( 0.1, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, 0 ] ]
                ],
                XY: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.15, 0.15, 0 ] ]
                ],
                YZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.15, 0.15 ], [ 0, Math.PI/2, 0 ] ]
                ],
                XZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.15, 0, 0.15 ], [ -Math.PI/2, 0, 0 ] ]
                ]
            };

            this.pickerGizmos = {
                X: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]
                ],
                Y: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0.6, 0 ] ]
                ],
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.6 ], [ Math.PI/2, 0, 0 ] ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.OctahedronGeometry( 0.2, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
                ],
                XY: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.2, 0.2, 0 ] ]
                ],
                YZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.2, 0.2 ], [ 0, Math.PI/2, 0 ] ]
                ],
                XZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.2, 0, 0.2 ], [ -Math.PI/2, 0, 0 ] ]
                ]
            };

            this.hemiPickerGizmos = {
                XYZ: [
                    [ new THREE.Mesh( new THREE.BoxGeometry( 1.2, 1.2, 1.2 ), new GizmoMaterial( { color: 0x0000ff } ) ), [ 0.5, 0.5, 0.5 ], null, false ]
                ]
            };

        };

        this.setActivePlane = function ( axis, eye ) {

            var tempMatrix = new THREE.Matrix4();
            eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

            if ( axis == "X" ) {
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ "XZ" ];
            }

            if ( axis == "Y" ){
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "Z" ){
                this.activePlane = this.planes[ "XZ" ];
                if ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "XYZ" ) this.activePlane = this.planes[ "XYZE" ];

            if ( axis == "XY" ) this.activePlane = this.planes[ "XY" ];

            if ( axis == "YZ" ) this.activePlane = this.planes[ "YZ" ];

            if ( axis == "XZ" ) this.activePlane = this.planes[ "XZ" ];

            this.hide();
            this.show();

        };

        this.init();

    };

    THREE.TransformGizmoTranslate.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformGizmoRotate = function () {

        THREE.TransformGizmo.call( this );

        this.setHandlePickerGizmos = function () {

            this.handleGizmos = {
                RX: [
                    [ new THREE.Line( createCircleGeometry(1,'x',0.5), new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
                ],
                RY: [
                    [ new THREE.Line( createCircleGeometry(1,'y',0.5), new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
                ],
                RZ: [
                    [ new THREE.Line( createCircleGeometry(1,'z',0.5), new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
                ],
                RE: [
                    [ new THREE.Line( createCircleGeometry(1.25,'z',1), new GizmoLineMaterial( { color: 0x00ffff } ) ) ]
                ],
                RXYZE: [
                    [ new THREE.Line( createCircleGeometry(1,'z',1), new GizmoLineMaterial( { color: 0xff00ff } ) ) ]
                ]
            };

            this.pickerGizmos = {
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, -Math.PI/2, -Math.PI/2 ] ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, 0 ] ]
                ],
                RZ: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]
                ],
                RE: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1.25, 0.12, 2, 24 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ) ]
                ],
                RXYZE: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 2, 24 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ) ]
                ]
            };

        };

        this.setActivePlane = function ( axis ) {

            if ( axis == "RE" ) this.activePlane = this.planes[ "XYZE" ];

            if ( axis == "RX" ) this.activePlane = this.planes[ "YZ" ];

            if ( axis == "RY" ) this.activePlane = this.planes[ "XZ" ];

            if ( axis == "RZ" ) this.activePlane = this.planes[ "XY" ];

            this.hide();
            this.show();

        };

        this.update = function ( rotation, eye2 ) {

            THREE.TransformGizmo.prototype.update.apply( this, arguments );

            var tempMatrix = new THREE.Matrix4();
            var worldRotation = new THREE.Euler( 0, 0, 1 );
            var tempQuaternion = new THREE.Quaternion();
            var unitX = new THREE.Vector3( 1, 0, 0 );
            var unitY = new THREE.Vector3( 0, 1, 0 );
            var unitZ = new THREE.Vector3( 0, 0, 1 );
            var quaternionX = new THREE.Quaternion();
            var quaternionY = new THREE.Quaternion();
            var quaternionZ = new THREE.Quaternion();
            var eye = eye2.clone();

            worldRotation.copy( this.planes["XY"].rotation );
            tempQuaternion.setFromEuler( worldRotation );

            tempMatrix.makeRotationFromQuaternion( tempQuaternion ).getInverse( tempMatrix );
            eye.applyMatrix4( tempMatrix );

            this.traverse(function(child) {

                tempQuaternion.setFromEuler( worldRotation );

                if ( child.name == "RX" ) {
                    quaternionX.setFromAxisAngle( unitX, Math.atan2( -eye.y, eye.z ) );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                    child.quaternion.copy( tempQuaternion );
                }

                if ( child.name == "RY" ) {
                    quaternionY.setFromAxisAngle( unitY, Math.atan2( eye.x, eye.z ) );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
                    child.quaternion.copy( tempQuaternion );
                }

                if ( child.name == "RZ" ) {
                    quaternionZ.setFromAxisAngle( unitZ, Math.atan2( eye.y, eye.x ) );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );
                    child.quaternion.copy( tempQuaternion );
                }

            });

        };

        this.init();

    };

    THREE.TransformGizmoRotate.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformGizmoTranslateRotate = function () {

        THREE.TransformGizmo.call( this );

        var scope = this;

        this.setHandlePickerGizmos = function () {

            var arrowGeometry = createArrowGeometry( 0, 0.05, 0.2, 12, 1, false );
            var lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, -0.1 ), new THREE.Vector3( 0, 0, 0.1 ), new THREE.Vector3( -0.1, 0, 0 ), new THREE.Vector3( 0.1, 0, 0 ) );
            var theta = 0.15;

            this.handleGizmos = {
                Z: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xffffff } ) ), [ 0, 0, 0.25 ], [ Math.PI/2, 0, 0 ] ],
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.015, 0.015, 0.6, 4, 1, false ), new GizmoMaterial( { color: 0xffffff } ) ), [ 0, 0, 0.5 ],[ Math.PI/2, 0, 0 ] ]
                ],
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.015, 12, 60, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0xff0000 } ) ), [ 0, 0, 0 ], [ theta * Math.PI, -Math.PI/2, 0 ] ],
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.05, 0.05, 0.015, 60, 1, false ), new GizmoMaterial( { color: 0xff0000 } ) ), [ 0, 0, 1 ], [ Math.PI/2, 0, 0 ] ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.015, 12, 60, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, (0.5-theta)*Math.PI ] ],
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.05, 0.05, 0.01, 60, 1, false ), new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 1 ] ]
                ]
            };

            this.pickerGizmos = {
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.12, 0.12, 0.65, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ]
                ],
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ theta * Math.PI, -Math.PI/2, 0 ] ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, (0.5-theta)*Math.PI ] ]
                ]
            };

            this.subPickerGizmos = {
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.12, 0.12, 0.65, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ]
                ]
            };

            this.highlightGizmos = {
                Z: [
                ],
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.02, 12, 60, 2 * Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 1 } ) ), [ 0, 0, 0 ], [ 0, -Math.PI/2, -Math.PI/2 ], false ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.02, 12, 60, 2 * Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 1 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, 0 ], false ]
                ]
            };

            this.hemiPickerGizmos = {
                XYZ: [
                    [ new THREE.Mesh( new THREE.SphereGeometry( 1.2, 8, 8, 0, Math.PI ), new GizmoMaterial( { color: 0x0000ff } ) ), null, null, false ]
                ]
            };

        };

        this.setActivePlane = function ( axis, eye ) {

            if ( this.activeMode == "translate" ) {

                var tempMatrix = new THREE.Matrix4();
                eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

                if ( axis == "X" ) {
                    this.activePlane = this.planes[ "XY" ];
                    if ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ "XZ" ];
                }

                if ( axis == "Y" ){
                    this.activePlane = this.planes[ "XY" ];
                    if ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ "YZ" ];
                }

                if ( axis == "Z" ){
                    this.activePlane = this.planes[ "XZ" ];
                    if ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ "YZ" ];
                }

            } else if ( this.activeMode == "rotate" ){

                if ( axis == "RX" ) this.activePlane = this.planes[ "YZ" ];

                if ( axis == "RY" ) this.activePlane = this.planes[ "XZ" ];

                if ( axis == "RZ" ) this.activePlane = this.planes[ "XY" ];

            }

            this.hide();
            this.show();

        };

        this.update = function ( rotation, eye2 ) {

            if ( this.activeMode == "translate" ) {

                THREE.TransformGizmo.prototype.update.apply( this, arguments );

            } else if ( this.activeMode == "rotate" ) {

                THREE.TransformGizmo.prototype.update.apply( this, arguments );

                var tempMatrix = new THREE.Matrix4();
                var worldRotation = new THREE.Euler( 0, 0, 1 );
                var tempQuaternion = new THREE.Quaternion();
                var unitX = new THREE.Vector3( 1, 0, 0 );
                var unitY = new THREE.Vector3( 0, 1, 0 );
                var unitZ = new THREE.Vector3( 0, 0, 1 );
                var quaternionX = new THREE.Quaternion();
                var quaternionY = new THREE.Quaternion();
                var quaternionZ = new THREE.Quaternion();
                var eye = eye2.clone();

                worldRotation.copy( this.planes["XY"].rotation );
                tempQuaternion.setFromEuler( worldRotation );

                tempMatrix.makeRotationFromQuaternion( tempQuaternion ).getInverse( tempMatrix );
                eye.applyMatrix4( tempMatrix );

                this.traverse(function(child) {

                    tempQuaternion.setFromEuler( worldRotation );

                    if ( child.name == "RX" ) {
                        quaternionX.setFromAxisAngle( unitX, Math.atan2( -eye.y, eye.z ) );
                        tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                        child.quaternion.copy( tempQuaternion );
                    }

                    if ( child.name == "RY" ) {
                        quaternionY.setFromAxisAngle( unitY, Math.atan2( eye.x, eye.z ) );
                        tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
                        child.quaternion.copy( tempQuaternion );
                    }

                    if ( child.name == "RZ" ) {
                        quaternionZ.setFromAxisAngle( unitZ, Math.atan2( eye.y, eye.x ) );
                        tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );
                        child.quaternion.copy( tempQuaternion );
                    }

                });

            }

        };

        this.show = function () {
            this.traverse(function( child ) {
                if ( scope.parent == null || (scope.parent.useAllPickers || child.parent != scope.handles) ) child.visible = true;
                if ( child.material ) child.material.opacity = child.material.oldOpacity;
                if ( child.parent == scope.pickers || child.parent == scope.hemiPicker || child.parent == scope.subPickers) child.visible = false;
                if ( child.parent == scope.planes || child.parent == scope.highlights ) child.visible = false;
            });
            this.activePlane.visible = false;
        };

        this.highlight = function ( axis ) {
            this.traverse(function( child ) {
                if ( child.material && child.material.highlight ) {
                    if ( child.name == axis ) {
                        if ( child.parent == scope.highlights || child.parent == scope.handles ) child.visible = true;
                        child.material.highlight( true );
                    } else {
                        child.material.highlight( false );
                        child.material.opacity = 0.1;
                    }
                }
            });
        };

        this.init();

    };

    THREE.TransformGizmoTranslateRotate.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformGizmoScale = function () {

        THREE.TransformGizmo.call( this );

        this.setHandlePickerGizmos = function () {

            var arrowGeometry = createArrowGeometry( 0.125, 0.125, 0.125 );
            var lineXGeometry = createLineGeometry( 'X' );
            var lineYGeometry = createLineGeometry( 'Y' );
            var lineZGeometry = createLineGeometry( 'Z' );

            this.handleGizmos = {
                X: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xff0000 } ) ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI/2 ] ],
                    [ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
                ],
                Y: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x00ff00 } ) ), [ 0, 0.5, 0 ] ],
                    [ new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
                ],
                Z: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ],
                    [ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.BoxGeometry( 0.125, 0.125, 0.125 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
                ]
            };

            this.pickerGizmos = {
                X: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]
                ],
                Y: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0.6, 0 ] ]
                ],
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.6 ], [ Math.PI/2, 0, 0 ] ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.BoxGeometry( 0.4, 0.4, 0.4 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
                ]
            };

        };

        this.setActivePlane = function ( axis, eye ) {

            var tempMatrix = new THREE.Matrix4();
            eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

            if ( axis == "X" ) {
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ "XZ" ];
            }

            if ( axis == "Y" ){
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "Z" ){
                this.activePlane = this.planes[ "XZ" ];
                if ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "XYZ" ) this.activePlane = this.planes[ "XYZE" ];

            this.hide();
            this.show();

        };

        this.init();

    };

    THREE.TransformGizmoScale.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformControls = function ( camera, domElement, mode ) {

        // TODO: Make non-uniform scale and rotate play nice in hierarchies
        // TODO: ADD RXYZ contol

        THREE.Object3D.call( this );

        domElement = ( domElement !== undefined ) ? domElement : document;

        this.gizmo = {};
        switch ( mode ) {
            case "translate":
                this.gizmo[mode] = new THREE.TransformGizmoTranslate();
                break;
            case "rotate":           
               this.gizmo[mode] = new THREE.TransformGizmoRotate();
               break;
            case "transrotate":
                this.gizmo[mode] = new THREE.TransformGizmoTranslateRotate();
                break;
            case "scale":
                this.gizmo[mode] = new THREE.TransformGizmoScale();
                break;
        }

        this.add(this.gizmo[mode]);
        this.gizmo[mode].hide();

        this.object = undefined;
        this.snap = null;
        this.snapDelta = 0;
        this.space = "world";
        this.size = 1;
        this.axis = null;
        this.useAllPickers = true;

        this.unitX = new THREE.Vector3( 1, 0, 0 );
        this.unitY = new THREE.Vector3( 0, 1, 0 );
        this.unitZ = new THREE.Vector3( 0, 0, 1 );
        this.normal = new THREE.Vector3(0, 0, 1);

        if ( mode === "transrotate" ) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push( new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1) );
            var material = new THREE.LineBasicMaterial( {color: 0x000000, linewidth:2, depthTest: false} );
            this.startLine = new THREE.Line( geometry, material );
            var geometry = new THREE.Geometry();
            var material = new THREE.LineBasicMaterial( {color: 0xffe603, linewidth:2, depthTest: false} );
            geometry.vertices.push( new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1) );
            this.endLine = new THREE.Line( geometry, material );
            var geometry = new THREE.Geometry();
            var material = new THREE.LineDashedMaterial({color: 0x000000, linewidth:1, depthTest: false});
            geometry.vertices.push( new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0) );
            this.centerLine = new THREE.Line( geometry, material );

            var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl("res/textures/centerMarker_X.png"));
            map.magFilter = map.minFilter = THREE.NearestFilter;
            var geometry = new THREE.CircleGeometry( 0.1, 32 );
            var material = new THREE.MeshBasicMaterial({opacity: 1, side: THREE.DoubleSide, transparent:true, map:map});
            this.centerMark = new THREE.Mesh( geometry, material );
            this.centerMark.rotation.set(Math.PI/2, 0, 0);

            this.ticks = {};
            var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl("res/textures/cardinalPoint.png"));
            map.magFilter = map.minFilter = THREE.NearestFilter;
            var material = new THREE.MeshBasicMaterial({depthTest: false, opacity: 1, transparent:true, side: THREE.DoubleSide, map:map});
            var w = 0.12, h = 0.25, d = 1.15;

            this.ticks["RX"] = new THREE.Object3D();
            var geometry = new THREE.PlaneBufferGeometry(w, h);
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, -d-h/2);
            mesh.rotation.set(Math.PI/2, Math.PI/2, 0);
            this.ticks["RX"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, d+h/2, 0);
            mesh.rotation.set(0, Math.PI/2, 0);
            this.ticks["RX"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, 0, d+h/2);
            mesh.rotation.set(0, Math.PI/2, Math.PI/2);
            this.ticks["RX"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, -d-h/2, 0);
            mesh.rotation.set(0, Math.PI/2, 0);
            this.ticks["RX"].add(mesh);

            this.ticks["RY"] = new THREE.Object3D();
            mesh = mesh.clone();
            mesh.position.set(0, 0, -d-h/2);
            mesh.rotation.set(Math.PI/2, 0, 0);
            this.ticks["RY"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(-d-h/2, 0, 0);
            mesh.rotation.set(Math.PI/2, 0, Math.PI/2);
            this.ticks["RY"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, 0, d+h/2);
            mesh.rotation.set(Math.PI/2, 0, 0);
            this.ticks["RY"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(d+h/2, 0, 0);
            mesh.rotation.set(Math.PI/2, 0, Math.PI/2);
            this.ticks["RY"].add(mesh);
        }

        var scope = this;

        var _dragging = false;
        var _mode = mode;
        var _plane = "XY";

        var changeEvent = { type: "change" };
        var mouseDownEvent = { type: "mouseDown" };
        var mouseUpEvent = { type: "mouseUp", mode: _mode };
        var objectChangeEvent = { type: "objectChange" };

        var ray = new THREE.Raycaster();
        var pointerVector = new THREE.Vector3();
        var pointerDir = new THREE.Vector3();

        var point = new THREE.Vector3();
        var offset = new THREE.Vector3();

        var rotation = new THREE.Vector3();
        var offsetRotation = new THREE.Vector3();
        var scale = 1;

        var lookAtMatrix = new THREE.Matrix4();
        var eye = new THREE.Vector3();

        var tempMatrix = new THREE.Matrix4();
        var tempVector = new THREE.Vector3();
        var tempQuaternion = new THREE.Quaternion();
        var projX = new THREE.Vector3();
        var projY = new THREE.Vector3();
        var projZ = new THREE.Vector3();

        var quaternionXYZ = new THREE.Quaternion();
        var quaternionX = new THREE.Quaternion();
        var quaternionY = new THREE.Quaternion();
        var quaternionZ = new THREE.Quaternion();
        var quaternionE = new THREE.Quaternion();

        var oldPosition = new THREE.Vector3();
        var oldScale = new THREE.Vector3();
        var oldRotationMatrix = new THREE.Matrix4();

        var parentRotationMatrix  = new THREE.Matrix4();
        var parentScale = new THREE.Vector3();

        var worldPosition = new THREE.Vector3();
        var worldRotation = new THREE.Euler();
        var worldRotationMatrix  = new THREE.Matrix4();
        var camPosition = new THREE.Vector3();
        var camRotation = new THREE.Euler();

        this.attach = function ( object ) {

            scope.object = object;

            this.gizmo[_mode].show();

            scope.update();

            scope.updateUnitVectors();

        };

        this.detach = function ( object ) {

            scope.object = undefined;
            this.axis = null;

            this.gizmo[_mode].hide();

        };

        this.setMode = function ( mode ) {

            _mode = mode ? mode : _mode;

            if ( _mode == "scale" ) scope.space = "local";

            this.gizmo[_mode].show();

            this.update();
            scope.dispatchEvent( changeEvent );

        };

        this.getPicker = function () {

            return scope.gizmo[_mode].hemiPicker.children;

        };

        this.setPosition = function ( position ) {

            this.object.position.copy ( position );
            this.update();
        
        };

        this.setNormal = function ( normal ) {

            tempQuaternion.setFromUnitVectors( this.normal, normal );
            this.unitX.applyQuaternion( tempQuaternion );
            this.unitY.applyQuaternion( tempQuaternion );
            this.unitZ.applyQuaternion( tempQuaternion );
            this.normal.copy( normal );
            if (this.object) {
                this.object.quaternion.multiply ( tempQuaternion );
            }
            this.update();
        };

        this.setSnap = function ( snap, delta ) {

            scope.snap = snap;
            scope.snapDelta = delta;

        };

        this.setSize = function ( size ) {

            scope.size = size;
            this.update();
            scope.dispatchEvent( changeEvent );

        };

        this.setSpace = function ( space ) {

            scope.space = space;
            this.update();
            scope.dispatchEvent( changeEvent );

        };

        this.update = function (highlight) {

            if ( scope.object === undefined ) return;

            scope.object.updateMatrixWorld();
            worldPosition.setFromMatrixPosition( scope.object.matrixWorld );
            worldRotation.setFromRotationMatrix( tempMatrix.extractRotation( scope.object.matrixWorld ) );

            camera.updateMatrixWorld();
            camPosition.setFromMatrixPosition( camera.matrixWorld );
            //camRotation.setFromRotationMatrix( tempMatrix.extractRotation( camera.matrixWorld ) );

            this.position.copy( worldPosition );

            this.quaternion.setFromEuler( worldRotation );

            this.normal.set( 0, 0, 1 );
            this.normal.applyEuler( worldRotation );

            // keep same screen height (100px)
            var dist = worldPosition.distanceTo( camPosition );
            var height = camera.isPerspective? 2 * Math.tan( camera.fov * Math.PI / 360 ) * dist : dist;
            var rect = domElement.getBoundingClientRect();
            scale = 100 * height / rect.height;
            this.scale.set( scale, scale, scale );

            //eye.copy( camPosition ).sub( worldPosition ).normalize();

            //if ( scope.space == "local" )
            //    this.gizmo[_mode].update( worldRotation, eye );
            //else if ( scope.space == "world" )
            //    this.gizmo[_mode].update( new THREE.Euler(), eye );

            if (highlight)
                this.gizmo[_mode].highlight( scope.axis );

        };

        this.updateUnitVectors = function () {

            this.unitX.set( 1, 0, 0 );
            this.unitY.set( 0, 1, 0 );
            this.unitZ.set( 0, 0, 1 );
            this.unitX.applyEuler( worldRotation );
            this.unitY.applyEuler( worldRotation );
            this.unitZ.applyEuler( worldRotation );

        };

        this.showRotationGizmos = function (set) {

            var handles = this.gizmo[_mode].handles.children;
            for ( var i = 0; i < handles.length; i++ ) {
                var child = handles[i];
                child.visible = true;
                if ( child.name.search("R") !== -1 ) child.visible = set;
            }
            this.useAllPickers = set;
            
        };

        this.highlight = function () {

            this.gizmo[_mode].highlight( this.axis || "Z" );

        };

        this.onPointerHover = function( event ) {

            if ( scope.object === undefined || _dragging === true ) return false;

            var pointer = event.pointers ? event.pointers[ 0 ] : event;

            var intersect = intersectObjects( pointer, scope.useAllPickers? scope.gizmo[_mode].pickers.children: scope.gizmo[_mode].subPickers.children );

            var axis = null;
            var mode = "";

            if ( intersect ) {

                axis = intersect.object.name;
                mode = axis.search("R") != -1 ? "rotate" : "translate";

            }

            if ( scope.axis !== axis ) {

                scope.axis = axis;
                scope.gizmo[_mode].activeMode = mode;
                scope.update(true);
                scope.dispatchEvent( changeEvent );

            } 

            if (scope.axis === null) {

                scope.gizmo[_mode].show();
            
            }

            return intersect? true : false;

        }

        this.onPointerDown = function( event ) {

            if ( scope.object === undefined || _dragging === true ) return false;
            
            var pointer = event.pointers ? event.pointers[ 0 ] : event;

            if ( event.pointerType === 'touch' ) {

                var intersect = intersectObjects( pointer, scope.useAllPickers? scope.gizmo[_mode].pickers.children: scope.gizmo[_mode].subPickers.children );

                var axis = null;
                var mode = "";

                if ( intersect ) {

                    axis = intersect.object.name;
                    mode = axis.search("R") != -1 ? "rotate" : "translate";

                }

                if ( scope.axis !== axis ) {

                    scope.axis = axis;
                    scope.gizmo[_mode].activeMode = mode;
                }
            }

            var intersect = null;

            if ( pointer.button === 0 || pointer.button === undefined ) {

                intersect = intersectObjects( pointer, scope.useAllPickers? scope.gizmo[_mode].pickers.children: scope.gizmo[_mode].subPickers.children );

                if ( intersect ) {

                    scope.dispatchEvent( mouseDownEvent );

                    scope.axis = intersect.object.name;

                    scope.update();

                    eye.copy( camera.position ).sub( worldPosition ).normalize();

                    scope.gizmo[_mode].setActivePlane( scope.axis, eye );

                    var planeIntersect = intersectObjects( pointer, [scope.gizmo[_mode].activePlane] );

                    if ( planeIntersect )
                        offset.copy( planeIntersect.point );

                    oldPosition.copy( scope.object.position );
                    oldScale.copy( scope.object.scale );

                    oldRotationMatrix.extractRotation( scope.object.matrix );
                    worldRotationMatrix.extractRotation( scope.object.matrixWorld );

                    if ( scope.object.parent ) {
                        parentRotationMatrix.extractRotation( scope.object.parent.matrixWorld );
                        parentScale.setFromMatrixScale( tempMatrix.getInverse( scope.object.parent.matrixWorld ) );
                    } else {
                        parentRotationMatrix.extractRotation( scope.object.matrixWorld );
                        parentScale.setFromMatrixScale( tempMatrix.getInverse( scope.object.matrixWorld ) );
                    }

                    // show rotation start line and ticks
                    if ( _mode === "transrotate" && scope.gizmo[_mode].activeMode === "rotate" ) {
                        scope.startLine.geometry.vertices[0].set(0, 0, 0).applyMatrix4( scope.matrixWorld );
                        scope.startLine.geometry.vertices[1].set(0, 0, 1).applyMatrix4( scope.matrixWorld );
                        scope.startLine.geometry.verticesNeedUpdate = true;
                        scope.parent.add( scope.startLine );

                        var pos = scope.object.geometry.getAttribute('position');
                        var pt1 = new THREE.Vector3().fromAttribute(pos, 0).applyMatrix4( scope.object.matrixWorld );
                        var pt2 = new THREE.Vector3().fromAttribute(pos, 1).applyMatrix4( scope.object.matrixWorld );
                        var pt3 = new THREE.Vector3().fromAttribute(pos, 2).applyMatrix4( scope.object.matrixWorld );
                        var pt4 = new THREE.Vector3().fromAttribute(pos, 3).applyMatrix4( scope.object.matrixWorld );
                        if (scope.axis === "RX") {
                            pt1.lerp(pt3, 0.5);
                            pt2.lerp(pt4, 0.5);
                            var dist = pt1.distanceTo(pt2);
                            scope.centerLine.material.dashSize = dist / 15;
                            scope.centerLine.material.gapSize = dist / 30;
                            scope.centerLine.geometry.vertices[0].copy(pt1);
                            scope.centerLine.geometry.vertices[1].copy(pt2);
                        } else {
                            pt1.lerp(pt2, 0.5);
                            pt3.lerp(pt4, 0.5);
                            var dist = pt1.distanceTo(pt3);
                            scope.centerLine.material.dashSize = dist / 15;
                            scope.centerLine.material.gapSize = dist / 30;
                            scope.centerLine.geometry.vertices[0].copy(pt1);
                            scope.centerLine.geometry.vertices[1].copy(pt3);
                        }
                        scope.centerLine.geometry.computeLineDistances();
                        scope.centerLine.geometry.verticesNeedUpdate = true;
                        scope.parent.add( scope.centerLine );

                        scope.ticks[scope.axis].position.copy( scope.position );
                        scope.ticks[scope.axis].quaternion.copy( scope.quaternion );
                        scope.ticks[scope.axis].scale.copy( scope.scale );
                        scope.parent.add( scope.ticks[scope.axis] );
                    }

                }

            }

            _dragging = true;

            return intersect? true: false;

        }

        this.onPointerMove = function( event ) {

            if ( scope.object === undefined || scope.axis === null || _dragging === false ) return false;

            var pointer = event.pointers ? event.pointers[ 0 ] : event;

            var planeIntersect = intersectObjects( pointer, [scope.gizmo[_mode].activePlane] );

            if ( planeIntersect )
                point.copy( planeIntersect.point );

            var mode = scope.gizmo[_mode].activeMode;
            if ( mode == "translate" ) {

                point.sub( offset );
                point.multiply(parentScale);

                if ( scope.space == "local" ) {

                    point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                    projX.copy( this.unitX );
                    projY.copy( this.unitY );
                    projZ.copy( this.unitZ );
                    tempVector.set( 0, 0, 0 );
                    if ( scope.axis.search("X") != -1 ) {
                        projX.multiplyScalar( point.dot( this.unitX ) );
                        tempVector.add( projX );
                    }
                    if ( scope.axis.search("Y") != -1 ) {
                        projY.multiplyScalar( point.dot( this.unitY ) );
                        tempVector.add(projY);
                    }
                    if ( scope.axis.search("Z") != -1 ) {
                        projZ.multiplyScalar( point.dot( this.unitZ ) );
                        tempVector.add( projZ );
                    }
                    point.copy( tempVector );

                    point.applyMatrix4( oldRotationMatrix );

                    scope.object.position.copy( oldPosition );
                    scope.object.position.add( point );

                }

                if ( scope.space == "world" || scope.axis.search("XYZ") != -1 ) {

                    projX.copy( this.unitX );
                    projY.copy( this.unitY );
                    projZ.copy( this.unitZ );
                    tempVector.set( 0, 0, 0 );
                    if ( scope.axis.search("X") != -1 ) {
                        projX.multiplyScalar( point.dot( this.unitX ) );
                        tempVector.add( projX );
                    }
                    if ( scope.axis.search("Y") != -1 ) {
                        projY.multiplyScalar( point.dot( this.unitY ) );
                        tempVector.add(projY);
                    }
                    if ( scope.axis.search("Z") != -1 ) {
                        projZ.multiplyScalar( point.dot( this.unitZ ) );
                        tempVector.add( projZ );
                    }
                    point.copy( tempVector );

                    point.applyMatrix4( tempMatrix.getInverse( parentRotationMatrix ) );

                    scope.object.position.copy( oldPosition );
                    scope.object.position.add( point );

                }

            } else if ( mode == "scale" ) {

                point.sub( offset );
                point.multiply(parentScale);

                if ( scope.space == "local" ) {

                    if ( scope.axis == "XYZ") {

                        scale = 1 + ( ( point.y ) / 50 );

                        scope.object.scale.x = oldScale.x * scale;
                        scope.object.scale.y = oldScale.y * scale;
                        scope.object.scale.z = oldScale.z * scale;

                    } else {

                        point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                        if ( scope.axis == "X" ) scope.object.scale.x = oldScale.x * ( 1 + point.x / 50 );
                        if ( scope.axis == "Y" ) scope.object.scale.y = oldScale.y * ( 1 + point.y / 50 );
                        if ( scope.axis == "Z" ) scope.object.scale.z = oldScale.z * ( 1 + point.z / 50 );

                    }

                }

            } else if ( mode == "rotate") {

                point.sub( worldPosition );
                point.multiply(parentScale);
                tempVector.copy(offset).sub( worldPosition );
                tempVector.multiply(parentScale);

                if ( scope.axis == "RE" ) {

                    point.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );
                    tempVector.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );

                    rotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );
                    offsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );

                    tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

                    var rotz = rotation.z - offsetRotation.z;
                    if ( scope.snap !== null ) {
                        var rotsnap = Math.round( rotz / scope.snap ) * scope.snap;
                        if ( Math.abs(rotsnap-rotz) < scope.snapDelta ) {
                            rotz = rotsnap;
                        }
                    }
                    quaternionE.setFromAxisAngle( eye, rotz );
                    quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionE );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

                    scope.object.quaternion.copy( tempQuaternion );

                } else if ( scope.axis == "RXYZE" ) {

                    var tempAxis = point.clone().cross(tempVector).normalize(); // rotation axis

                    tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

                    var rot = - point.clone().angleTo(tempVector);
                    if ( scope.snap !== null ) {
                        var rotsnap = Math.round( rot / scope.snap ) * scope.snap;
                        if ( Math.abs(rotsnap-rot) < scope.snapDelta ) {
                            rot = rotsnap;
                        }
                    }
                    quaternionX.setFromAxisAngle( tempAxis, rot );
                    quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

                    scope.object.quaternion.copy( tempQuaternion );

                } else if ( scope.space == "local" ) {

                    point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                    tempVector.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                    var projx = point.dot(this.unitX), projy = point.dot(this.unitY), projz = point.dot(this.unitZ);
                    var tempx = tempVector.dot(this.unitX), tempy = tempVector.dot(this.unitY), tempz = tempVector.dot(this.unitZ);
                    rotation.set( Math.atan2( projz, projy ), Math.atan2( projx, projz ), Math.atan2( projy, projx ) );
                    offsetRotation.set( Math.atan2( tempz, tempy ), Math.atan2( tempx, tempz ), Math.atan2( tempy, tempx ) );

                    var rotx = rotation.x - offsetRotation.x;
                    var roty = rotation.y - offsetRotation.y;
                    var rotz = rotation.z - offsetRotation.z;
                    if ( scope.snap !== null ) {
                        if ( scope.axis.search("X") != -1 ) {
                            var rotsnap = Math.round( rotx / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotx) < scope.snapDelta ) {
                                rotx = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Y") != -1 ) {
                            var rotsnap = Math.round( roty / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-roty) < scope.snapDelta ) {
                                roty = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Z") != -1 ) {
                            var rotsnap = Math.round( rotz / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotz) < scope.snapDelta ) {
                                rotz = rotsnap;
                            }
                        }
                    }
                    quaternionX.setFromAxisAngle( this.unitX, rotx );
                    quaternionY.setFromAxisAngle( this.unitY, roty );
                    quaternionZ.setFromAxisAngle( this.unitZ, rotz );
                    quaternionXYZ.setFromRotationMatrix( oldRotationMatrix );

                    if ( scope.axis == "RX" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionX );
                    if ( scope.axis == "RY" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionY );
                    if ( scope.axis == "RZ" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionZ );

                    scope.object.quaternion.copy( quaternionXYZ );

                } else if ( scope.space == "world" ) {

                    var projx = point.dot(this.unitX), projy = point.dot(this.unitY), projz = point.dot(this.unitZ);
                    var tempx = tempVector.dot(this.unitX), tempy = tempVector.dot(this.unitY), tempz = tempVector.dot(this.unitZ);
                    rotation.set( Math.atan2( projz, projy ), Math.atan2( projx, projz ), Math.atan2( projy, projx ) );
                    offsetRotation.set( Math.atan2( tempz, tempy ), Math.atan2( tempx, tempz ), Math.atan2( tempy, tempx ) );

                    tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

                    var rotx = rotation.x - offsetRotation.x;
                    var roty = rotation.y - offsetRotation.y;
                    var rotz = rotation.z - offsetRotation.z;
                    if ( scope.snap !== null ) {
                        if ( scope.axis.search("X") != -1 ) {
                            var rotsnap = Math.round( rotx / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotx) < scope.snapDelta ) {
                                rotx = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Y") != -1 ) {
                            var rotsnap = Math.round( roty / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-roty) < scope.snapDelta ) {
                                roty = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Z") != -1 ) {
                            var rotsnap = Math.round( rotz / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotz) < scope.snapDelta ) {
                                rotz = rotsnap;
                            }
                        }
                    }
                    quaternionX.setFromAxisAngle( this.unitX, rotx );
                    quaternionY.setFromAxisAngle( this.unitY, roty );
                    quaternionZ.setFromAxisAngle( this.unitZ, rotz );
                    quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

                    if ( scope.axis == "RX" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                    if ( scope.axis == "RY" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
                    if ( scope.axis == "RZ" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );

                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

                    scope.object.quaternion.copy( tempQuaternion );

                }

                // show rotation end line
                if (_mode === "transrotate" ) {
                    scope.add( scope.endLine );
                    scope.add( scope.centerMark );
                }

            }

            // update matrix
            scope.object.matrixAutoUpdate = true;

            scope.update(true);
            scope.dispatchEvent( changeEvent );
            scope.dispatchEvent( objectChangeEvent );

            return planeIntersect? true : false;

        }

        this.onPointerUp = function( event ) {

            if ( _dragging && ( scope.axis !== null ) ) {
                mouseUpEvent.mode = _mode;
                scope.dispatchEvent( mouseUpEvent )
            }
            _dragging = false;

            this.gizmo[_mode].show();

            this.updateUnitVectors();

            // remove rotation start/end lines
            if ( _mode === "transrotate" && this.gizmo[_mode].activeMode === "rotate" ) {
                this.remove( this.endLine );
                this.remove( this.centerMark );
                this.parent.remove( this.centerLine );
                this.parent.remove( this.startLine );
                this.parent.remove( this.ticks[this.axis] );
            }

            return false;

        }

        function intersectObjects( pointer, objects ) {

            var rect = domElement.getBoundingClientRect();
            var x = ( ( pointer.clientX - rect.left ) / rect.width ) * 2 - 1;
            var y = - ( ( pointer.clientY - rect.top ) / rect.height ) * 2 + 1;
          
            if ( camera.isPerspective ) {
                pointerVector.set( x, y, 0.5 );
                pointerVector.unproject( camera );
                ray.set( camera.position, pointerVector.sub( camera.position ).normalize() );
            } else {
                pointerVector.set( x, y, -1 );
                pointerVector.unproject( camera );
                pointerDir.set( 0, 0, -1 );
                ray.set( pointerVector, pointerDir.transformDirection( camera.matrixWorld ) );
            }

            var intersections = ray.intersectObjects( objects, true );
            return intersections[0] ? intersections[0] : false;

        }

    };

    THREE.TransformControls.prototype = Object.create( THREE.Object3D.prototype );

};
